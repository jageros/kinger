// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: shop.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type UpdateShopDataArg_DataType int32

const (
	UpdateShopDataArg_Unknow          UpdateShopDataArg_DataType = 0
	UpdateShopDataArg_LimitGift       UpdateShopDataArg_DataType = 1
	UpdateShopDataArg_SoldTreasure    UpdateShopDataArg_DataType = 2
	UpdateShopDataArg_RecruitTreasure UpdateShopDataArg_DataType = 3
	UpdateShopDataArg_Jade            UpdateShopDataArg_DataType = 4
	UpdateShopDataArg_Gold            UpdateShopDataArg_DataType = 5
	UpdateShopDataArg_FreeAds         UpdateShopDataArg_DataType = 6
	UpdateShopDataArg_Vip             UpdateShopDataArg_DataType = 7
	UpdateShopDataArg_RandomShop      UpdateShopDataArg_DataType = 8
	UpdateShopDataArg_GoldGift        UpdateShopDataArg_DataType = 9
	UpdateShopDataArg_RecommendGift   UpdateShopDataArg_DataType = 10
)

var UpdateShopDataArg_DataType_name = map[int32]string{
	0:  "Unknow",
	1:  "LimitGift",
	2:  "SoldTreasure",
	3:  "RecruitTreasure",
	4:  "Jade",
	5:  "Gold",
	6:  "FreeAds",
	7:  "Vip",
	8:  "RandomShop",
	9:  "GoldGift",
	10: "RecommendGift",
}
var UpdateShopDataArg_DataType_value = map[string]int32{
	"Unknow":          0,
	"LimitGift":       1,
	"SoldTreasure":    2,
	"RecruitTreasure": 3,
	"Jade":            4,
	"Gold":            5,
	"FreeAds":         6,
	"Vip":             7,
	"RandomShop":      8,
	"GoldGift":        9,
	"RecommendGift":   10,
}

func (x UpdateShopDataArg_DataType) String() string {
	return proto.EnumName(UpdateShopDataArg_DataType_name, int32(x))
}
func (UpdateShopDataArg_DataType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorShop, []int{4, 0}
}

type RecruitTreasureData_RewardType int32

const (
	RecruitTreasureData_Unknow RecruitTreasureData_RewardType = 0
	RecruitTreasureData_Card   RecruitTreasureData_RewardType = 1
	RecruitTreasureData_Skin   RecruitTreasureData_RewardType = 2
)

var RecruitTreasureData_RewardType_name = map[int32]string{
	0: "Unknow",
	1: "Card",
	2: "Skin",
}
var RecruitTreasureData_RewardType_value = map[string]int32{
	"Unknow": 0,
	"Card":   1,
	"Skin":   2,
}

func (x RecruitTreasureData_RewardType) String() string {
	return proto.EnumName(RecruitTreasureData_RewardType_name, int32(x))
}
func (RecruitTreasureData_RewardType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorShop, []int{10, 0}
}

type SdkRechargeResult_RechargeErr int32

const (
	SdkRechargeResult_Success SdkRechargeResult_RechargeErr = 0
	SdkRechargeResult_Fail    SdkRechargeResult_RechargeErr = 1
)

var SdkRechargeResult_RechargeErr_name = map[int32]string{
	0: "Success",
	1: "Fail",
}
var SdkRechargeResult_RechargeErr_value = map[string]int32{
	"Success": 0,
	"Fail":    1,
}

func (x SdkRechargeResult_RechargeErr) String() string {
	return proto.EnumName(SdkRechargeResult_RechargeErr_name, int32(x))
}
func (SdkRechargeResult_RechargeErr) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorShop, []int{30, 0}
}

type SdkRechargeResult_GoodsType int32

const (
	SdkRechargeResult_Unknow    SdkRechargeResult_GoodsType = 0
	SdkRechargeResult_LimitGift SdkRechargeResult_GoodsType = 1
	SdkRechargeResult_Jade      SdkRechargeResult_GoodsType = 2
	SdkRechargeResult_Vip       SdkRechargeResult_GoodsType = 3
	SdkRechargeResult_Lottery   SdkRechargeResult_GoodsType = 4
)

var SdkRechargeResult_GoodsType_name = map[int32]string{
	0: "Unknow",
	1: "LimitGift",
	2: "Jade",
	3: "Vip",
	4: "Lottery",
}
var SdkRechargeResult_GoodsType_value = map[string]int32{
	"Unknow":    0,
	"LimitGift": 1,
	"Jade":      2,
	"Vip":       3,
	"Lottery":   4,
}

func (x SdkRechargeResult_GoodsType) String() string {
	return proto.EnumName(SdkRechargeResult_GoodsType_name, int32(x))
}
func (SdkRechargeResult_GoodsType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorShop, []int{30, 1}
}

type PieceExchangeArg_PieceTypeEnum int32

const (
	PieceExchangeArg_Unknow PieceExchangeArg_PieceTypeEnum = 0
	PieceExchangeArg_Card   PieceExchangeArg_PieceTypeEnum = 1
	PieceExchangeArg_Skin   PieceExchangeArg_PieceTypeEnum = 2
)

var PieceExchangeArg_PieceTypeEnum_name = map[int32]string{
	0: "Unknow",
	1: "Card",
	2: "Skin",
}
var PieceExchangeArg_PieceTypeEnum_value = map[string]int32{
	"Unknow": 0,
	"Card":   1,
	"Skin":   2,
}

func (x PieceExchangeArg_PieceTypeEnum) String() string {
	return proto.EnumName(PieceExchangeArg_PieceTypeEnum_name, int32(x))
}
func (PieceExchangeArg_PieceTypeEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorShop, []int{35, 0}
}

type UpdateLimitGiftArg struct {
	Gift []*LimitGift `protobuf:"bytes,1,rep,name=Gift" json:"Gift,omitempty"`
}

func (m *UpdateLimitGiftArg) Reset()                    { *m = UpdateLimitGiftArg{} }
func (m *UpdateLimitGiftArg) String() string            { return proto.CompactTextString(m) }
func (*UpdateLimitGiftArg) ProtoMessage()               {}
func (*UpdateLimitGiftArg) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{0} }

func (m *UpdateLimitGiftArg) GetGift() []*LimitGift {
	if m != nil {
		return m.Gift
	}
	return nil
}

type UpdateJadeGoodsArg struct {
	JadeGoodsList []*JadeGoods `protobuf:"bytes,1,rep,name=JadeGoodsList" json:"JadeGoodsList,omitempty"`
}

func (m *UpdateJadeGoodsArg) Reset()                    { *m = UpdateJadeGoodsArg{} }
func (m *UpdateJadeGoodsArg) String() string            { return proto.CompactTextString(m) }
func (*UpdateJadeGoodsArg) ProtoMessage()               {}
func (*UpdateJadeGoodsArg) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{1} }

func (m *UpdateJadeGoodsArg) GetJadeGoodsList() []*JadeGoods {
	if m != nil {
		return m.JadeGoodsList
	}
	return nil
}

type UpdateGoldGoodsArg struct {
	GoldGoodsList     []*GoldGoods `protobuf:"bytes,1,rep,name=GoldGoodsList" json:"GoldGoodsList,omitempty"`
	BuyGoldRemainTime int32        `protobuf:"varint,2,opt,name=BuyGoldRemainTime,proto3" json:"BuyGoldRemainTime,omitempty"`
}

func (m *UpdateGoldGoodsArg) Reset()                    { *m = UpdateGoldGoodsArg{} }
func (m *UpdateGoldGoodsArg) String() string            { return proto.CompactTextString(m) }
func (*UpdateGoldGoodsArg) ProtoMessage()               {}
func (*UpdateGoldGoodsArg) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{2} }

func (m *UpdateGoldGoodsArg) GetGoldGoodsList() []*GoldGoods {
	if m != nil {
		return m.GoldGoodsList
	}
	return nil
}

func (m *UpdateGoldGoodsArg) GetBuyGoldRemainTime() int32 {
	if m != nil {
		return m.BuyGoldRemainTime
	}
	return 0
}

type UpdateFreeAdsArg struct {
	Adses []*ShopFreeAds `protobuf:"bytes,1,rep,name=Adses" json:"Adses,omitempty"`
}

func (m *UpdateFreeAdsArg) Reset()                    { *m = UpdateFreeAdsArg{} }
func (m *UpdateFreeAdsArg) String() string            { return proto.CompactTextString(m) }
func (*UpdateFreeAdsArg) ProtoMessage()               {}
func (*UpdateFreeAdsArg) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{3} }

func (m *UpdateFreeAdsArg) GetAdses() []*ShopFreeAds {
	if m != nil {
		return m.Adses
	}
	return nil
}

// switch Type {
// case LimitGift:
//   Data = UpdateLimitGiftArg
// case SoldTreasure:
//   Data = SoldTreasureData
// case RecruitTreasure:
//   Data = RecruitTreasureData
// case Jade:
//   Data = UpdateJadeGoodsArg
// case Gold:
//   Data = UpdateGoldGoodsArg
// case FreeAds:
//   Data = UpdateFreeAdsArg
// case Vip:
//   Data = VipCardGoods
// case RandomShop:
//   Data = VisitRandomShopData
// case GoldGift:
//   Data = SoldGoldGift
// }
type UpdateShopDataArg struct {
	Type UpdateShopDataArg_DataType `protobuf:"varint,1,opt,name=Type,proto3,enum=pb.UpdateShopDataArg_DataType" json:"Type,omitempty"`
	Data []byte                     `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *UpdateShopDataArg) Reset()                    { *m = UpdateShopDataArg{} }
func (m *UpdateShopDataArg) String() string            { return proto.CompactTextString(m) }
func (*UpdateShopDataArg) ProtoMessage()               {}
func (*UpdateShopDataArg) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{4} }

func (m *UpdateShopDataArg) GetType() UpdateShopDataArg_DataType {
	if m != nil {
		return m.Type
	}
	return UpdateShopDataArg_Unknow
}

func (m *UpdateShopDataArg) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type LimitGift struct {
	GiftID     string `protobuf:"bytes,1,opt,name=GiftID,proto3" json:"GiftID,omitempty"`
	RemainTime int32  `protobuf:"varint,2,opt,name=RemainTime,proto3" json:"RemainTime,omitempty"`
	Price      int32  `protobuf:"varint,3,opt,name=Price,proto3" json:"Price,omitempty"`
	IsNew      bool   `protobuf:"varint,4,opt,name=IsNew,proto3" json:"IsNew,omitempty"`
}

func (m *LimitGift) Reset()                    { *m = LimitGift{} }
func (m *LimitGift) String() string            { return proto.CompactTextString(m) }
func (*LimitGift) ProtoMessage()               {}
func (*LimitGift) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{5} }

func (m *LimitGift) GetGiftID() string {
	if m != nil {
		return m.GiftID
	}
	return ""
}

func (m *LimitGift) GetRemainTime() int32 {
	if m != nil {
		return m.RemainTime
	}
	return 0
}

func (m *LimitGift) GetPrice() int32 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *LimitGift) GetIsNew() bool {
	if m != nil {
		return m.IsNew
	}
	return false
}

type JadeGoods struct {
	GoodsID  string `protobuf:"bytes,1,opt,name=GoodsID,proto3" json:"GoodsID,omitempty"`
	Price    int32  `protobuf:"varint,2,opt,name=Price,proto3" json:"Price,omitempty"`
	Jade     int32  `protobuf:"varint,3,opt,name=Jade,proto3" json:"Jade,omitempty"`
	IsDouble bool   `protobuf:"varint,4,opt,name=isDouble,proto3" json:"isDouble,omitempty"`
}

func (m *JadeGoods) Reset()                    { *m = JadeGoods{} }
func (m *JadeGoods) String() string            { return proto.CompactTextString(m) }
func (*JadeGoods) ProtoMessage()               {}
func (*JadeGoods) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{6} }

func (m *JadeGoods) GetGoodsID() string {
	if m != nil {
		return m.GoodsID
	}
	return ""
}

func (m *JadeGoods) GetPrice() int32 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *JadeGoods) GetJade() int32 {
	if m != nil {
		return m.Jade
	}
	return 0
}

func (m *JadeGoods) GetIsDouble() bool {
	if m != nil {
		return m.IsDouble
	}
	return false
}

type SoldTreasure struct {
	TreasureModelID string `protobuf:"bytes,1,opt,name=TreasureModelID,proto3" json:"TreasureModelID,omitempty"`
	NeedJade        int32  `protobuf:"varint,2,opt,name=NeedJade,proto3" json:"NeedJade,omitempty"`
	NexRemainTime   int32  `protobuf:"varint,3,opt,name=NexRemainTime,proto3" json:"NexRemainTime,omitempty"`
}

func (m *SoldTreasure) Reset()                    { *m = SoldTreasure{} }
func (m *SoldTreasure) String() string            { return proto.CompactTextString(m) }
func (*SoldTreasure) ProtoMessage()               {}
func (*SoldTreasure) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{7} }

func (m *SoldTreasure) GetTreasureModelID() string {
	if m != nil {
		return m.TreasureModelID
	}
	return ""
}

func (m *SoldTreasure) GetNeedJade() int32 {
	if m != nil {
		return m.NeedJade
	}
	return 0
}

func (m *SoldTreasure) GetNexRemainTime() int32 {
	if m != nil {
		return m.NexRemainTime
	}
	return 0
}

type SoldTreasureData struct {
	SoldTreasures []*SoldTreasure `protobuf:"bytes,1,rep,name=SoldTreasures" json:"SoldTreasures,omitempty"`
}

func (m *SoldTreasureData) Reset()                    { *m = SoldTreasureData{} }
func (m *SoldTreasureData) String() string            { return proto.CompactTextString(m) }
func (*SoldTreasureData) ProtoMessage()               {}
func (*SoldTreasureData) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{8} }

func (m *SoldTreasureData) GetSoldTreasures() []*SoldTreasure {
	if m != nil {
		return m.SoldTreasures
	}
	return nil
}

type RandomShop struct {
	GoodsId  string `protobuf:"bytes,1,opt,name=GoodsId,proto3" json:"GoodsId,omitempty"`
	Amount   int32  `protobuf:"varint,2,opt,name=Amount,proto3" json:"Amount,omitempty"`
	NeedJade int32  `protobuf:"varint,3,opt,name=NeedJade,proto3" json:"NeedJade,omitempty"`
	IsBuy    bool   `protobuf:"varint,4,opt,name=IsBuy,proto3" json:"IsBuy,omitempty"`
	NeedGold int32  `protobuf:"varint,5,opt,name=NeedGold,proto3" json:"NeedGold,omitempty"`
}

func (m *RandomShop) Reset()                    { *m = RandomShop{} }
func (m *RandomShop) String() string            { return proto.CompactTextString(m) }
func (*RandomShop) ProtoMessage()               {}
func (*RandomShop) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{9} }

func (m *RandomShop) GetGoodsId() string {
	if m != nil {
		return m.GoodsId
	}
	return ""
}

func (m *RandomShop) GetAmount() int32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *RandomShop) GetNeedJade() int32 {
	if m != nil {
		return m.NeedJade
	}
	return 0
}

func (m *RandomShop) GetIsBuy() bool {
	if m != nil {
		return m.IsBuy
	}
	return false
}

func (m *RandomShop) GetNeedGold() int32 {
	if m != nil {
		return m.NeedGold
	}
	return 0
}

// 商城招募
type RecruitTreasureData struct {
	TreasureModelID string                         `protobuf:"bytes,1,opt,name=TreasureModelID,proto3" json:"TreasureModelID,omitempty"`
	NeedJade        int32                          `protobuf:"varint,2,opt,name=NeedJade,proto3" json:"NeedJade,omitempty"`
	BuyTimes        int32                          `protobuf:"varint,3,opt,name=BuyTimes,proto3" json:"BuyTimes,omitempty"`
	NexRemainTime   int32                          `protobuf:"varint,4,opt,name=NexRemainTime,proto3" json:"NexRemainTime,omitempty"`
	Discount        int32                          `protobuf:"varint,5,opt,name=Discount,proto3" json:"Discount,omitempty"`
	MaxBuyTimes     int32                          `protobuf:"varint,6,opt,name=MaxBuyTimes,proto3" json:"MaxBuyTimes,omitempty"`
	Rid             []int32                        `protobuf:"varint,7,rep,packed,name=rid" json:"rid,omitempty"`
	RwType          RecruitTreasureData_RewardType `protobuf:"varint,8,opt,name=RwType,proto3,enum=pb.RecruitTreasureData_RewardType" json:"RwType,omitempty"`
	NextRefreshTime int64                          `protobuf:"varint,9,opt,name=NextRefreshTime,proto3" json:"NextRefreshTime,omitempty"`
}

func (m *RecruitTreasureData) Reset()                    { *m = RecruitTreasureData{} }
func (m *RecruitTreasureData) String() string            { return proto.CompactTextString(m) }
func (*RecruitTreasureData) ProtoMessage()               {}
func (*RecruitTreasureData) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{10} }

func (m *RecruitTreasureData) GetTreasureModelID() string {
	if m != nil {
		return m.TreasureModelID
	}
	return ""
}

func (m *RecruitTreasureData) GetNeedJade() int32 {
	if m != nil {
		return m.NeedJade
	}
	return 0
}

func (m *RecruitTreasureData) GetBuyTimes() int32 {
	if m != nil {
		return m.BuyTimes
	}
	return 0
}

func (m *RecruitTreasureData) GetNexRemainTime() int32 {
	if m != nil {
		return m.NexRemainTime
	}
	return 0
}

func (m *RecruitTreasureData) GetDiscount() int32 {
	if m != nil {
		return m.Discount
	}
	return 0
}

func (m *RecruitTreasureData) GetMaxBuyTimes() int32 {
	if m != nil {
		return m.MaxBuyTimes
	}
	return 0
}

func (m *RecruitTreasureData) GetRid() []int32 {
	if m != nil {
		return m.Rid
	}
	return nil
}

func (m *RecruitTreasureData) GetRwType() RecruitTreasureData_RewardType {
	if m != nil {
		return m.RwType
	}
	return RecruitTreasureData_Unknow
}

func (m *RecruitTreasureData) GetNextRefreshTime() int64 {
	if m != nil {
		return m.NextRefreshTime
	}
	return 0
}

// 探访
type VisitRandomShopData struct {
	RandomShops   []*RandomShop `protobuf:"bytes,1,rep,name=RandomShops" json:"RandomShops,omitempty"`
	NexRemainTime int32         `protobuf:"varint,2,opt,name=NexRemainTime,proto3" json:"NexRemainTime,omitempty"`
	BuyTimes      int32         `protobuf:"varint,3,opt,name=BuyTimes,proto3" json:"BuyTimes,omitempty"`
	Discount      int32         `protobuf:"varint,4,opt,name=Discount,proto3" json:"Discount,omitempty"`
	MaxBuyTimes   int32         `protobuf:"varint,5,opt,name=MaxBuyTimes,proto3" json:"MaxBuyTimes,omitempty"`
	NeedJade      int32         `protobuf:"varint,6,opt,name=NeedJade,proto3" json:"NeedJade,omitempty"`
}

func (m *VisitRandomShopData) Reset()                    { *m = VisitRandomShopData{} }
func (m *VisitRandomShopData) String() string            { return proto.CompactTextString(m) }
func (*VisitRandomShopData) ProtoMessage()               {}
func (*VisitRandomShopData) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{11} }

func (m *VisitRandomShopData) GetRandomShops() []*RandomShop {
	if m != nil {
		return m.RandomShops
	}
	return nil
}

func (m *VisitRandomShopData) GetNexRemainTime() int32 {
	if m != nil {
		return m.NexRemainTime
	}
	return 0
}

func (m *VisitRandomShopData) GetBuyTimes() int32 {
	if m != nil {
		return m.BuyTimes
	}
	return 0
}

func (m *VisitRandomShopData) GetDiscount() int32 {
	if m != nil {
		return m.Discount
	}
	return 0
}

func (m *VisitRandomShopData) GetMaxBuyTimes() int32 {
	if m != nil {
		return m.MaxBuyTimes
	}
	return 0
}

func (m *VisitRandomShopData) GetNeedJade() int32 {
	if m != nil {
		return m.NeedJade
	}
	return 0
}

type GoldGoods struct {
	GoodsID  string `protobuf:"bytes,1,opt,name=GoodsID,proto3" json:"GoodsID,omitempty"`
	Gold     int32  `protobuf:"varint,2,opt,name=Gold,proto3" json:"Gold,omitempty"`
	NeedJade int32  `protobuf:"varint,3,opt,name=NeedJade,proto3" json:"NeedJade,omitempty"`
}

func (m *GoldGoods) Reset()                    { *m = GoldGoods{} }
func (m *GoldGoods) String() string            { return proto.CompactTextString(m) }
func (*GoldGoods) ProtoMessage()               {}
func (*GoldGoods) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{12} }

func (m *GoldGoods) GetGoodsID() string {
	if m != nil {
		return m.GoodsID
	}
	return ""
}

func (m *GoldGoods) GetGold() int32 {
	if m != nil {
		return m.Gold
	}
	return 0
}

func (m *GoldGoods) GetNeedJade() int32 {
	if m != nil {
		return m.NeedJade
	}
	return 0
}

type SoldGoldGift struct {
	TreasureID       string `protobuf:"bytes,1,opt,name=TreasureID,proto3" json:"TreasureID,omitempty"`
	JadePrice        int32  `protobuf:"varint,2,opt,name=JadePrice,proto3" json:"JadePrice,omitempty"`
	CanBuyRemainTime int32  `protobuf:"varint,3,opt,name=CanBuyRemainTime,proto3" json:"CanBuyRemainTime,omitempty"`
}

func (m *SoldGoldGift) Reset()                    { *m = SoldGoldGift{} }
func (m *SoldGoldGift) String() string            { return proto.CompactTextString(m) }
func (*SoldGoldGift) ProtoMessage()               {}
func (*SoldGoldGift) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{13} }

func (m *SoldGoldGift) GetTreasureID() string {
	if m != nil {
		return m.TreasureID
	}
	return ""
}

func (m *SoldGoldGift) GetJadePrice() int32 {
	if m != nil {
		return m.JadePrice
	}
	return 0
}

func (m *SoldGoldGift) GetCanBuyRemainTime() int32 {
	if m != nil {
		return m.CanBuyRemainTime
	}
	return 0
}

type SoldRecommendGift struct {
	GiftID            string           `protobuf:"bytes,1,opt,name=GiftID,proto3" json:"GiftID,omitempty"`
	JadePrice         int32            `protobuf:"varint,2,opt,name=JadePrice,proto3" json:"JadePrice,omitempty"`
	Cards             map[uint32]int32 `protobuf:"bytes,3,rep,name=cards" json:"cards,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	RefreshRemainTime int32            `protobuf:"varint,4,opt,name=RefreshRemainTime,proto3" json:"RefreshRemainTime,omitempty"`
}

func (m *SoldRecommendGift) Reset()                    { *m = SoldRecommendGift{} }
func (m *SoldRecommendGift) String() string            { return proto.CompactTextString(m) }
func (*SoldRecommendGift) ProtoMessage()               {}
func (*SoldRecommendGift) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{14} }

func (m *SoldRecommendGift) GetGiftID() string {
	if m != nil {
		return m.GiftID
	}
	return ""
}

func (m *SoldRecommendGift) GetJadePrice() int32 {
	if m != nil {
		return m.JadePrice
	}
	return 0
}

func (m *SoldRecommendGift) GetCards() map[uint32]int32 {
	if m != nil {
		return m.Cards
	}
	return nil
}

func (m *SoldRecommendGift) GetRefreshRemainTime() int32 {
	if m != nil {
		return m.RefreshRemainTime
	}
	return 0
}

type ShopData struct {
	Gift              []*LimitGift         `protobuf:"bytes,1,rep,name=Gift" json:"Gift,omitempty"`
	SoldTreasures     *SoldTreasureData    `protobuf:"bytes,2,opt,name=SoldTreasures" json:"SoldTreasures,omitempty"`
	RecruitTreasure   *RecruitTreasureData `protobuf:"bytes,3,opt,name=RecruitTreasure" json:"RecruitTreasure,omitempty"`
	JadeGoodsList     []*JadeGoods         `protobuf:"bytes,4,rep,name=JadeGoodsList" json:"JadeGoodsList,omitempty"`
	GoldGoodsList     []*GoldGoods         `protobuf:"bytes,5,rep,name=GoldGoodsList" json:"GoldGoodsList,omitempty"`
	Adses             []*ShopFreeAds       `protobuf:"bytes,6,rep,name=Adses" json:"Adses,omitempty"`
	BuyGoldRemainTime int32                `protobuf:"varint,7,opt,name=BuyGoldRemainTime,proto3" json:"BuyGoldRemainTime,omitempty"`
	VipCard           *VipCardGoods        `protobuf:"bytes,8,opt,name=VipCard" json:"VipCard,omitempty"`
	RandomShopData    *VisitRandomShopData `protobuf:"bytes,9,opt,name=RandomShopData" json:"RandomShopData,omitempty"`
	GoldGift          *SoldGoldGift        `protobuf:"bytes,10,opt,name=GoldGift" json:"GoldGift,omitempty"`
	RecommendGift     *SoldRecommendGift   `protobuf:"bytes,11,opt,name=RecommendGift" json:"RecommendGift,omitempty"`
}

func (m *ShopData) Reset()                    { *m = ShopData{} }
func (m *ShopData) String() string            { return proto.CompactTextString(m) }
func (*ShopData) ProtoMessage()               {}
func (*ShopData) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{15} }

func (m *ShopData) GetGift() []*LimitGift {
	if m != nil {
		return m.Gift
	}
	return nil
}

func (m *ShopData) GetSoldTreasures() *SoldTreasureData {
	if m != nil {
		return m.SoldTreasures
	}
	return nil
}

func (m *ShopData) GetRecruitTreasure() *RecruitTreasureData {
	if m != nil {
		return m.RecruitTreasure
	}
	return nil
}

func (m *ShopData) GetJadeGoodsList() []*JadeGoods {
	if m != nil {
		return m.JadeGoodsList
	}
	return nil
}

func (m *ShopData) GetGoldGoodsList() []*GoldGoods {
	if m != nil {
		return m.GoldGoodsList
	}
	return nil
}

func (m *ShopData) GetAdses() []*ShopFreeAds {
	if m != nil {
		return m.Adses
	}
	return nil
}

func (m *ShopData) GetBuyGoldRemainTime() int32 {
	if m != nil {
		return m.BuyGoldRemainTime
	}
	return 0
}

func (m *ShopData) GetVipCard() *VipCardGoods {
	if m != nil {
		return m.VipCard
	}
	return nil
}

func (m *ShopData) GetRandomShopData() *VisitRandomShopData {
	if m != nil {
		return m.RandomShopData
	}
	return nil
}

func (m *ShopData) GetGoldGift() *SoldGoldGift {
	if m != nil {
		return m.GoldGift
	}
	return nil
}

func (m *ShopData) GetRecommendGift() *SoldRecommendGift {
	if m != nil {
		return m.RecommendGift
	}
	return nil
}

type VipCardGoods struct {
	GoodsID   string `protobuf:"bytes,1,opt,name=GoodsID,proto3" json:"GoodsID,omitempty"`
	JadePrice int32  `protobuf:"varint,2,opt,name=JadePrice,proto3" json:"JadePrice,omitempty"`
	Price     int32  `protobuf:"varint,3,opt,name=Price,proto3" json:"Price,omitempty"`
}

func (m *VipCardGoods) Reset()                    { *m = VipCardGoods{} }
func (m *VipCardGoods) String() string            { return proto.CompactTextString(m) }
func (*VipCardGoods) ProtoMessage()               {}
func (*VipCardGoods) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{16} }

func (m *VipCardGoods) GetGoodsID() string {
	if m != nil {
		return m.GoodsID
	}
	return ""
}

func (m *VipCardGoods) GetJadePrice() int32 {
	if m != nil {
		return m.JadePrice
	}
	return 0
}

func (m *VipCardGoods) GetPrice() int32 {
	if m != nil {
		return m.Price
	}
	return 0
}

type BuyRandomShopArg struct {
	GoodsID string `protobuf:"bytes,1,opt,name=GoodsID,proto3" json:"GoodsID,omitempty"`
	Amount  int32  `protobuf:"varint,2,opt,name=Amount,proto3" json:"Amount,omitempty"`
}

func (m *BuyRandomShopArg) Reset()                    { *m = BuyRandomShopArg{} }
func (m *BuyRandomShopArg) String() string            { return proto.CompactTextString(m) }
func (*BuyRandomShopArg) ProtoMessage()               {}
func (*BuyRandomShopArg) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{17} }

func (m *BuyRandomShopArg) GetGoodsID() string {
	if m != nil {
		return m.GoodsID
	}
	return ""
}

func (m *BuyRandomShopArg) GetAmount() int32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

type BuyJadeArg struct {
	GoodsID string `protobuf:"bytes,1,opt,name=GoodsID,proto3" json:"GoodsID,omitempty"`
	Receipt string `protobuf:"bytes,2,opt,name=Receipt,proto3" json:"Receipt,omitempty"`
}

func (m *BuyJadeArg) Reset()                    { *m = BuyJadeArg{} }
func (m *BuyJadeArg) String() string            { return proto.CompactTextString(m) }
func (*BuyJadeArg) ProtoMessage()               {}
func (*BuyJadeArg) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{18} }

func (m *BuyJadeArg) GetGoodsID() string {
	if m != nil {
		return m.GoodsID
	}
	return ""
}

func (m *BuyJadeArg) GetReceipt() string {
	if m != nil {
		return m.Receipt
	}
	return ""
}

type BuyJadeReply struct {
	Jade       int32 `protobuf:"varint,1,opt,name=Jade,proto3" json:"Jade,omitempty"`
	RewardJade int32 `protobuf:"varint,2,opt,name=RewardJade,proto3" json:"RewardJade,omitempty"`
}

func (m *BuyJadeReply) Reset()                    { *m = BuyJadeReply{} }
func (m *BuyJadeReply) String() string            { return proto.CompactTextString(m) }
func (*BuyJadeReply) ProtoMessage()               {}
func (*BuyJadeReply) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{19} }

func (m *BuyJadeReply) GetJade() int32 {
	if m != nil {
		return m.Jade
	}
	return 0
}

func (m *BuyJadeReply) GetRewardJade() int32 {
	if m != nil {
		return m.RewardJade
	}
	return 0
}

type BuyLimitGiftArg struct {
	GiftID  string `protobuf:"bytes,1,opt,name=GiftID,proto3" json:"GiftID,omitempty"`
	Receipt string `protobuf:"bytes,2,opt,name=Receipt,proto3" json:"Receipt,omitempty"`
}

func (m *BuyLimitGiftArg) Reset()                    { *m = BuyLimitGiftArg{} }
func (m *BuyLimitGiftArg) String() string            { return proto.CompactTextString(m) }
func (*BuyLimitGiftArg) ProtoMessage()               {}
func (*BuyLimitGiftArg) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{20} }

func (m *BuyLimitGiftArg) GetGiftID() string {
	if m != nil {
		return m.GiftID
	}
	return ""
}

func (m *BuyLimitGiftArg) GetReceipt() string {
	if m != nil {
		return m.Receipt
	}
	return ""
}

type GiftPrivilegeReward struct {
	PrivID     int32 `protobuf:"varint,1,opt,name=PrivID,proto3" json:"PrivID,omitempty"`
	RemainTime int32 `protobuf:"varint,2,opt,name=RemainTime,proto3" json:"RemainTime,omitempty"`
}

func (m *GiftPrivilegeReward) Reset()                    { *m = GiftPrivilegeReward{} }
func (m *GiftPrivilegeReward) String() string            { return proto.CompactTextString(m) }
func (*GiftPrivilegeReward) ProtoMessage()               {}
func (*GiftPrivilegeReward) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{21} }

func (m *GiftPrivilegeReward) GetPrivID() int32 {
	if m != nil {
		return m.PrivID
	}
	return 0
}

func (m *GiftPrivilegeReward) GetRemainTime() int32 {
	if m != nil {
		return m.RemainTime
	}
	return 0
}

type BuyLimitGiftReply struct {
	GiftReward *OpenTreasureReply     `protobuf:"bytes,1,opt,name=GiftReward" json:"GiftReward,omitempty"`
	Privileges []*GiftPrivilegeReward `protobuf:"bytes,2,rep,name=Privileges" json:"Privileges,omitempty"`
	NextGift   *LimitGift             `protobuf:"bytes,3,opt,name=NextGift" json:"NextGift,omitempty"`
}

func (m *BuyLimitGiftReply) Reset()                    { *m = BuyLimitGiftReply{} }
func (m *BuyLimitGiftReply) String() string            { return proto.CompactTextString(m) }
func (*BuyLimitGiftReply) ProtoMessage()               {}
func (*BuyLimitGiftReply) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{22} }

func (m *BuyLimitGiftReply) GetGiftReward() *OpenTreasureReply {
	if m != nil {
		return m.GiftReward
	}
	return nil
}

func (m *BuyLimitGiftReply) GetPrivileges() []*GiftPrivilegeReward {
	if m != nil {
		return m.Privileges
	}
	return nil
}

func (m *BuyLimitGiftReply) GetNextGift() *LimitGift {
	if m != nil {
		return m.NextGift
	}
	return nil
}

type BuySoldTreasureArg struct {
	TreasureModelID string `protobuf:"bytes,1,opt,name=TreasureModelID,proto3" json:"TreasureModelID,omitempty"`
}

func (m *BuySoldTreasureArg) Reset()                    { *m = BuySoldTreasureArg{} }
func (m *BuySoldTreasureArg) String() string            { return proto.CompactTextString(m) }
func (*BuySoldTreasureArg) ProtoMessage()               {}
func (*BuySoldTreasureArg) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{23} }

func (m *BuySoldTreasureArg) GetTreasureModelID() string {
	if m != nil {
		return m.TreasureModelID
	}
	return ""
}

type BuySoldTreasureReply struct {
	TreasureReward  *OpenTreasureReply `protobuf:"bytes,1,opt,name=TreasureReward" json:"TreasureReward,omitempty"`
	NewSoldTreasure *SoldTreasureData  `protobuf:"bytes,2,opt,name=NewSoldTreasure" json:"NewSoldTreasure,omitempty"`
}

func (m *BuySoldTreasureReply) Reset()                    { *m = BuySoldTreasureReply{} }
func (m *BuySoldTreasureReply) String() string            { return proto.CompactTextString(m) }
func (*BuySoldTreasureReply) ProtoMessage()               {}
func (*BuySoldTreasureReply) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{24} }

func (m *BuySoldTreasureReply) GetTreasureReward() *OpenTreasureReply {
	if m != nil {
		return m.TreasureReward
	}
	return nil
}

func (m *BuySoldTreasureReply) GetNewSoldTreasure() *SoldTreasureData {
	if m != nil {
		return m.NewSoldTreasure
	}
	return nil
}

type BuyGoldArg struct {
	GoodsID string `protobuf:"bytes,1,opt,name=GoodsID,proto3" json:"GoodsID,omitempty"`
}

func (m *BuyGoldArg) Reset()                    { *m = BuyGoldArg{} }
func (m *BuyGoldArg) String() string            { return proto.CompactTextString(m) }
func (*BuyGoldArg) ProtoMessage()               {}
func (*BuyGoldArg) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{25} }

func (m *BuyGoldArg) GetGoodsID() string {
	if m != nil {
		return m.GoodsID
	}
	return ""
}

type BuyGoldReply struct {
	Gold           int32 `protobuf:"varint,1,opt,name=Gold,proto3" json:"Gold,omitempty"`
	NextRemainTime int32 `protobuf:"varint,2,opt,name=NextRemainTime,proto3" json:"NextRemainTime,omitempty"`
}

func (m *BuyGoldReply) Reset()                    { *m = BuyGoldReply{} }
func (m *BuyGoldReply) String() string            { return proto.CompactTextString(m) }
func (*BuyGoldReply) ProtoMessage()               {}
func (*BuyGoldReply) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{26} }

func (m *BuyGoldReply) GetGold() int32 {
	if m != nil {
		return m.Gold
	}
	return 0
}

func (m *BuyGoldReply) GetNextRemainTime() int32 {
	if m != nil {
		return m.NextRemainTime
	}
	return 0
}

type SdkCreateOrderArg struct {
	GoodsID string `protobuf:"bytes,1,opt,name=GoodsID,proto3" json:"GoodsID,omitempty"`
}

func (m *SdkCreateOrderArg) Reset()                    { *m = SdkCreateOrderArg{} }
func (m *SdkCreateOrderArg) String() string            { return proto.CompactTextString(m) }
func (*SdkCreateOrderArg) ProtoMessage()               {}
func (*SdkCreateOrderArg) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{27} }

func (m *SdkCreateOrderArg) GetGoodsID() string {
	if m != nil {
		return m.GoodsID
	}
	return ""
}

type SdkCreateOrderReply struct {
	OrderID string `protobuf:"bytes,1,opt,name=OrderID,proto3" json:"OrderID,omitempty"`
}

func (m *SdkCreateOrderReply) Reset()                    { *m = SdkCreateOrderReply{} }
func (m *SdkCreateOrderReply) String() string            { return proto.CompactTextString(m) }
func (*SdkCreateOrderReply) ProtoMessage()               {}
func (*SdkCreateOrderReply) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{28} }

func (m *SdkCreateOrderReply) GetOrderID() string {
	if m != nil {
		return m.OrderID
	}
	return ""
}

// 锦囊抽奖
type RechargeLotteryReply struct {
	RewardIdx  int32                `protobuf:"varint,1,opt,name=RewardIdx,proto3" json:"RewardIdx,omitempty"`
	Privileges *GiftPrivilegeReward `protobuf:"bytes,2,opt,name=Privileges" json:"Privileges,omitempty"`
}

func (m *RechargeLotteryReply) Reset()                    { *m = RechargeLotteryReply{} }
func (m *RechargeLotteryReply) String() string            { return proto.CompactTextString(m) }
func (*RechargeLotteryReply) ProtoMessage()               {}
func (*RechargeLotteryReply) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{29} }

func (m *RechargeLotteryReply) GetRewardIdx() int32 {
	if m != nil {
		return m.RewardIdx
	}
	return 0
}

func (m *RechargeLotteryReply) GetPrivileges() *GiftPrivilegeReward {
	if m != nil {
		return m.Privileges
	}
	return nil
}

// switch SdkRechargeResult.Type {
// case LimitGift:
//   Data = BuyLimitGiftReply,
// case Jade:
//   Data = BuyJadeReply
// case Vip:
//   Data = BuyVipCardReply
// case Lottery:
//   Data = RechargeLotteryReply
// }
type SdkRechargeResult struct {
	Errcode SdkRechargeResult_RechargeErr `protobuf:"varint,1,opt,name=Errcode,proto3,enum=pb.SdkRechargeResult_RechargeErr" json:"Errcode,omitempty"`
	Type    SdkRechargeResult_GoodsType   `protobuf:"varint,2,opt,name=Type,proto3,enum=pb.SdkRechargeResult_GoodsType" json:"Type,omitempty"`
	Data    []byte                        `protobuf:"bytes,3,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *SdkRechargeResult) Reset()                    { *m = SdkRechargeResult{} }
func (m *SdkRechargeResult) String() string            { return proto.CompactTextString(m) }
func (*SdkRechargeResult) ProtoMessage()               {}
func (*SdkRechargeResult) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{30} }

func (m *SdkRechargeResult) GetErrcode() SdkRechargeResult_RechargeErr {
	if m != nil {
		return m.Errcode
	}
	return SdkRechargeResult_Success
}

func (m *SdkRechargeResult) GetType() SdkRechargeResult_GoodsType {
	if m != nil {
		return m.Type
	}
	return SdkRechargeResult_Unknow
}

func (m *SdkRechargeResult) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type IosPrePayArg struct {
	GoodsID string `protobuf:"bytes,1,opt,name=GoodsID,proto3" json:"GoodsID,omitempty"`
}

func (m *IosPrePayArg) Reset()                    { *m = IosPrePayArg{} }
func (m *IosPrePayArg) String() string            { return proto.CompactTextString(m) }
func (*IosPrePayArg) ProtoMessage()               {}
func (*IosPrePayArg) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{31} }

func (m *IosPrePayArg) GetGoodsID() string {
	if m != nil {
		return m.GoodsID
	}
	return ""
}

type BuyLimitGiftByJadeArg struct {
	GiftID string `protobuf:"bytes,1,opt,name=GiftID,proto3" json:"GiftID,omitempty"`
}

func (m *BuyLimitGiftByJadeArg) Reset()                    { *m = BuyLimitGiftByJadeArg{} }
func (m *BuyLimitGiftByJadeArg) String() string            { return proto.CompactTextString(m) }
func (*BuyLimitGiftByJadeArg) ProtoMessage()               {}
func (*BuyLimitGiftByJadeArg) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{32} }

func (m *BuyLimitGiftByJadeArg) GetGiftID() string {
	if m != nil {
		return m.GiftID
	}
	return ""
}

type GooglePlayRechargeArg struct {
	GoodsID            string `protobuf:"bytes,1,opt,name=GoodsID,proto3" json:"GoodsID,omitempty"`
	InappPurchaseData  string `protobuf:"bytes,2,opt,name=InappPurchaseData,proto3" json:"InappPurchaseData,omitempty"`
	InappDataSignature string `protobuf:"bytes,3,opt,name=InappDataSignature,proto3" json:"InappDataSignature,omitempty"`
	Money              int32  `protobuf:"varint,4,opt,name=Money,proto3" json:"Money,omitempty"`
	Currency           string `protobuf:"bytes,5,opt,name=Currency,proto3" json:"Currency,omitempty"`
}

func (m *GooglePlayRechargeArg) Reset()                    { *m = GooglePlayRechargeArg{} }
func (m *GooglePlayRechargeArg) String() string            { return proto.CompactTextString(m) }
func (*GooglePlayRechargeArg) ProtoMessage()               {}
func (*GooglePlayRechargeArg) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{33} }

func (m *GooglePlayRechargeArg) GetGoodsID() string {
	if m != nil {
		return m.GoodsID
	}
	return ""
}

func (m *GooglePlayRechargeArg) GetInappPurchaseData() string {
	if m != nil {
		return m.InappPurchaseData
	}
	return ""
}

func (m *GooglePlayRechargeArg) GetInappDataSignature() string {
	if m != nil {
		return m.InappDataSignature
	}
	return ""
}

func (m *GooglePlayRechargeArg) GetMoney() int32 {
	if m != nil {
		return m.Money
	}
	return 0
}

func (m *GooglePlayRechargeArg) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

type BuyVipCardReply struct {
	HeadFrame  string `protobuf:"bytes,1,opt,name=HeadFrame,proto3" json:"HeadFrame,omitempty"`
	RemainTime int32  `protobuf:"varint,2,opt,name=RemainTime,proto3" json:"RemainTime,omitempty"`
}

func (m *BuyVipCardReply) Reset()                    { *m = BuyVipCardReply{} }
func (m *BuyVipCardReply) String() string            { return proto.CompactTextString(m) }
func (*BuyVipCardReply) ProtoMessage()               {}
func (*BuyVipCardReply) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{34} }

func (m *BuyVipCardReply) GetHeadFrame() string {
	if m != nil {
		return m.HeadFrame
	}
	return ""
}

func (m *BuyVipCardReply) GetRemainTime() int32 {
	if m != nil {
		return m.RemainTime
	}
	return 0
}

type PieceExchangeArg struct {
	PieceType PieceExchangeArg_PieceTypeEnum `protobuf:"varint,1,opt,name=PieceType,proto3,enum=pb.PieceExchangeArg_PieceTypeEnum" json:"PieceType,omitempty"`
	GoodsID   int32                          `protobuf:"varint,2,opt,name=GoodsID,proto3" json:"GoodsID,omitempty"`
}

func (m *PieceExchangeArg) Reset()                    { *m = PieceExchangeArg{} }
func (m *PieceExchangeArg) String() string            { return proto.CompactTextString(m) }
func (*PieceExchangeArg) ProtoMessage()               {}
func (*PieceExchangeArg) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{35} }

func (m *PieceExchangeArg) GetPieceType() PieceExchangeArg_PieceTypeEnum {
	if m != nil {
		return m.PieceType
	}
	return PieceExchangeArg_Unknow
}

func (m *PieceExchangeArg) GetGoodsID() int32 {
	if m != nil {
		return m.GoodsID
	}
	return 0
}

type TargetLimitGift struct {
	GiftID string `protobuf:"bytes,1,opt,name=GiftID,proto3" json:"GiftID,omitempty"`
}

func (m *TargetLimitGift) Reset()                    { *m = TargetLimitGift{} }
func (m *TargetLimitGift) String() string            { return proto.CompactTextString(m) }
func (*TargetLimitGift) ProtoMessage()               {}
func (*TargetLimitGift) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{36} }

func (m *TargetLimitGift) GetGiftID() string {
	if m != nil {
		return m.GiftID
	}
	return ""
}

type IosRechargeArg struct {
	GoodsID string `protobuf:"bytes,1,opt,name=GoodsID,proto3" json:"GoodsID,omitempty"`
	Receipt string `protobuf:"bytes,2,opt,name=Receipt,proto3" json:"Receipt,omitempty"`
}

func (m *IosRechargeArg) Reset()                    { *m = IosRechargeArg{} }
func (m *IosRechargeArg) String() string            { return proto.CompactTextString(m) }
func (*IosRechargeArg) ProtoMessage()               {}
func (*IosRechargeArg) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{37} }

func (m *IosRechargeArg) GetGoodsID() string {
	if m != nil {
		return m.GoodsID
	}
	return ""
}

func (m *IosRechargeArg) GetReceipt() string {
	if m != nil {
		return m.Receipt
	}
	return ""
}

type BuyRecruitTreasureArg struct {
	BuyCnt int32 `protobuf:"varint,1,opt,name=BuyCnt,proto3" json:"BuyCnt,omitempty"`
}

func (m *BuyRecruitTreasureArg) Reset()                    { *m = BuyRecruitTreasureArg{} }
func (m *BuyRecruitTreasureArg) String() string            { return proto.CompactTextString(m) }
func (*BuyRecruitTreasureArg) ProtoMessage()               {}
func (*BuyRecruitTreasureArg) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{38} }

func (m *BuyRecruitTreasureArg) GetBuyCnt() int32 {
	if m != nil {
		return m.BuyCnt
	}
	return 0
}

type BuyRecruitTreasureReply struct {
	TreasureReward *OpenTreasureReply `protobuf:"bytes,1,opt,name=TreasureReward" json:"TreasureReward,omitempty"`
	NextRemainTime int32              `protobuf:"varint,2,opt,name=NextRemainTime,proto3" json:"NextRemainTime,omitempty"`
	Discount       int32              `protobuf:"varint,3,opt,name=Discount,proto3" json:"Discount,omitempty"`
}

func (m *BuyRecruitTreasureReply) Reset()                    { *m = BuyRecruitTreasureReply{} }
func (m *BuyRecruitTreasureReply) String() string            { return proto.CompactTextString(m) }
func (*BuyRecruitTreasureReply) ProtoMessage()               {}
func (*BuyRecruitTreasureReply) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{39} }

func (m *BuyRecruitTreasureReply) GetTreasureReward() *OpenTreasureReply {
	if m != nil {
		return m.TreasureReward
	}
	return nil
}

func (m *BuyRecruitTreasureReply) GetNextRemainTime() int32 {
	if m != nil {
		return m.NextRemainTime
	}
	return 0
}

func (m *BuyRecruitTreasureReply) GetDiscount() int32 {
	if m != nil {
		return m.Discount
	}
	return 0
}

type BuyRandomShopRefreshCntArg struct {
	BuyCnt int32 `protobuf:"varint,1,opt,name=BuyCnt,proto3" json:"BuyCnt,omitempty"`
}

func (m *BuyRandomShopRefreshCntArg) Reset()                    { *m = BuyRandomShopRefreshCntArg{} }
func (m *BuyRandomShopRefreshCntArg) String() string            { return proto.CompactTextString(m) }
func (*BuyRandomShopRefreshCntArg) ProtoMessage()               {}
func (*BuyRandomShopRefreshCntArg) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{40} }

func (m *BuyRandomShopRefreshCntArg) GetBuyCnt() int32 {
	if m != nil {
		return m.BuyCnt
	}
	return 0
}

type BuyRandomShopRefreshCntReply struct {
	RandomShopData *VisitRandomShopData `protobuf:"bytes,1,opt,name=RandomShopData" json:"RandomShopData,omitempty"`
}

func (m *BuyRandomShopRefreshCntReply) Reset()         { *m = BuyRandomShopRefreshCntReply{} }
func (m *BuyRandomShopRefreshCntReply) String() string { return proto.CompactTextString(m) }
func (*BuyRandomShopRefreshCntReply) ProtoMessage()    {}
func (*BuyRandomShopRefreshCntReply) Descriptor() ([]byte, []int) {
	return fileDescriptorShop, []int{41}
}

func (m *BuyRandomShopRefreshCntReply) GetRandomShopData() *VisitRandomShopData {
	if m != nil {
		return m.RandomShopData
	}
	return nil
}

type PieceExchangeIds struct {
	ExchangeCardIds []int32 `protobuf:"varint,1,rep,packed,name=ExchangeCardIds" json:"ExchangeCardIds,omitempty"`
	ExchangeSkinIds []int32 `protobuf:"varint,2,rep,packed,name=ExchangeSkinIds" json:"ExchangeSkinIds,omitempty"`
}

func (m *PieceExchangeIds) Reset()                    { *m = PieceExchangeIds{} }
func (m *PieceExchangeIds) String() string            { return proto.CompactTextString(m) }
func (*PieceExchangeIds) ProtoMessage()               {}
func (*PieceExchangeIds) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{42} }

func (m *PieceExchangeIds) GetExchangeCardIds() []int32 {
	if m != nil {
		return m.ExchangeCardIds
	}
	return nil
}

func (m *PieceExchangeIds) GetExchangeSkinIds() []int32 {
	if m != nil {
		return m.ExchangeSkinIds
	}
	return nil
}

type BuySoldGoldGiftReply struct {
	TreasureReward *OpenTreasureReply `protobuf:"bytes,1,opt,name=TreasureReward" json:"TreasureReward,omitempty"`
	NextGift       *SoldGoldGift      `protobuf:"bytes,2,opt,name=NextGift" json:"NextGift,omitempty"`
}

func (m *BuySoldGoldGiftReply) Reset()                    { *m = BuySoldGoldGiftReply{} }
func (m *BuySoldGoldGiftReply) String() string            { return proto.CompactTextString(m) }
func (*BuySoldGoldGiftReply) ProtoMessage()               {}
func (*BuySoldGoldGiftReply) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{43} }

func (m *BuySoldGoldGiftReply) GetTreasureReward() *OpenTreasureReply {
	if m != nil {
		return m.TreasureReward
	}
	return nil
}

func (m *BuySoldGoldGiftReply) GetNextGift() *SoldGoldGift {
	if m != nil {
		return m.NextGift
	}
	return nil
}

type MidasRechargeArg struct {
	OrderID      string `protobuf:"bytes,1,opt,name=OrderID,proto3" json:"OrderID,omitempty"`
	MidasOpenkey string `protobuf:"bytes,2,opt,name=MidasOpenkey,proto3" json:"MidasOpenkey,omitempty"`
	Pf           string `protobuf:"bytes,3,opt,name=Pf,proto3" json:"Pf,omitempty"`
	Pfkey        string `protobuf:"bytes,4,opt,name=Pfkey,proto3" json:"Pfkey,omitempty"`
}

func (m *MidasRechargeArg) Reset()                    { *m = MidasRechargeArg{} }
func (m *MidasRechargeArg) String() string            { return proto.CompactTextString(m) }
func (*MidasRechargeArg) ProtoMessage()               {}
func (*MidasRechargeArg) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{44} }

func (m *MidasRechargeArg) GetOrderID() string {
	if m != nil {
		return m.OrderID
	}
	return ""
}

func (m *MidasRechargeArg) GetMidasOpenkey() string {
	if m != nil {
		return m.MidasOpenkey
	}
	return ""
}

func (m *MidasRechargeArg) GetPf() string {
	if m != nil {
		return m.Pf
	}
	return ""
}

func (m *MidasRechargeArg) GetPfkey() string {
	if m != nil {
		return m.Pfkey
	}
	return ""
}

type BuyRecommendGiftReply struct {
	TreasureReward *OpenTreasureReply `protobuf:"bytes,1,opt,name=TreasureReward" json:"TreasureReward,omitempty"`
}

func (m *BuyRecommendGiftReply) Reset()                    { *m = BuyRecommendGiftReply{} }
func (m *BuyRecommendGiftReply) String() string            { return proto.CompactTextString(m) }
func (*BuyRecommendGiftReply) ProtoMessage()               {}
func (*BuyRecommendGiftReply) Descriptor() ([]byte, []int) { return fileDescriptorShop, []int{45} }

func (m *BuyRecommendGiftReply) GetTreasureReward() *OpenTreasureReply {
	if m != nil {
		return m.TreasureReward
	}
	return nil
}

func init() {
	proto.RegisterType((*UpdateLimitGiftArg)(nil), "pb.UpdateLimitGiftArg")
	proto.RegisterType((*UpdateJadeGoodsArg)(nil), "pb.UpdateJadeGoodsArg")
	proto.RegisterType((*UpdateGoldGoodsArg)(nil), "pb.UpdateGoldGoodsArg")
	proto.RegisterType((*UpdateFreeAdsArg)(nil), "pb.UpdateFreeAdsArg")
	proto.RegisterType((*UpdateShopDataArg)(nil), "pb.UpdateShopDataArg")
	proto.RegisterType((*LimitGift)(nil), "pb.LimitGift")
	proto.RegisterType((*JadeGoods)(nil), "pb.JadeGoods")
	proto.RegisterType((*SoldTreasure)(nil), "pb.SoldTreasure")
	proto.RegisterType((*SoldTreasureData)(nil), "pb.SoldTreasureData")
	proto.RegisterType((*RandomShop)(nil), "pb.RandomShop")
	proto.RegisterType((*RecruitTreasureData)(nil), "pb.RecruitTreasureData")
	proto.RegisterType((*VisitRandomShopData)(nil), "pb.VisitRandomShopData")
	proto.RegisterType((*GoldGoods)(nil), "pb.GoldGoods")
	proto.RegisterType((*SoldGoldGift)(nil), "pb.SoldGoldGift")
	proto.RegisterType((*SoldRecommendGift)(nil), "pb.SoldRecommendGift")
	proto.RegisterType((*ShopData)(nil), "pb.ShopData")
	proto.RegisterType((*VipCardGoods)(nil), "pb.VipCardGoods")
	proto.RegisterType((*BuyRandomShopArg)(nil), "pb.BuyRandomShopArg")
	proto.RegisterType((*BuyJadeArg)(nil), "pb.BuyJadeArg")
	proto.RegisterType((*BuyJadeReply)(nil), "pb.BuyJadeReply")
	proto.RegisterType((*BuyLimitGiftArg)(nil), "pb.BuyLimitGiftArg")
	proto.RegisterType((*GiftPrivilegeReward)(nil), "pb.GiftPrivilegeReward")
	proto.RegisterType((*BuyLimitGiftReply)(nil), "pb.BuyLimitGiftReply")
	proto.RegisterType((*BuySoldTreasureArg)(nil), "pb.BuySoldTreasureArg")
	proto.RegisterType((*BuySoldTreasureReply)(nil), "pb.BuySoldTreasureReply")
	proto.RegisterType((*BuyGoldArg)(nil), "pb.BuyGoldArg")
	proto.RegisterType((*BuyGoldReply)(nil), "pb.BuyGoldReply")
	proto.RegisterType((*SdkCreateOrderArg)(nil), "pb.SdkCreateOrderArg")
	proto.RegisterType((*SdkCreateOrderReply)(nil), "pb.SdkCreateOrderReply")
	proto.RegisterType((*RechargeLotteryReply)(nil), "pb.RechargeLotteryReply")
	proto.RegisterType((*SdkRechargeResult)(nil), "pb.SdkRechargeResult")
	proto.RegisterType((*IosPrePayArg)(nil), "pb.IosPrePayArg")
	proto.RegisterType((*BuyLimitGiftByJadeArg)(nil), "pb.BuyLimitGiftByJadeArg")
	proto.RegisterType((*GooglePlayRechargeArg)(nil), "pb.GooglePlayRechargeArg")
	proto.RegisterType((*BuyVipCardReply)(nil), "pb.BuyVipCardReply")
	proto.RegisterType((*PieceExchangeArg)(nil), "pb.PieceExchangeArg")
	proto.RegisterType((*TargetLimitGift)(nil), "pb.TargetLimitGift")
	proto.RegisterType((*IosRechargeArg)(nil), "pb.IosRechargeArg")
	proto.RegisterType((*BuyRecruitTreasureArg)(nil), "pb.BuyRecruitTreasureArg")
	proto.RegisterType((*BuyRecruitTreasureReply)(nil), "pb.BuyRecruitTreasureReply")
	proto.RegisterType((*BuyRandomShopRefreshCntArg)(nil), "pb.BuyRandomShopRefreshCntArg")
	proto.RegisterType((*BuyRandomShopRefreshCntReply)(nil), "pb.BuyRandomShopRefreshCntReply")
	proto.RegisterType((*PieceExchangeIds)(nil), "pb.PieceExchangeIds")
	proto.RegisterType((*BuySoldGoldGiftReply)(nil), "pb.BuySoldGoldGiftReply")
	proto.RegisterType((*MidasRechargeArg)(nil), "pb.MidasRechargeArg")
	proto.RegisterType((*BuyRecommendGiftReply)(nil), "pb.BuyRecommendGiftReply")
	proto.RegisterEnum("pb.UpdateShopDataArg_DataType", UpdateShopDataArg_DataType_name, UpdateShopDataArg_DataType_value)
	proto.RegisterEnum("pb.RecruitTreasureData_RewardType", RecruitTreasureData_RewardType_name, RecruitTreasureData_RewardType_value)
	proto.RegisterEnum("pb.SdkRechargeResult_RechargeErr", SdkRechargeResult_RechargeErr_name, SdkRechargeResult_RechargeErr_value)
	proto.RegisterEnum("pb.SdkRechargeResult_GoodsType", SdkRechargeResult_GoodsType_name, SdkRechargeResult_GoodsType_value)
	proto.RegisterEnum("pb.PieceExchangeArg_PieceTypeEnum", PieceExchangeArg_PieceTypeEnum_name, PieceExchangeArg_PieceTypeEnum_value)
}
func (m *UpdateLimitGiftArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateLimitGiftArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Gift) > 0 {
		for _, msg := range m.Gift {
			dAtA[i] = 0xa
			i++
			i = encodeVarintShop(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UpdateJadeGoodsArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateJadeGoodsArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.JadeGoodsList) > 0 {
		for _, msg := range m.JadeGoodsList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintShop(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UpdateGoldGoodsArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGoldGoodsArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GoldGoodsList) > 0 {
		for _, msg := range m.GoldGoodsList {
			dAtA[i] = 0xa
			i++
			i = encodeVarintShop(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.BuyGoldRemainTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.BuyGoldRemainTime))
	}
	return i, nil
}

func (m *UpdateFreeAdsArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateFreeAdsArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Adses) > 0 {
		for _, msg := range m.Adses {
			dAtA[i] = 0xa
			i++
			i = encodeVarintShop(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *UpdateShopDataArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateShopDataArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.Type))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *LimitGift) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LimitGift) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GiftID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.GiftID)))
		i += copy(dAtA[i:], m.GiftID)
	}
	if m.RemainTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.RemainTime))
	}
	if m.Price != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.Price))
	}
	if m.IsNew {
		dAtA[i] = 0x20
		i++
		if m.IsNew {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *JadeGoods) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JadeGoods) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GoodsID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.GoodsID)))
		i += copy(dAtA[i:], m.GoodsID)
	}
	if m.Price != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.Price))
	}
	if m.Jade != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.Jade))
	}
	if m.IsDouble {
		dAtA[i] = 0x20
		i++
		if m.IsDouble {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SoldTreasure) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SoldTreasure) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TreasureModelID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.TreasureModelID)))
		i += copy(dAtA[i:], m.TreasureModelID)
	}
	if m.NeedJade != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.NeedJade))
	}
	if m.NexRemainTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.NexRemainTime))
	}
	return i, nil
}

func (m *SoldTreasureData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SoldTreasureData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SoldTreasures) > 0 {
		for _, msg := range m.SoldTreasures {
			dAtA[i] = 0xa
			i++
			i = encodeVarintShop(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *RandomShop) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RandomShop) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GoodsId) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.GoodsId)))
		i += copy(dAtA[i:], m.GoodsId)
	}
	if m.Amount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.Amount))
	}
	if m.NeedJade != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.NeedJade))
	}
	if m.IsBuy {
		dAtA[i] = 0x20
		i++
		if m.IsBuy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NeedGold != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.NeedGold))
	}
	return i, nil
}

func (m *RecruitTreasureData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecruitTreasureData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TreasureModelID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.TreasureModelID)))
		i += copy(dAtA[i:], m.TreasureModelID)
	}
	if m.NeedJade != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.NeedJade))
	}
	if m.BuyTimes != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.BuyTimes))
	}
	if m.NexRemainTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.NexRemainTime))
	}
	if m.Discount != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.Discount))
	}
	if m.MaxBuyTimes != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.MaxBuyTimes))
	}
	if len(m.Rid) > 0 {
		dAtA2 := make([]byte, len(m.Rid)*10)
		var j1 int
		for _, num1 := range m.Rid {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x3a
		i++
		i = encodeVarintShop(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if m.RwType != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.RwType))
	}
	if m.NextRefreshTime != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.NextRefreshTime))
	}
	return i, nil
}

func (m *VisitRandomShopData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VisitRandomShopData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RandomShops) > 0 {
		for _, msg := range m.RandomShops {
			dAtA[i] = 0xa
			i++
			i = encodeVarintShop(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.NexRemainTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.NexRemainTime))
	}
	if m.BuyTimes != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.BuyTimes))
	}
	if m.Discount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.Discount))
	}
	if m.MaxBuyTimes != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.MaxBuyTimes))
	}
	if m.NeedJade != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.NeedJade))
	}
	return i, nil
}

func (m *GoldGoods) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoldGoods) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GoodsID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.GoodsID)))
		i += copy(dAtA[i:], m.GoodsID)
	}
	if m.Gold != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.Gold))
	}
	if m.NeedJade != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.NeedJade))
	}
	return i, nil
}

func (m *SoldGoldGift) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SoldGoldGift) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TreasureID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.TreasureID)))
		i += copy(dAtA[i:], m.TreasureID)
	}
	if m.JadePrice != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.JadePrice))
	}
	if m.CanBuyRemainTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.CanBuyRemainTime))
	}
	return i, nil
}

func (m *SoldRecommendGift) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SoldRecommendGift) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GiftID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.GiftID)))
		i += copy(dAtA[i:], m.GiftID)
	}
	if m.JadePrice != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.JadePrice))
	}
	if len(m.Cards) > 0 {
		for k, _ := range m.Cards {
			dAtA[i] = 0x1a
			i++
			v := m.Cards[k]
			mapSize := 1 + sovShop(uint64(k)) + 1 + sovShop(uint64(v))
			i = encodeVarintShop(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintShop(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			i = encodeVarintShop(dAtA, i, uint64(v))
		}
	}
	if m.RefreshRemainTime != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.RefreshRemainTime))
	}
	return i, nil
}

func (m *ShopData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShopData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Gift) > 0 {
		for _, msg := range m.Gift {
			dAtA[i] = 0xa
			i++
			i = encodeVarintShop(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.SoldTreasures != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.SoldTreasures.Size()))
		n3, err := m.SoldTreasures.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.RecruitTreasure != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.RecruitTreasure.Size()))
		n4, err := m.RecruitTreasure.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.JadeGoodsList) > 0 {
		for _, msg := range m.JadeGoodsList {
			dAtA[i] = 0x22
			i++
			i = encodeVarintShop(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.GoldGoodsList) > 0 {
		for _, msg := range m.GoldGoodsList {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintShop(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Adses) > 0 {
		for _, msg := range m.Adses {
			dAtA[i] = 0x32
			i++
			i = encodeVarintShop(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.BuyGoldRemainTime != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.BuyGoldRemainTime))
	}
	if m.VipCard != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.VipCard.Size()))
		n5, err := m.VipCard.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.RandomShopData != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.RandomShopData.Size()))
		n6, err := m.RandomShopData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.GoldGift != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.GoldGift.Size()))
		n7, err := m.GoldGift.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.RecommendGift != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.RecommendGift.Size()))
		n8, err := m.RecommendGift.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *VipCardGoods) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VipCardGoods) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GoodsID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.GoodsID)))
		i += copy(dAtA[i:], m.GoodsID)
	}
	if m.JadePrice != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.JadePrice))
	}
	if m.Price != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.Price))
	}
	return i, nil
}

func (m *BuyRandomShopArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuyRandomShopArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GoodsID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.GoodsID)))
		i += copy(dAtA[i:], m.GoodsID)
	}
	if m.Amount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.Amount))
	}
	return i, nil
}

func (m *BuyJadeArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuyJadeArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GoodsID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.GoodsID)))
		i += copy(dAtA[i:], m.GoodsID)
	}
	if len(m.Receipt) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.Receipt)))
		i += copy(dAtA[i:], m.Receipt)
	}
	return i, nil
}

func (m *BuyJadeReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuyJadeReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Jade != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.Jade))
	}
	if m.RewardJade != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.RewardJade))
	}
	return i, nil
}

func (m *BuyLimitGiftArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuyLimitGiftArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GiftID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.GiftID)))
		i += copy(dAtA[i:], m.GiftID)
	}
	if len(m.Receipt) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.Receipt)))
		i += copy(dAtA[i:], m.Receipt)
	}
	return i, nil
}

func (m *GiftPrivilegeReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GiftPrivilegeReward) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PrivID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.PrivID))
	}
	if m.RemainTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.RemainTime))
	}
	return i, nil
}

func (m *BuyLimitGiftReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuyLimitGiftReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GiftReward != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.GiftReward.Size()))
		n9, err := m.GiftReward.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.Privileges) > 0 {
		for _, msg := range m.Privileges {
			dAtA[i] = 0x12
			i++
			i = encodeVarintShop(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.NextGift != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.NextGift.Size()))
		n10, err := m.NextGift.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *BuySoldTreasureArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuySoldTreasureArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TreasureModelID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.TreasureModelID)))
		i += copy(dAtA[i:], m.TreasureModelID)
	}
	return i, nil
}

func (m *BuySoldTreasureReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuySoldTreasureReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TreasureReward != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.TreasureReward.Size()))
		n11, err := m.TreasureReward.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.NewSoldTreasure != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.NewSoldTreasure.Size()))
		n12, err := m.NewSoldTreasure.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *BuyGoldArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuyGoldArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GoodsID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.GoodsID)))
		i += copy(dAtA[i:], m.GoodsID)
	}
	return i, nil
}

func (m *BuyGoldReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuyGoldReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Gold != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.Gold))
	}
	if m.NextRemainTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.NextRemainTime))
	}
	return i, nil
}

func (m *SdkCreateOrderArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SdkCreateOrderArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GoodsID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.GoodsID)))
		i += copy(dAtA[i:], m.GoodsID)
	}
	return i, nil
}

func (m *SdkCreateOrderReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SdkCreateOrderReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OrderID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.OrderID)))
		i += copy(dAtA[i:], m.OrderID)
	}
	return i, nil
}

func (m *RechargeLotteryReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RechargeLotteryReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RewardIdx != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.RewardIdx))
	}
	if m.Privileges != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.Privileges.Size()))
		n13, err := m.Privileges.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *SdkRechargeResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SdkRechargeResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Errcode != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.Errcode))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.Type))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *IosPrePayArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IosPrePayArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GoodsID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.GoodsID)))
		i += copy(dAtA[i:], m.GoodsID)
	}
	return i, nil
}

func (m *BuyLimitGiftByJadeArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuyLimitGiftByJadeArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GiftID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.GiftID)))
		i += copy(dAtA[i:], m.GiftID)
	}
	return i, nil
}

func (m *GooglePlayRechargeArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GooglePlayRechargeArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GoodsID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.GoodsID)))
		i += copy(dAtA[i:], m.GoodsID)
	}
	if len(m.InappPurchaseData) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.InappPurchaseData)))
		i += copy(dAtA[i:], m.InappPurchaseData)
	}
	if len(m.InappDataSignature) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.InappDataSignature)))
		i += copy(dAtA[i:], m.InappDataSignature)
	}
	if m.Money != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.Money))
	}
	if len(m.Currency) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.Currency)))
		i += copy(dAtA[i:], m.Currency)
	}
	return i, nil
}

func (m *BuyVipCardReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuyVipCardReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HeadFrame) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.HeadFrame)))
		i += copy(dAtA[i:], m.HeadFrame)
	}
	if m.RemainTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.RemainTime))
	}
	return i, nil
}

func (m *PieceExchangeArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PieceExchangeArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PieceType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.PieceType))
	}
	if m.GoodsID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.GoodsID))
	}
	return i, nil
}

func (m *TargetLimitGift) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TargetLimitGift) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GiftID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.GiftID)))
		i += copy(dAtA[i:], m.GiftID)
	}
	return i, nil
}

func (m *IosRechargeArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IosRechargeArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GoodsID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.GoodsID)))
		i += copy(dAtA[i:], m.GoodsID)
	}
	if len(m.Receipt) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.Receipt)))
		i += copy(dAtA[i:], m.Receipt)
	}
	return i, nil
}

func (m *BuyRecruitTreasureArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuyRecruitTreasureArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BuyCnt != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.BuyCnt))
	}
	return i, nil
}

func (m *BuyRecruitTreasureReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuyRecruitTreasureReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TreasureReward != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.TreasureReward.Size()))
		n14, err := m.TreasureReward.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.NextRemainTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.NextRemainTime))
	}
	if m.Discount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.Discount))
	}
	return i, nil
}

func (m *BuyRandomShopRefreshCntArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuyRandomShopRefreshCntArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BuyCnt != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.BuyCnt))
	}
	return i, nil
}

func (m *BuyRandomShopRefreshCntReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuyRandomShopRefreshCntReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RandomShopData != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.RandomShopData.Size()))
		n15, err := m.RandomShopData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *PieceExchangeIds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PieceExchangeIds) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ExchangeCardIds) > 0 {
		dAtA17 := make([]byte, len(m.ExchangeCardIds)*10)
		var j16 int
		for _, num1 := range m.ExchangeCardIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintShop(dAtA, i, uint64(j16))
		i += copy(dAtA[i:], dAtA17[:j16])
	}
	if len(m.ExchangeSkinIds) > 0 {
		dAtA19 := make([]byte, len(m.ExchangeSkinIds)*10)
		var j18 int
		for _, num1 := range m.ExchangeSkinIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA19[j18] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j18++
			}
			dAtA19[j18] = uint8(num)
			j18++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintShop(dAtA, i, uint64(j18))
		i += copy(dAtA[i:], dAtA19[:j18])
	}
	return i, nil
}

func (m *BuySoldGoldGiftReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuySoldGoldGiftReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TreasureReward != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.TreasureReward.Size()))
		n20, err := m.TreasureReward.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.NextGift != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.NextGift.Size()))
		n21, err := m.NextGift.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func (m *MidasRechargeArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MidasRechargeArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OrderID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.OrderID)))
		i += copy(dAtA[i:], m.OrderID)
	}
	if len(m.MidasOpenkey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.MidasOpenkey)))
		i += copy(dAtA[i:], m.MidasOpenkey)
	}
	if len(m.Pf) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.Pf)))
		i += copy(dAtA[i:], m.Pf)
	}
	if len(m.Pfkey) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintShop(dAtA, i, uint64(len(m.Pfkey)))
		i += copy(dAtA[i:], m.Pfkey)
	}
	return i, nil
}

func (m *BuyRecommendGiftReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuyRecommendGiftReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TreasureReward != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintShop(dAtA, i, uint64(m.TreasureReward.Size()))
		n22, err := m.TreasureReward.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func encodeVarintShop(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *UpdateLimitGiftArg) Size() (n int) {
	var l int
	_ = l
	if len(m.Gift) > 0 {
		for _, e := range m.Gift {
			l = e.Size()
			n += 1 + l + sovShop(uint64(l))
		}
	}
	return n
}

func (m *UpdateJadeGoodsArg) Size() (n int) {
	var l int
	_ = l
	if len(m.JadeGoodsList) > 0 {
		for _, e := range m.JadeGoodsList {
			l = e.Size()
			n += 1 + l + sovShop(uint64(l))
		}
	}
	return n
}

func (m *UpdateGoldGoodsArg) Size() (n int) {
	var l int
	_ = l
	if len(m.GoldGoodsList) > 0 {
		for _, e := range m.GoldGoodsList {
			l = e.Size()
			n += 1 + l + sovShop(uint64(l))
		}
	}
	if m.BuyGoldRemainTime != 0 {
		n += 1 + sovShop(uint64(m.BuyGoldRemainTime))
	}
	return n
}

func (m *UpdateFreeAdsArg) Size() (n int) {
	var l int
	_ = l
	if len(m.Adses) > 0 {
		for _, e := range m.Adses {
			l = e.Size()
			n += 1 + l + sovShop(uint64(l))
		}
	}
	return n
}

func (m *UpdateShopDataArg) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovShop(uint64(m.Type))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	return n
}

func (m *LimitGift) Size() (n int) {
	var l int
	_ = l
	l = len(m.GiftID)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	if m.RemainTime != 0 {
		n += 1 + sovShop(uint64(m.RemainTime))
	}
	if m.Price != 0 {
		n += 1 + sovShop(uint64(m.Price))
	}
	if m.IsNew {
		n += 2
	}
	return n
}

func (m *JadeGoods) Size() (n int) {
	var l int
	_ = l
	l = len(m.GoodsID)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	if m.Price != 0 {
		n += 1 + sovShop(uint64(m.Price))
	}
	if m.Jade != 0 {
		n += 1 + sovShop(uint64(m.Jade))
	}
	if m.IsDouble {
		n += 2
	}
	return n
}

func (m *SoldTreasure) Size() (n int) {
	var l int
	_ = l
	l = len(m.TreasureModelID)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	if m.NeedJade != 0 {
		n += 1 + sovShop(uint64(m.NeedJade))
	}
	if m.NexRemainTime != 0 {
		n += 1 + sovShop(uint64(m.NexRemainTime))
	}
	return n
}

func (m *SoldTreasureData) Size() (n int) {
	var l int
	_ = l
	if len(m.SoldTreasures) > 0 {
		for _, e := range m.SoldTreasures {
			l = e.Size()
			n += 1 + l + sovShop(uint64(l))
		}
	}
	return n
}

func (m *RandomShop) Size() (n int) {
	var l int
	_ = l
	l = len(m.GoodsId)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	if m.Amount != 0 {
		n += 1 + sovShop(uint64(m.Amount))
	}
	if m.NeedJade != 0 {
		n += 1 + sovShop(uint64(m.NeedJade))
	}
	if m.IsBuy {
		n += 2
	}
	if m.NeedGold != 0 {
		n += 1 + sovShop(uint64(m.NeedGold))
	}
	return n
}

func (m *RecruitTreasureData) Size() (n int) {
	var l int
	_ = l
	l = len(m.TreasureModelID)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	if m.NeedJade != 0 {
		n += 1 + sovShop(uint64(m.NeedJade))
	}
	if m.BuyTimes != 0 {
		n += 1 + sovShop(uint64(m.BuyTimes))
	}
	if m.NexRemainTime != 0 {
		n += 1 + sovShop(uint64(m.NexRemainTime))
	}
	if m.Discount != 0 {
		n += 1 + sovShop(uint64(m.Discount))
	}
	if m.MaxBuyTimes != 0 {
		n += 1 + sovShop(uint64(m.MaxBuyTimes))
	}
	if len(m.Rid) > 0 {
		l = 0
		for _, e := range m.Rid {
			l += sovShop(uint64(e))
		}
		n += 1 + sovShop(uint64(l)) + l
	}
	if m.RwType != 0 {
		n += 1 + sovShop(uint64(m.RwType))
	}
	if m.NextRefreshTime != 0 {
		n += 1 + sovShop(uint64(m.NextRefreshTime))
	}
	return n
}

func (m *VisitRandomShopData) Size() (n int) {
	var l int
	_ = l
	if len(m.RandomShops) > 0 {
		for _, e := range m.RandomShops {
			l = e.Size()
			n += 1 + l + sovShop(uint64(l))
		}
	}
	if m.NexRemainTime != 0 {
		n += 1 + sovShop(uint64(m.NexRemainTime))
	}
	if m.BuyTimes != 0 {
		n += 1 + sovShop(uint64(m.BuyTimes))
	}
	if m.Discount != 0 {
		n += 1 + sovShop(uint64(m.Discount))
	}
	if m.MaxBuyTimes != 0 {
		n += 1 + sovShop(uint64(m.MaxBuyTimes))
	}
	if m.NeedJade != 0 {
		n += 1 + sovShop(uint64(m.NeedJade))
	}
	return n
}

func (m *GoldGoods) Size() (n int) {
	var l int
	_ = l
	l = len(m.GoodsID)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	if m.Gold != 0 {
		n += 1 + sovShop(uint64(m.Gold))
	}
	if m.NeedJade != 0 {
		n += 1 + sovShop(uint64(m.NeedJade))
	}
	return n
}

func (m *SoldGoldGift) Size() (n int) {
	var l int
	_ = l
	l = len(m.TreasureID)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	if m.JadePrice != 0 {
		n += 1 + sovShop(uint64(m.JadePrice))
	}
	if m.CanBuyRemainTime != 0 {
		n += 1 + sovShop(uint64(m.CanBuyRemainTime))
	}
	return n
}

func (m *SoldRecommendGift) Size() (n int) {
	var l int
	_ = l
	l = len(m.GiftID)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	if m.JadePrice != 0 {
		n += 1 + sovShop(uint64(m.JadePrice))
	}
	if len(m.Cards) > 0 {
		for k, v := range m.Cards {
			_ = k
			_ = v
			mapEntrySize := 1 + sovShop(uint64(k)) + 1 + sovShop(uint64(v))
			n += mapEntrySize + 1 + sovShop(uint64(mapEntrySize))
		}
	}
	if m.RefreshRemainTime != 0 {
		n += 1 + sovShop(uint64(m.RefreshRemainTime))
	}
	return n
}

func (m *ShopData) Size() (n int) {
	var l int
	_ = l
	if len(m.Gift) > 0 {
		for _, e := range m.Gift {
			l = e.Size()
			n += 1 + l + sovShop(uint64(l))
		}
	}
	if m.SoldTreasures != nil {
		l = m.SoldTreasures.Size()
		n += 1 + l + sovShop(uint64(l))
	}
	if m.RecruitTreasure != nil {
		l = m.RecruitTreasure.Size()
		n += 1 + l + sovShop(uint64(l))
	}
	if len(m.JadeGoodsList) > 0 {
		for _, e := range m.JadeGoodsList {
			l = e.Size()
			n += 1 + l + sovShop(uint64(l))
		}
	}
	if len(m.GoldGoodsList) > 0 {
		for _, e := range m.GoldGoodsList {
			l = e.Size()
			n += 1 + l + sovShop(uint64(l))
		}
	}
	if len(m.Adses) > 0 {
		for _, e := range m.Adses {
			l = e.Size()
			n += 1 + l + sovShop(uint64(l))
		}
	}
	if m.BuyGoldRemainTime != 0 {
		n += 1 + sovShop(uint64(m.BuyGoldRemainTime))
	}
	if m.VipCard != nil {
		l = m.VipCard.Size()
		n += 1 + l + sovShop(uint64(l))
	}
	if m.RandomShopData != nil {
		l = m.RandomShopData.Size()
		n += 1 + l + sovShop(uint64(l))
	}
	if m.GoldGift != nil {
		l = m.GoldGift.Size()
		n += 1 + l + sovShop(uint64(l))
	}
	if m.RecommendGift != nil {
		l = m.RecommendGift.Size()
		n += 1 + l + sovShop(uint64(l))
	}
	return n
}

func (m *VipCardGoods) Size() (n int) {
	var l int
	_ = l
	l = len(m.GoodsID)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	if m.JadePrice != 0 {
		n += 1 + sovShop(uint64(m.JadePrice))
	}
	if m.Price != 0 {
		n += 1 + sovShop(uint64(m.Price))
	}
	return n
}

func (m *BuyRandomShopArg) Size() (n int) {
	var l int
	_ = l
	l = len(m.GoodsID)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	if m.Amount != 0 {
		n += 1 + sovShop(uint64(m.Amount))
	}
	return n
}

func (m *BuyJadeArg) Size() (n int) {
	var l int
	_ = l
	l = len(m.GoodsID)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	l = len(m.Receipt)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	return n
}

func (m *BuyJadeReply) Size() (n int) {
	var l int
	_ = l
	if m.Jade != 0 {
		n += 1 + sovShop(uint64(m.Jade))
	}
	if m.RewardJade != 0 {
		n += 1 + sovShop(uint64(m.RewardJade))
	}
	return n
}

func (m *BuyLimitGiftArg) Size() (n int) {
	var l int
	_ = l
	l = len(m.GiftID)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	l = len(m.Receipt)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	return n
}

func (m *GiftPrivilegeReward) Size() (n int) {
	var l int
	_ = l
	if m.PrivID != 0 {
		n += 1 + sovShop(uint64(m.PrivID))
	}
	if m.RemainTime != 0 {
		n += 1 + sovShop(uint64(m.RemainTime))
	}
	return n
}

func (m *BuyLimitGiftReply) Size() (n int) {
	var l int
	_ = l
	if m.GiftReward != nil {
		l = m.GiftReward.Size()
		n += 1 + l + sovShop(uint64(l))
	}
	if len(m.Privileges) > 0 {
		for _, e := range m.Privileges {
			l = e.Size()
			n += 1 + l + sovShop(uint64(l))
		}
	}
	if m.NextGift != nil {
		l = m.NextGift.Size()
		n += 1 + l + sovShop(uint64(l))
	}
	return n
}

func (m *BuySoldTreasureArg) Size() (n int) {
	var l int
	_ = l
	l = len(m.TreasureModelID)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	return n
}

func (m *BuySoldTreasureReply) Size() (n int) {
	var l int
	_ = l
	if m.TreasureReward != nil {
		l = m.TreasureReward.Size()
		n += 1 + l + sovShop(uint64(l))
	}
	if m.NewSoldTreasure != nil {
		l = m.NewSoldTreasure.Size()
		n += 1 + l + sovShop(uint64(l))
	}
	return n
}

func (m *BuyGoldArg) Size() (n int) {
	var l int
	_ = l
	l = len(m.GoodsID)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	return n
}

func (m *BuyGoldReply) Size() (n int) {
	var l int
	_ = l
	if m.Gold != 0 {
		n += 1 + sovShop(uint64(m.Gold))
	}
	if m.NextRemainTime != 0 {
		n += 1 + sovShop(uint64(m.NextRemainTime))
	}
	return n
}

func (m *SdkCreateOrderArg) Size() (n int) {
	var l int
	_ = l
	l = len(m.GoodsID)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	return n
}

func (m *SdkCreateOrderReply) Size() (n int) {
	var l int
	_ = l
	l = len(m.OrderID)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	return n
}

func (m *RechargeLotteryReply) Size() (n int) {
	var l int
	_ = l
	if m.RewardIdx != 0 {
		n += 1 + sovShop(uint64(m.RewardIdx))
	}
	if m.Privileges != nil {
		l = m.Privileges.Size()
		n += 1 + l + sovShop(uint64(l))
	}
	return n
}

func (m *SdkRechargeResult) Size() (n int) {
	var l int
	_ = l
	if m.Errcode != 0 {
		n += 1 + sovShop(uint64(m.Errcode))
	}
	if m.Type != 0 {
		n += 1 + sovShop(uint64(m.Type))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	return n
}

func (m *IosPrePayArg) Size() (n int) {
	var l int
	_ = l
	l = len(m.GoodsID)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	return n
}

func (m *BuyLimitGiftByJadeArg) Size() (n int) {
	var l int
	_ = l
	l = len(m.GiftID)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	return n
}

func (m *GooglePlayRechargeArg) Size() (n int) {
	var l int
	_ = l
	l = len(m.GoodsID)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	l = len(m.InappPurchaseData)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	l = len(m.InappDataSignature)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	if m.Money != 0 {
		n += 1 + sovShop(uint64(m.Money))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	return n
}

func (m *BuyVipCardReply) Size() (n int) {
	var l int
	_ = l
	l = len(m.HeadFrame)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	if m.RemainTime != 0 {
		n += 1 + sovShop(uint64(m.RemainTime))
	}
	return n
}

func (m *PieceExchangeArg) Size() (n int) {
	var l int
	_ = l
	if m.PieceType != 0 {
		n += 1 + sovShop(uint64(m.PieceType))
	}
	if m.GoodsID != 0 {
		n += 1 + sovShop(uint64(m.GoodsID))
	}
	return n
}

func (m *TargetLimitGift) Size() (n int) {
	var l int
	_ = l
	l = len(m.GiftID)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	return n
}

func (m *IosRechargeArg) Size() (n int) {
	var l int
	_ = l
	l = len(m.GoodsID)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	l = len(m.Receipt)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	return n
}

func (m *BuyRecruitTreasureArg) Size() (n int) {
	var l int
	_ = l
	if m.BuyCnt != 0 {
		n += 1 + sovShop(uint64(m.BuyCnt))
	}
	return n
}

func (m *BuyRecruitTreasureReply) Size() (n int) {
	var l int
	_ = l
	if m.TreasureReward != nil {
		l = m.TreasureReward.Size()
		n += 1 + l + sovShop(uint64(l))
	}
	if m.NextRemainTime != 0 {
		n += 1 + sovShop(uint64(m.NextRemainTime))
	}
	if m.Discount != 0 {
		n += 1 + sovShop(uint64(m.Discount))
	}
	return n
}

func (m *BuyRandomShopRefreshCntArg) Size() (n int) {
	var l int
	_ = l
	if m.BuyCnt != 0 {
		n += 1 + sovShop(uint64(m.BuyCnt))
	}
	return n
}

func (m *BuyRandomShopRefreshCntReply) Size() (n int) {
	var l int
	_ = l
	if m.RandomShopData != nil {
		l = m.RandomShopData.Size()
		n += 1 + l + sovShop(uint64(l))
	}
	return n
}

func (m *PieceExchangeIds) Size() (n int) {
	var l int
	_ = l
	if len(m.ExchangeCardIds) > 0 {
		l = 0
		for _, e := range m.ExchangeCardIds {
			l += sovShop(uint64(e))
		}
		n += 1 + sovShop(uint64(l)) + l
	}
	if len(m.ExchangeSkinIds) > 0 {
		l = 0
		for _, e := range m.ExchangeSkinIds {
			l += sovShop(uint64(e))
		}
		n += 1 + sovShop(uint64(l)) + l
	}
	return n
}

func (m *BuySoldGoldGiftReply) Size() (n int) {
	var l int
	_ = l
	if m.TreasureReward != nil {
		l = m.TreasureReward.Size()
		n += 1 + l + sovShop(uint64(l))
	}
	if m.NextGift != nil {
		l = m.NextGift.Size()
		n += 1 + l + sovShop(uint64(l))
	}
	return n
}

func (m *MidasRechargeArg) Size() (n int) {
	var l int
	_ = l
	l = len(m.OrderID)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	l = len(m.MidasOpenkey)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	l = len(m.Pf)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	l = len(m.Pfkey)
	if l > 0 {
		n += 1 + l + sovShop(uint64(l))
	}
	return n
}

func (m *BuyRecommendGiftReply) Size() (n int) {
	var l int
	_ = l
	if m.TreasureReward != nil {
		l = m.TreasureReward.Size()
		n += 1 + l + sovShop(uint64(l))
	}
	return n
}

func sovShop(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozShop(x uint64) (n int) {
	return sovShop(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UpdateLimitGiftArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateLimitGiftArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateLimitGiftArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gift", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gift = append(m.Gift, &LimitGift{})
			if err := m.Gift[len(m.Gift)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateJadeGoodsArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateJadeGoodsArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateJadeGoodsArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JadeGoodsList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JadeGoodsList = append(m.JadeGoodsList, &JadeGoods{})
			if err := m.JadeGoodsList[len(m.JadeGoodsList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGoldGoodsArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGoldGoodsArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGoldGoodsArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoldGoodsList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoldGoodsList = append(m.GoldGoodsList, &GoldGoods{})
			if err := m.GoldGoodsList[len(m.GoldGoodsList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyGoldRemainTime", wireType)
			}
			m.BuyGoldRemainTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyGoldRemainTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateFreeAdsArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateFreeAdsArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateFreeAdsArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Adses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Adses = append(m.Adses, &ShopFreeAds{})
			if err := m.Adses[len(m.Adses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateShopDataArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateShopDataArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateShopDataArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (UpdateShopDataArg_DataType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LimitGift) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LimitGift: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LimitGift: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GiftID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainTime", wireType)
			}
			m.RemainTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemainTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNew", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNew = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JadeGoods) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JadeGoods: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JadeGoods: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoodsID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jade", wireType)
			}
			m.Jade = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Jade |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDouble", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDouble = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SoldTreasure) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SoldTreasure: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SoldTreasure: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasureModelID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TreasureModelID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedJade", wireType)
			}
			m.NeedJade = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NeedJade |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NexRemainTime", wireType)
			}
			m.NexRemainTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NexRemainTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SoldTreasureData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SoldTreasureData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SoldTreasureData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoldTreasures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SoldTreasures = append(m.SoldTreasures, &SoldTreasure{})
			if err := m.SoldTreasures[len(m.SoldTreasures)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RandomShop) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RandomShop: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RandomShop: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoodsId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedJade", wireType)
			}
			m.NeedJade = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NeedJade |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBuy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBuy = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedGold", wireType)
			}
			m.NeedGold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NeedGold |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecruitTreasureData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecruitTreasureData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecruitTreasureData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasureModelID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TreasureModelID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedJade", wireType)
			}
			m.NeedJade = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NeedJade |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyTimes", wireType)
			}
			m.BuyTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NexRemainTime", wireType)
			}
			m.NexRemainTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NexRemainTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Discount", wireType)
			}
			m.Discount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Discount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBuyTimes", wireType)
			}
			m.MaxBuyTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBuyTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowShop
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Rid = append(m.Rid, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowShop
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthShop
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowShop
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Rid = append(m.Rid, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Rid", wireType)
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RwType", wireType)
			}
			m.RwType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RwType |= (RecruitTreasureData_RewardType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextRefreshTime", wireType)
			}
			m.NextRefreshTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextRefreshTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VisitRandomShopData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VisitRandomShopData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VisitRandomShopData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomShops", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RandomShops = append(m.RandomShops, &RandomShop{})
			if err := m.RandomShops[len(m.RandomShops)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NexRemainTime", wireType)
			}
			m.NexRemainTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NexRemainTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyTimes", wireType)
			}
			m.BuyTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Discount", wireType)
			}
			m.Discount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Discount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBuyTimes", wireType)
			}
			m.MaxBuyTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBuyTimes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedJade", wireType)
			}
			m.NeedJade = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NeedJade |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoldGoods) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GoldGoods: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GoldGoods: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoodsID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			m.Gold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gold |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedJade", wireType)
			}
			m.NeedJade = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NeedJade |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SoldGoldGift) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SoldGoldGift: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SoldGoldGift: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasureID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TreasureID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JadePrice", wireType)
			}
			m.JadePrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JadePrice |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanBuyRemainTime", wireType)
			}
			m.CanBuyRemainTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CanBuyRemainTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SoldRecommendGift) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SoldRecommendGift: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SoldRecommendGift: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GiftID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JadePrice", wireType)
			}
			m.JadePrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JadePrice |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cards == nil {
				m.Cards = make(map[uint32]int32)
			}
			var mapkey uint32
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowShop
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowShop
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowShop
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipShop(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthShop
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Cards[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshRemainTime", wireType)
			}
			m.RefreshRemainTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefreshRemainTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShopData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShopData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShopData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gift", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gift = append(m.Gift, &LimitGift{})
			if err := m.Gift[len(m.Gift)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SoldTreasures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SoldTreasures == nil {
				m.SoldTreasures = &SoldTreasureData{}
			}
			if err := m.SoldTreasures.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecruitTreasure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecruitTreasure == nil {
				m.RecruitTreasure = &RecruitTreasureData{}
			}
			if err := m.RecruitTreasure.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JadeGoodsList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JadeGoodsList = append(m.JadeGoodsList, &JadeGoods{})
			if err := m.JadeGoodsList[len(m.JadeGoodsList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoldGoodsList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoldGoodsList = append(m.GoldGoodsList, &GoldGoods{})
			if err := m.GoldGoodsList[len(m.GoldGoodsList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Adses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Adses = append(m.Adses, &ShopFreeAds{})
			if err := m.Adses[len(m.Adses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyGoldRemainTime", wireType)
			}
			m.BuyGoldRemainTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyGoldRemainTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VipCard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VipCard == nil {
				m.VipCard = &VipCardGoods{}
			}
			if err := m.VipCard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomShopData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RandomShopData == nil {
				m.RandomShopData = &VisitRandomShopData{}
			}
			if err := m.RandomShopData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoldGift", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GoldGift == nil {
				m.GoldGift = &SoldGoldGift{}
			}
			if err := m.GoldGift.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecommendGift", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RecommendGift == nil {
				m.RecommendGift = &SoldRecommendGift{}
			}
			if err := m.RecommendGift.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VipCardGoods) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VipCardGoods: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VipCardGoods: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoodsID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JadePrice", wireType)
			}
			m.JadePrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JadePrice |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuyRandomShopArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuyRandomShopArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuyRandomShopArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoodsID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuyJadeArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuyJadeArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuyJadeArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoodsID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receipt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receipt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuyJadeReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuyJadeReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuyJadeReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jade", wireType)
			}
			m.Jade = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Jade |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardJade", wireType)
			}
			m.RewardJade = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardJade |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuyLimitGiftArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuyLimitGiftArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuyLimitGiftArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GiftID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receipt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receipt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GiftPrivilegeReward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GiftPrivilegeReward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GiftPrivilegeReward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivID", wireType)
			}
			m.PrivID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrivID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainTime", wireType)
			}
			m.RemainTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemainTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuyLimitGiftReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuyLimitGiftReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuyLimitGiftReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftReward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GiftReward == nil {
				m.GiftReward = &OpenTreasureReply{}
			}
			if err := m.GiftReward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Privileges = append(m.Privileges, &GiftPrivilegeReward{})
			if err := m.Privileges[len(m.Privileges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextGift", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NextGift == nil {
				m.NextGift = &LimitGift{}
			}
			if err := m.NextGift.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuySoldTreasureArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuySoldTreasureArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuySoldTreasureArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasureModelID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TreasureModelID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuySoldTreasureReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuySoldTreasureReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuySoldTreasureReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasureReward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TreasureReward == nil {
				m.TreasureReward = &OpenTreasureReply{}
			}
			if err := m.TreasureReward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewSoldTreasure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewSoldTreasure == nil {
				m.NewSoldTreasure = &SoldTreasureData{}
			}
			if err := m.NewSoldTreasure.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuyGoldArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuyGoldArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuyGoldArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoodsID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuyGoldReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuyGoldReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuyGoldReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			m.Gold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gold |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextRemainTime", wireType)
			}
			m.NextRemainTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextRemainTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SdkCreateOrderArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SdkCreateOrderArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SdkCreateOrderArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoodsID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SdkCreateOrderReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SdkCreateOrderReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SdkCreateOrderReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RechargeLotteryReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RechargeLotteryReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RechargeLotteryReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardIdx", wireType)
			}
			m.RewardIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardIdx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Privileges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Privileges == nil {
				m.Privileges = &GiftPrivilegeReward{}
			}
			if err := m.Privileges.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SdkRechargeResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SdkRechargeResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SdkRechargeResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errcode", wireType)
			}
			m.Errcode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Errcode |= (SdkRechargeResult_RechargeErr(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (SdkRechargeResult_GoodsType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IosPrePayArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IosPrePayArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IosPrePayArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoodsID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuyLimitGiftByJadeArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuyLimitGiftByJadeArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuyLimitGiftByJadeArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GiftID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GooglePlayRechargeArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GooglePlayRechargeArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GooglePlayRechargeArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoodsID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InappPurchaseData", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InappPurchaseData = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InappDataSignature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InappDataSignature = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Money", wireType)
			}
			m.Money = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Money |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuyVipCardReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuyVipCardReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuyVipCardReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadFrame", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeadFrame = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainTime", wireType)
			}
			m.RemainTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemainTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PieceExchangeArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PieceExchangeArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PieceExchangeArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PieceType", wireType)
			}
			m.PieceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PieceType |= (PieceExchangeArg_PieceTypeEnum(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsID", wireType)
			}
			m.GoodsID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GoodsID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TargetLimitGift) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TargetLimitGift: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TargetLimitGift: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GiftID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IosRechargeArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IosRechargeArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IosRechargeArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoodsID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Receipt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Receipt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuyRecruitTreasureArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuyRecruitTreasureArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuyRecruitTreasureArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyCnt", wireType)
			}
			m.BuyCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyCnt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuyRecruitTreasureReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuyRecruitTreasureReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuyRecruitTreasureReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasureReward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TreasureReward == nil {
				m.TreasureReward = &OpenTreasureReply{}
			}
			if err := m.TreasureReward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextRemainTime", wireType)
			}
			m.NextRemainTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextRemainTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Discount", wireType)
			}
			m.Discount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Discount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuyRandomShopRefreshCntArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuyRandomShopRefreshCntArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuyRandomShopRefreshCntArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuyCnt", wireType)
			}
			m.BuyCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BuyCnt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuyRandomShopRefreshCntReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuyRandomShopRefreshCntReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuyRandomShopRefreshCntReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomShopData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RandomShopData == nil {
				m.RandomShopData = &VisitRandomShopData{}
			}
			if err := m.RandomShopData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PieceExchangeIds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PieceExchangeIds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PieceExchangeIds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowShop
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ExchangeCardIds = append(m.ExchangeCardIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowShop
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthShop
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowShop
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ExchangeCardIds = append(m.ExchangeCardIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeCardIds", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowShop
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ExchangeSkinIds = append(m.ExchangeSkinIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowShop
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthShop
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowShop
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ExchangeSkinIds = append(m.ExchangeSkinIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ExchangeSkinIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuySoldGoldGiftReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuySoldGoldGiftReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuySoldGoldGiftReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasureReward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TreasureReward == nil {
				m.TreasureReward = &OpenTreasureReply{}
			}
			if err := m.TreasureReward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextGift", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NextGift == nil {
				m.NextGift = &SoldGoldGift{}
			}
			if err := m.NextGift.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MidasRechargeArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MidasRechargeArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MidasRechargeArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MidasOpenkey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MidasOpenkey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pf", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pf = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pfkey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pfkey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuyRecommendGiftReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowShop
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuyRecommendGiftReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuyRecommendGiftReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasureReward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowShop
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthShop
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TreasureReward == nil {
				m.TreasureReward = &OpenTreasureReply{}
			}
			if err := m.TreasureReward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipShop(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthShop
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipShop(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowShop
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowShop
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowShop
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthShop
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowShop
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipShop(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthShop = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowShop   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("shop.proto", fileDescriptorShop) }

var fileDescriptorShop = []byte{
	// 1812 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0x5f, 0x6f, 0x1c, 0x49,
	0x11, 0xbf, 0xd9, 0x3f, 0xde, 0xdd, 0xb2, 0xbd, 0x1e, 0xb7, 0x13, 0x6e, 0x65, 0x45, 0xc6, 0xd7,
	0x3a, 0x4e, 0xbe, 0x93, 0x59, 0x90, 0x03, 0x77, 0x47, 0x10, 0xc7, 0x79, 0x6d, 0x27, 0x38, 0x8a,
	0x93, 0x55, 0x3b, 0xc9, 0x13, 0x12, 0x9a, 0xec, 0xb4, 0xed, 0x91, 0x77, 0x67, 0x56, 0xf3, 0x27,
	0xf6, 0xf0, 0x86, 0x10, 0xe2, 0x85, 0x57, 0x24, 0x1e, 0x90, 0x78, 0xe4, 0x8d, 0xef, 0x80, 0x78,
	0xe1, 0x91, 0x8f, 0x80, 0x92, 0x27, 0xbe, 0x05, 0xaa, 0xee, 0x9e, 0x9e, 0x9e, 0x99, 0xfd, 0xe3,
	0x93, 0xf2, 0xb4, 0x53, 0xd5, 0xd5, 0x55, 0xd5, 0x55, 0xd5, 0xbf, 0xaa, 0x5e, 0x80, 0xe8, 0x2a,
	0x98, 0xf6, 0xa7, 0x61, 0x10, 0x07, 0xa4, 0x36, 0x7d, 0xb3, 0xdd, 0x8d, 0x43, 0xee, 0x44, 0x49,
	0xc8, 0x25, 0x6f, 0x7b, 0xcb, 0x71, 0xdf, 0xf2, 0x30, 0xf6, 0x22, 0x3e, 0xe1, 0x7e, 0x2c, 0x99,
	0xf4, 0x2b, 0x20, 0xaf, 0xa6, 0xae, 0x13, 0xf3, 0x67, 0xde, 0xc4, 0x8b, 0x9f, 0x78, 0x17, 0xf1,
	0x61, 0x78, 0x49, 0x3e, 0x81, 0x06, 0x7e, 0xf6, 0xac, 0xdd, 0xfa, 0xde, 0xea, 0xc1, 0x7a, 0x7f,
	0xfa, 0xa6, 0xaf, 0xd7, 0x99, 0x58, 0xa2, 0xa7, 0xd9, 0xc6, 0xa7, 0x8e, 0xcb, 0x9f, 0x04, 0x81,
	0x1b, 0xe1, 0xc6, 0x87, 0xb0, 0xae, 0xe9, 0x67, 0x5e, 0x54, 0xd0, 0xa0, 0x17, 0x58, 0x51, 0x86,
	0xde, 0x64, 0xaa, 0x9e, 0x04, 0x63, 0xd7, 0x54, 0xa5, 0xe9, 0xb2, 0x2a, 0xbd, 0xc0, 0x8a, 0x32,
	0x64, 0x1f, 0x36, 0x07, 0x49, 0x8a, 0x3c, 0xc6, 0x27, 0x8e, 0xe7, 0xbf, 0xf4, 0x26, 0xbc, 0x57,
	0xdb, 0xb5, 0xf6, 0x9a, 0xac, 0xba, 0x40, 0x7f, 0x06, 0xb6, 0x34, 0xfc, 0x38, 0xe4, 0xfc, 0x50,
	0x9a, 0xfd, 0x01, 0x34, 0x0f, 0xdd, 0x88, 0x47, 0xca, 0xdc, 0x06, 0x9a, 0x3b, 0xbf, 0x0a, 0xa6,
	0x4a, 0x84, 0xc9, 0x55, 0xfa, 0x87, 0x1a, 0x6c, 0xca, 0xbd, 0xb8, 0x78, 0xec, 0xc4, 0x0e, 0x6e,
	0x3e, 0x80, 0xc6, 0xcb, 0x74, 0xca, 0x7b, 0xd6, 0xae, 0xb5, 0xd7, 0x3d, 0xd8, 0xc1, 0xbd, 0x15,
	0xa1, 0x3e, 0xfe, 0xa2, 0x14, 0x13, 0xb2, 0x84, 0x40, 0x03, 0x39, 0xc2, 0xcb, 0x35, 0x26, 0xbe,
	0xe9, 0xdf, 0x2d, 0x68, 0x67, 0x62, 0x04, 0x60, 0xe5, 0x95, 0x7f, 0xed, 0x07, 0x37, 0xf6, 0x47,
	0x64, 0x1d, 0x3a, 0x3a, 0x11, 0xb6, 0x45, 0x6c, 0x58, 0x3b, 0x0f, 0xc6, 0xee, 0x4b, 0x95, 0x68,
	0xbb, 0x46, 0xb6, 0x60, 0x83, 0xf1, 0x51, 0x98, 0x78, 0xb1, 0x66, 0xd6, 0x49, 0x1b, 0x1a, 0x18,
	0x71, 0xbb, 0x81, 0x5f, 0x18, 0x03, 0xbb, 0x49, 0x56, 0xa1, 0xa5, 0x8e, 0x64, 0xaf, 0x90, 0x16,
	0xd4, 0x5f, 0x7b, 0x53, 0xbb, 0x45, 0xba, 0x00, 0xcc, 0xf1, 0xdd, 0x60, 0x82, 0x0e, 0xdb, 0x6d,
	0xb2, 0x06, 0x6d, 0x11, 0x60, 0x34, 0xd7, 0x21, 0x9b, 0xb0, 0xce, 0xf8, 0x28, 0x98, 0x4c, 0xb8,
	0x2f, 0x59, 0x40, 0x03, 0xc3, 0x21, 0xf2, 0x3d, 0x58, 0xc1, 0xdf, 0xd3, 0x63, 0x11, 0x80, 0x0e,
	0x53, 0x14, 0xd9, 0x01, 0xa8, 0xa4, 0xc3, 0xe0, 0x90, 0x7b, 0xd0, 0x1c, 0x86, 0xde, 0x88, 0xf7,
	0xea, 0x62, 0x49, 0x12, 0xc8, 0x3d, 0x8d, 0x9e, 0xf3, 0x9b, 0x5e, 0x63, 0xd7, 0xda, 0x6b, 0x33,
	0x49, 0xd0, 0x6b, 0xe8, 0xe8, 0xea, 0x21, 0x3d, 0x68, 0x89, 0x0f, 0x6d, 0x31, 0x23, 0x73, 0x95,
	0x35, 0x53, 0x25, 0x91, 0x81, 0x50, 0x76, 0xc4, 0x37, 0xd9, 0x86, 0xb6, 0x17, 0x1d, 0x07, 0xc9,
	0x9b, 0x31, 0x57, 0x96, 0x34, 0x4d, 0x7f, 0x5b, 0x8c, 0x2f, 0xd9, 0x83, 0x8d, 0xec, 0xfb, 0x2c,
	0x70, 0xf9, 0x58, 0xdb, 0x2d, 0xb3, 0x51, 0xeb, 0x73, 0xce, 0x5d, 0x61, 0x4d, 0xba, 0xa0, 0x69,
	0xf2, 0x29, 0xac, 0x3f, 0xe7, 0xb7, 0x46, 0x44, 0xa4, 0x3b, 0x45, 0x26, 0x7d, 0x0a, 0xb6, 0x69,
	0x1b, 0xcb, 0x81, 0x7c, 0x09, 0xeb, 0x26, 0x2f, 0x2b, 0x52, 0x5b, 0x14, 0xa9, 0xb1, 0xc0, 0x8a,
	0x62, 0xf4, 0x4f, 0x96, 0x99, 0xd7, 0x3c, 0x6c, 0x6e, 0x31, 0x6c, 0x2e, 0x66, 0xf0, 0x70, 0x12,
	0x24, 0x7e, 0xac, 0x9c, 0x56, 0x54, 0xe1, 0x38, 0xf5, 0xd2, 0x71, 0x44, 0x9e, 0x06, 0x49, 0x9a,
	0xe7, 0x69, 0x90, 0xa4, 0xd9, 0x0e, 0xac, 0x9e, 0x5e, 0x33, 0xdf, 0x81, 0x34, 0xfd, 0x5d, 0x1d,
	0xb6, 0x4a, 0x55, 0x2a, 0x8e, 0xf7, 0x61, 0xc2, 0xbb, 0x0d, 0xed, 0x41, 0x92, 0x62, 0x0c, 0xa3,
	0xcc, 0xd7, 0x8c, 0xae, 0x86, 0xbe, 0x31, 0x23, 0xf4, 0xa8, 0xe1, 0xd8, 0x8b, 0x46, 0x22, 0x0e,
	0xca, 0xf7, 0x8c, 0x26, 0xbb, 0xb0, 0x7a, 0xe6, 0xdc, 0x6a, 0x03, 0x2b, 0x62, 0xd9, 0x64, 0x11,
	0x1b, 0xea, 0xa1, 0xe7, 0xf6, 0x5a, 0xbb, 0xf5, 0xbd, 0x26, 0xc3, 0x4f, 0xf2, 0x08, 0x56, 0xd8,
	0x8d, 0x00, 0x86, 0xb6, 0x00, 0x06, 0x8a, 0xf9, 0x9a, 0x11, 0x80, 0x3e, 0xe3, 0x37, 0x4e, 0xe8,
	0x0a, 0x70, 0x50, 0x3b, 0x30, 0x26, 0xcf, 0xf9, 0x6d, 0xcc, 0xf8, 0x45, 0xc8, 0xa3, 0x2b, 0xe1,
	0x73, 0x67, 0xd7, 0xda, 0xab, 0xb3, 0x32, 0x9b, 0xee, 0xe3, 0x2d, 0xcb, 0xf6, 0x17, 0x50, 0xa3,
	0x0d, 0x8d, 0x23, 0x27, 0x74, 0x6d, 0x0b, 0xbf, 0xce, 0xaf, 0x3d, 0xdf, 0xae, 0xd1, 0xf7, 0x16,
	0x6c, 0xbd, 0xf6, 0x22, 0x2f, 0xce, 0xeb, 0x42, 0xe4, 0xe0, 0xc7, 0xb0, 0x9a, 0x73, 0xb2, 0x02,
	0xeb, 0x0a, 0x87, 0x35, 0x9b, 0x99, 0x22, 0xd5, 0x98, 0xd6, 0xe6, 0xc4, 0x74, 0x6e, 0x56, 0xcc,
	0x78, 0x37, 0x16, 0xc7, 0xbb, 0x59, 0x8d, 0xb7, 0x59, 0x0b, 0x2b, 0xc5, 0x5a, 0xa0, 0xaf, 0xa0,
	0xa3, 0x1b, 0xc4, 0x02, 0xb4, 0x20, 0x12, 0x16, 0x95, 0xe7, 0xe2, 0x7b, 0x51, 0xc9, 0xd3, 0x5b,
	0x89, 0x0b, 0x19, 0x34, 0x22, 0xc0, 0x65, 0x79, 0xd4, 0xca, 0x0d, 0x0e, 0x79, 0x20, 0x41, 0xcb,
	0x44, 0xa4, 0x9c, 0x41, 0xbe, 0x00, 0xfb, 0xc8, 0xf1, 0x07, 0x49, 0x5a, 0x81, 0x84, 0x0a, 0x9f,
	0xfe, 0xcf, 0x82, 0xcd, 0x73, 0xd1, 0xc5, 0x0c, 0x1c, 0x9e, 0x0b, 0xbc, 0x8b, 0xed, 0x7e, 0x09,
	0xcd, 0x91, 0x13, 0xba, 0x98, 0x0f, 0x4c, 0xf2, 0x6e, 0x86, 0x22, 0x05, 0xdd, 0x7d, 0xac, 0x9c,
	0xe8, 0xc4, 0x8f, 0xc3, 0x94, 0x49, 0x71, 0x6c, 0xb2, 0xaa, 0xee, 0x2a, 0x17, 0xa9, 0xba, 0xb0,
	0xfd, 0x35, 0x40, 0xae, 0x02, 0x2f, 0xc7, 0x35, 0x4f, 0x85, 0x9b, 0xeb, 0x0c, 0x3f, 0x11, 0x3e,
	0xde, 0x3a, 0xe3, 0x44, 0x23, 0xb5, 0x20, 0x1e, 0xd5, 0xbe, 0xb6, 0xe8, 0xbf, 0x1a, 0xd0, 0xd6,
	0x75, 0xb9, 0x7c, 0x24, 0x21, 0x8f, 0xca, 0xe8, 0x88, 0x1a, 0x57, 0x0f, 0xee, 0x95, 0xd1, 0x11,
	0xf5, 0x95, 0x10, 0x92, 0x1c, 0x56, 0xfa, 0xa6, 0x48, 0xc1, 0xea, 0xc1, 0xc7, 0x73, 0xee, 0x2a,
	0x2b, 0xcb, 0x57, 0x67, 0x9f, 0xc6, 0xf2, 0xd9, 0xa7, 0x3a, 0xe5, 0x34, 0xef, 0x30, 0xe5, 0xe8,
	0x19, 0x65, 0x65, 0xd1, 0x8c, 0x32, 0x7b, 0x18, 0x6a, 0xcd, 0x19, 0x86, 0xc8, 0x17, 0xd0, 0x7a,
	0xed, 0x4d, 0x31, 0x55, 0x02, 0xa5, 0x54, 0x57, 0x51, 0x2c, 0xe9, 0x46, 0x26, 0x40, 0x7e, 0x09,
	0xdd, 0x22, 0x6c, 0x08, 0x4c, 0x52, 0xc1, 0x9a, 0x81, 0x2a, 0xac, 0x24, 0x4e, 0xf6, 0xf3, 0xb9,
	0xa2, 0x07, 0xb9, 0x35, 0xf3, 0x52, 0x31, 0x2d, 0x41, 0x7e, 0x5e, 0x9a, 0x3b, 0x7a, 0xab, 0x62,
	0xcb, 0xfd, 0x99, 0x05, 0xcb, 0x8a, 0xb2, 0xf4, 0xd7, 0xb0, 0x66, 0x1e, 0x62, 0x01, 0x0a, 0x2c,
	0xbe, 0x2d, 0x33, 0x87, 0x14, 0x7a, 0x0c, 0x36, 0x5e, 0x50, 0x7d, 0x3a, 0x9c, 0x02, 0xe7, 0x5b,
	0x98, 0xd3, 0x5e, 0xe9, 0xb7, 0x00, 0x83, 0x24, 0x45, 0x5b, 0x8b, 0xf7, 0xf7, 0xa0, 0xc5, 0xf8,
	0x88, 0x7b, 0x53, 0xa9, 0xa0, 0xc3, 0x32, 0x92, 0x0e, 0x60, 0x4d, 0x69, 0x60, 0x7c, 0x3a, 0x4e,
	0xf5, 0xa4, 0x63, 0x19, 0x93, 0xce, 0x4e, 0xd6, 0x20, 0x8c, 0xb6, 0x69, 0x70, 0xe8, 0x11, 0x6c,
	0x0c, 0x92, 0xb4, 0xf0, 0x10, 0x98, 0x07, 0x2c, 0xf3, 0x1d, 0x39, 0x83, 0x2d, 0x94, 0x19, 0x86,
	0xde, 0x5b, 0x6f, 0xcc, 0x2f, 0xb9, 0xd4, 0x8f, 0x8a, 0x90, 0xa5, 0x14, 0x35, 0x99, 0xa2, 0x96,
	0x8d, 0x86, 0xf4, 0x1f, 0x96, 0x28, 0xe2, 0xfc, 0xaa, 0x8b, 0xd3, 0xfd, 0x14, 0x40, 0x12, 0xa8,
	0x5b, 0x68, 0x54, 0xd5, 0xf0, 0x62, 0xca, 0x7d, 0x3d, 0x04, 0xa1, 0x28, 0x33, 0x04, 0xc9, 0x57,
	0x00, 0xda, 0x2f, 0x44, 0x87, 0x7a, 0x56, 0xb2, 0x33, 0x3c, 0x66, 0x86, 0x28, 0xf9, 0x1c, 0x7b,
	0xc1, 0xad, 0x70, 0x40, 0xc1, 0x42, 0x09, 0x80, 0xf4, 0x32, 0xfd, 0x06, 0xc8, 0x20, 0x49, 0x4d,
	0x70, 0xc1, 0x38, 0xde, 0x79, 0xb2, 0xa1, 0x7f, 0xb6, 0xe0, 0x5e, 0x49, 0x81, 0x3c, 0xf3, 0x2f,
	0xa0, 0x9b, 0x33, 0x96, 0x9f, 0xbb, 0x24, 0x4c, 0xbe, 0xc1, 0x39, 0xe2, 0xc6, 0x54, 0xbb, 0x10,
	0x1e, 0xcb, 0xc2, 0xf4, 0x33, 0x51, 0xa2, 0x78, 0x25, 0x17, 0x96, 0x28, 0x7d, 0x2a, 0x0a, 0x51,
	0x62, 0x8b, 0x2a, 0x44, 0xd1, 0x5a, 0x2d, 0xa3, 0xb5, 0x7e, 0x06, 0x5d, 0x39, 0xbc, 0x94, 0x12,
	0x5f, 0xe2, 0xd2, 0x1f, 0xc2, 0xe6, 0xb9, 0x7b, 0x7d, 0x14, 0x72, 0x27, 0xe6, 0x2f, 0x42, 0x97,
	0x87, 0x8b, 0x4d, 0xff, 0x08, 0xb6, 0x8a, 0xe2, 0xd2, 0x83, 0x1e, 0xb4, 0x04, 0x95, 0x6f, 0x50,
	0x24, 0x9d, 0xc0, 0x3d, 0xc6, 0x47, 0x57, 0x4e, 0x78, 0xc9, 0x9f, 0x05, 0x71, 0xcc, 0xc3, 0x54,
	0xee, 0x78, 0x00, 0x1d, 0x19, 0xb5, 0x53, 0xf7, 0x56, 0x39, 0x9e, 0x33, 0x2a, 0x55, 0x64, 0xdd,
	0xb1, 0x8a, 0xe8, 0x1f, 0x6b, 0xe2, 0x3c, 0x99, 0x49, 0xc6, 0xa3, 0x64, 0x8c, 0xe0, 0xd6, 0x3a,
	0x09, 0xc3, 0x51, 0xe0, 0x66, 0xcf, 0xc6, 0x4f, 0x44, 0x42, 0xca, 0x72, 0xfd, 0x8c, 0x3c, 0x09,
	0x43, 0x96, 0xed, 0x20, 0x0f, 0xd5, 0x83, 0xb3, 0x26, 0x76, 0x7e, 0x7f, 0xf6, 0x4e, 0x11, 0x9f,
	0x19, 0x2f, 0xce, 0xba, 0xf1, 0xe2, 0xfc, 0x14, 0x56, 0x0d, 0x03, 0xf8, 0x3a, 0x3c, 0x4f, 0x46,
	0x23, 0x1e, 0x45, 0x72, 0x7c, 0x7c, 0xec, 0x78, 0x63, 0xdb, 0xa2, 0x8f, 0x71, 0x9c, 0x52, 0xca,
	0x16, 0xbd, 0x4b, 0xb3, 0x07, 0x67, 0x2d, 0x7b, 0x59, 0xd6, 0x51, 0xa3, 0x8a, 0xb1, 0xdd, 0xa0,
	0x7b, 0xb0, 0x76, 0x1a, 0x44, 0xc3, 0x90, 0x0f, 0x9d, 0x74, 0x59, 0x4e, 0xef, 0x9b, 0xd7, 0x7f,
	0xa0, 0x41, 0x72, 0x0e, 0x32, 0xd1, 0x7f, 0x5a, 0x70, 0xff, 0x49, 0x10, 0x5c, 0x8e, 0xf9, 0x70,
	0xec, 0xa4, 0xd9, 0x99, 0x16, 0xc3, 0xea, 0x3e, 0x6c, 0x9e, 0xfa, 0xce, 0x74, 0x3a, 0x4c, 0xc2,
	0xd1, 0x95, 0x13, 0x71, 0xfd, 0x1e, 0xef, 0xb0, 0xea, 0x02, 0xe9, 0x03, 0x11, 0x4c, 0x24, 0xce,
	0xbd, 0x4b, 0xdf, 0x89, 0xb3, 0x69, 0xa1, 0xc3, 0x66, 0xac, 0x60, 0xe3, 0x38, 0x0b, 0x7c, 0x9e,
	0xaa, 0x11, 0x49, 0x12, 0x38, 0x5e, 0x1e, 0x25, 0x61, 0xc8, 0xfd, 0x51, 0x2a, 0x86, 0xda, 0x0e,
	0xd3, 0x34, 0x7d, 0x21, 0x80, 0x58, 0x75, 0x2d, 0x5d, 0x92, 0xbf, 0xe2, 0x8e, 0xfb, 0x38, 0x74,
	0x26, 0x5c, 0xb9, 0x9f, 0x33, 0x96, 0xa2, 0xe8, 0xdf, 0x2c, 0xb0, 0x87, 0x1e, 0x1f, 0xf1, 0x93,
	0xdb, 0xd1, 0x95, 0xe3, 0xcb, 0x78, 0x7c, 0x0b, 0x1d, 0xc1, 0x33, 0xfe, 0xb1, 0x10, 0x0f, 0x93,
	0xb2, 0x60, 0x5f, 0x4b, 0x9d, 0xf8, 0xc9, 0x84, 0xe5, 0x9b, 0xcc, 0x88, 0x4a, 0x9b, 0x46, 0xda,
	0xd6, 0x0b, 0xbb, 0x96, 0x3e, 0x47, 0x3e, 0x87, 0x8d, 0x97, 0x98, 0xa8, 0x78, 0xe9, 0xbf, 0x09,
	0xf4, 0x18, 0xba, 0xa7, 0x41, 0x74, 0xb7, 0xcc, 0xce, 0xef, 0x53, 0xb2, 0xb0, 0x4a, 0x33, 0x9c,
	0x2a, 0xac, 0x41, 0x92, 0x1e, 0xf9, 0x71, 0xd6, 0xa9, 0x24, 0x45, 0xff, 0x6a, 0xc1, 0xc7, 0xd5,
	0x1d, 0x1f, 0x04, 0x9b, 0xef, 0x88, 0x87, 0x85, 0x77, 0x52, 0xbd, 0xf8, 0x4e, 0xa2, 0x3f, 0x81,
	0xed, 0xc2, 0x20, 0xa2, 0x06, 0xf1, 0x23, 0x3f, 0x5e, 0x74, 0xa8, 0xdf, 0xc0, 0x83, 0x39, 0xbb,
	0xe4, 0xc1, 0xaa, 0x83, 0x9e, 0xf5, 0x9d, 0x06, 0x3d, 0x7a, 0x51, 0x2a, 0xbc, 0x53, 0x37, 0xc2,
	0x66, 0x98, 0x91, 0x47, 0x02, 0x53, 0xe5, 0x33, 0xb3, 0xc9, 0xca, 0x6c, 0x53, 0x12, 0xeb, 0x04,
	0x25, 0x6b, 0x45, 0x49, 0xc5, 0xa6, 0xbf, 0xcf, 0xdb, 0xa6, 0x1e, 0x20, 0x3f, 0x44, 0x6a, 0xf6,
	0x8d, 0xce, 0x5f, 0x9b, 0x37, 0xa8, 0xea, 0xe6, 0xff, 0x16, 0xec, 0x33, 0xcf, 0x75, 0xca, 0xc5,
	0x39, 0xbb, 0xfd, 0x10, 0x0a, 0x6b, 0x42, 0x1a, 0xbd, 0xc0, 0x47, 0x91, 0xac, 0xd0, 0x02, 0x8f,
	0x74, 0xa1, 0x36, 0xbc, 0x50, 0xe0, 0x52, 0x1b, 0x5e, 0x88, 0x29, 0xf4, 0xe2, 0x5a, 0x81, 0x49,
	0x87, 0x49, 0x82, 0xbe, 0xce, 0x8a, 0xd9, 0x18, 0x83, 0x3f, 0xc0, 0xe9, 0x07, 0xf6, 0xbf, 0xdf,
	0xed, 0x58, 0xff, 0x79, 0xb7, 0x63, 0xfd, 0xf7, 0xdd, 0x8e, 0xf5, 0x97, 0xf7, 0x3b, 0x1f, 0xbd,
	0x59, 0x11, 0x7f, 0x1b, 0x3f, 0xfc, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x22, 0x9b, 0x39, 0x1d,
	0x6d, 0x16, 0x00, 0x00,
}
