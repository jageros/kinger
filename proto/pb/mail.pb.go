// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: mail.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type MailRewardType int32

const (
	MailRewardType_MrtGold         MailRewardType = 0
	MailRewardType_MrtJade         MailRewardType = 1
	MailRewardType_MrtCard         MailRewardType = 2
	MailRewardType_MrtTreasure     MailRewardType = 3
	MailRewardType_MrtCardSkin     MailRewardType = 4
	MailRewardType_MrtHeadFrame    MailRewardType = 5
	MailRewardType_MrtFeats        MailRewardType = 6
	MailRewardType_MrtPrestige     MailRewardType = 7
	MailRewardType_MrtEquip        MailRewardType = 8
	MailRewardType_MrtEmoji        MailRewardType = 9
	MailRewardType_MrtContribution MailRewardType = 10
	MailRewardType_MrtBowlder      MailRewardType = 11
	MailRewardType_MrtReputation   MailRewardType = 12
	MailRewardType_MrtCardPiece    MailRewardType = 13
	MailRewardType_MrtSkinPiece    MailRewardType = 14
	MailRewardType_MrtAccTicket    MailRewardType = 15
)

var MailRewardType_name = map[int32]string{
	0:  "MrtGold",
	1:  "MrtJade",
	2:  "MrtCard",
	3:  "MrtTreasure",
	4:  "MrtCardSkin",
	5:  "MrtHeadFrame",
	6:  "MrtFeats",
	7:  "MrtPrestige",
	8:  "MrtEquip",
	9:  "MrtEmoji",
	10: "MrtContribution",
	11: "MrtBowlder",
	12: "MrtReputation",
	13: "MrtCardPiece",
	14: "MrtSkinPiece",
	15: "MrtAccTicket",
}
var MailRewardType_value = map[string]int32{
	"MrtGold":         0,
	"MrtJade":         1,
	"MrtCard":         2,
	"MrtTreasure":     3,
	"MrtCardSkin":     4,
	"MrtHeadFrame":    5,
	"MrtFeats":        6,
	"MrtPrestige":     7,
	"MrtEquip":        8,
	"MrtEmoji":        9,
	"MrtContribution": 10,
	"MrtBowlder":      11,
	"MrtReputation":   12,
	"MrtCardPiece":    13,
	"MrtSkinPiece":    14,
	"MrtAccTicket":    15,
}

func (x MailRewardType) String() string {
	return proto.EnumName(MailRewardType_name, int32(x))
}
func (MailRewardType) EnumDescriptor() ([]byte, []int) { return fileDescriptorMail, []int{0} }

type MailTypeEnum int32

const (
	MailTypeEnum_CUSTOM            MailTypeEnum = 0
	MailTypeEnum_SeasonPvpBegin    MailTypeEnum = 1
	MailTypeEnum_SeasonPvpEnd      MailTypeEnum = 2
	MailTypeEnum_FbAdvert          MailTypeEnum = 3
	MailTypeEnum_KingReward        MailTypeEnum = 4
	MailTypeEnum_ChristmasReward   MailTypeEnum = 5
	MailTypeEnum_YuandanReward     MailTypeEnum = 6
	MailTypeEnum_CampaignUnified   MailTypeEnum = 7
	MailTypeEnum_SpringRecharge    MailTypeEnum = 8
	MailTypeEnum_RankHonorReward   MailTypeEnum = 9
	MailTypeEnum_BackPrivReimburse MailTypeEnum = 10
	MailTypeEnum_LeagueStart       MailTypeEnum = 11
	MailTypeEnum_LeagueEnd         MailTypeEnum = 12
)

var MailTypeEnum_name = map[int32]string{
	0:  "CUSTOM",
	1:  "SeasonPvpBegin",
	2:  "SeasonPvpEnd",
	3:  "FbAdvert",
	4:  "KingReward",
	5:  "ChristmasReward",
	6:  "YuandanReward",
	7:  "CampaignUnified",
	8:  "SpringRecharge",
	9:  "RankHonorReward",
	10: "BackPrivReimburse",
	11: "LeagueStart",
	12: "LeagueEnd",
}
var MailTypeEnum_value = map[string]int32{
	"CUSTOM":            0,
	"SeasonPvpBegin":    1,
	"SeasonPvpEnd":      2,
	"FbAdvert":          3,
	"KingReward":        4,
	"ChristmasReward":   5,
	"YuandanReward":     6,
	"CampaignUnified":   7,
	"SpringRecharge":    8,
	"RankHonorReward":   9,
	"BackPrivReimburse": 10,
	"LeagueStart":       11,
	"LeagueEnd":         12,
}

func (x MailTypeEnum) String() string {
	return proto.EnumName(MailTypeEnum_name, int32(x))
}
func (MailTypeEnum) EnumDescriptor() ([]byte, []int) { return fileDescriptorMail, []int{1} }

type FetchMailListArg struct {
	MinMailID int32 `protobuf:"varint,1,opt,name=MinMailID,proto3" json:"MinMailID,omitempty"`
}

func (m *FetchMailListArg) Reset()                    { *m = FetchMailListArg{} }
func (m *FetchMailListArg) String() string            { return proto.CompactTextString(m) }
func (*FetchMailListArg) ProtoMessage()               {}
func (*FetchMailListArg) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{0} }

func (m *FetchMailListArg) GetMinMailID() int32 {
	if m != nil {
		return m.MinMailID
	}
	return 0
}

type MailReward struct {
	Type   MailRewardType `protobuf:"varint,1,opt,name=Type,proto3,enum=pb.MailRewardType" json:"Type,omitempty"`
	Amount int32          `protobuf:"varint,2,opt,name=Amount,proto3" json:"Amount,omitempty"`
	CardID uint32         `protobuf:"varint,3,opt,name=CardID,proto3" json:"CardID,omitempty"`
	// Type==Treasure, ItemID=Treasure表里的ID; Type==CardSkin, ItemID=SkinID; Type==HeadFrame, ItemID=HeadFrameID
	// Type==Equip, ItemID=EquipID
	ItemID    string `protobuf:"bytes,4,opt,name=ItemID,proto3" json:"ItemID,omitempty"`
	EmojiTeam int32  `protobuf:"varint,5,opt,name=EmojiTeam,proto3" json:"EmojiTeam,omitempty"`
}

func (m *MailReward) Reset()                    { *m = MailReward{} }
func (m *MailReward) String() string            { return proto.CompactTextString(m) }
func (*MailReward) ProtoMessage()               {}
func (*MailReward) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{1} }

func (m *MailReward) GetType() MailRewardType {
	if m != nil {
		return m.Type
	}
	return MailRewardType_MrtGold
}

func (m *MailReward) GetAmount() int32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *MailReward) GetCardID() uint32 {
	if m != nil {
		return m.CardID
	}
	return 0
}

func (m *MailReward) GetItemID() string {
	if m != nil {
		return m.ItemID
	}
	return ""
}

func (m *MailReward) GetEmojiTeam() int32 {
	if m != nil {
		return m.EmojiTeam
	}
	return 0
}

type MailSeasonPvpBeginArg struct {
	PvpLevel int32 `protobuf:"varint,1,opt,name=PvpLevel,proto3" json:"PvpLevel,omitempty"`
}

func (m *MailSeasonPvpBeginArg) Reset()                    { *m = MailSeasonPvpBeginArg{} }
func (m *MailSeasonPvpBeginArg) String() string            { return proto.CompactTextString(m) }
func (*MailSeasonPvpBeginArg) ProtoMessage()               {}
func (*MailSeasonPvpBeginArg) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{2} }

func (m *MailSeasonPvpBeginArg) GetPvpLevel() int32 {
	if m != nil {
		return m.PvpLevel
	}
	return 0
}

type MailSeasonPvpEndArg struct {
	WinDiff int32 `protobuf:"varint,1,opt,name=WinDiff,proto3" json:"WinDiff,omitempty"`
}

func (m *MailSeasonPvpEndArg) Reset()                    { *m = MailSeasonPvpEndArg{} }
func (m *MailSeasonPvpEndArg) String() string            { return proto.CompactTextString(m) }
func (*MailSeasonPvpEndArg) ProtoMessage()               {}
func (*MailSeasonPvpEndArg) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{3} }

func (m *MailSeasonPvpEndArg) GetWinDiff() int32 {
	if m != nil {
		return m.WinDiff
	}
	return 0
}

type MailRankHonorRewardArg struct {
	Rank  int32 `protobuf:"varint,1,opt,name=Rank,proto3" json:"Rank,omitempty"`
	Honor int32 `protobuf:"varint,2,opt,name=Honor,proto3" json:"Honor,omitempty"`
}

func (m *MailRankHonorRewardArg) Reset()                    { *m = MailRankHonorRewardArg{} }
func (m *MailRankHonorRewardArg) String() string            { return proto.CompactTextString(m) }
func (*MailRankHonorRewardArg) ProtoMessage()               {}
func (*MailRankHonorRewardArg) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{4} }

func (m *MailRankHonorRewardArg) GetRank() int32 {
	if m != nil {
		return m.Rank
	}
	return 0
}

func (m *MailRankHonorRewardArg) GetHonor() int32 {
	if m != nil {
		return m.Honor
	}
	return 0
}

type MailCampaignUnifiedArg struct {
	YourMajestyName string `protobuf:"bytes,1,opt,name=YourMajestyName,proto3" json:"YourMajestyName,omitempty"`
	CountryName     string `protobuf:"bytes,2,opt,name=CountryName,proto3" json:"CountryName,omitempty"`
}

func (m *MailCampaignUnifiedArg) Reset()                    { *m = MailCampaignUnifiedArg{} }
func (m *MailCampaignUnifiedArg) String() string            { return proto.CompactTextString(m) }
func (*MailCampaignUnifiedArg) ProtoMessage()               {}
func (*MailCampaignUnifiedArg) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{5} }

func (m *MailCampaignUnifiedArg) GetYourMajestyName() string {
	if m != nil {
		return m.YourMajestyName
	}
	return ""
}

func (m *MailCampaignUnifiedArg) GetCountryName() string {
	if m != nil {
		return m.CountryName
	}
	return ""
}

// switch MailType {
// default:
//   Arg = nil
// case SeasonPvpEnd:
//   Arg = MailSeasonPvpEndArg
// case CampaignUnified:
//   Arg = MailCampaignUnifiedArg
// case RankHonorReward:
//   Arg = MailRankHonorRewardArg
// }
type Mail struct {
	ID         int32         `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Title      string        `protobuf:"bytes,2,opt,name=Title,proto3" json:"Title,omitempty"`
	Content    string        `protobuf:"bytes,3,opt,name=Content,proto3" json:"Content,omitempty"`
	Time       int32         `protobuf:"varint,4,opt,name=Time,proto3" json:"Time,omitempty"`
	IsReward   bool          `protobuf:"varint,6,opt,name=IsReward,proto3" json:"IsReward,omitempty"`
	SenderName string        `protobuf:"bytes,7,opt,name=SenderName,proto3" json:"SenderName,omitempty"`
	Rewards    []*MailReward `protobuf:"bytes,8,rep,name=Rewards" json:"Rewards,omitempty"`
	IsRead     bool          `protobuf:"varint,9,opt,name=IsRead,proto3" json:"IsRead,omitempty"`
	MailType   MailTypeEnum  `protobuf:"varint,10,opt,name=MailType,proto3,enum=pb.MailTypeEnum" json:"MailType,omitempty"`
	Arg        []byte        `protobuf:"bytes,11,opt,name=Arg,proto3" json:"Arg,omitempty"`
}

func (m *Mail) Reset()                    { *m = Mail{} }
func (m *Mail) String() string            { return proto.CompactTextString(m) }
func (*Mail) ProtoMessage()               {}
func (*Mail) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{6} }

func (m *Mail) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Mail) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Mail) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *Mail) GetTime() int32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *Mail) GetIsReward() bool {
	if m != nil {
		return m.IsReward
	}
	return false
}

func (m *Mail) GetSenderName() string {
	if m != nil {
		return m.SenderName
	}
	return ""
}

func (m *Mail) GetRewards() []*MailReward {
	if m != nil {
		return m.Rewards
	}
	return nil
}

func (m *Mail) GetIsRead() bool {
	if m != nil {
		return m.IsRead
	}
	return false
}

func (m *Mail) GetMailType() MailTypeEnum {
	if m != nil {
		return m.MailType
	}
	return MailTypeEnum_CUSTOM
}

func (m *Mail) GetArg() []byte {
	if m != nil {
		return m.Arg
	}
	return nil
}

type MailList struct {
	Mails   []*Mail `protobuf:"bytes,1,rep,name=Mails" json:"Mails,omitempty"`
	HasMore bool    `protobuf:"varint,2,opt,name=HasMore,proto3" json:"HasMore,omitempty"`
}

func (m *MailList) Reset()                    { *m = MailList{} }
func (m *MailList) String() string            { return proto.CompactTextString(m) }
func (*MailList) ProtoMessage()               {}
func (*MailList) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{7} }

func (m *MailList) GetMails() []*Mail {
	if m != nil {
		return m.Mails
	}
	return nil
}

func (m *MailList) GetHasMore() bool {
	if m != nil {
		return m.HasMore
	}
	return false
}

type GetMailRewardArg struct {
	ID int32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
}

func (m *GetMailRewardArg) Reset()                    { *m = GetMailRewardArg{} }
func (m *GetMailRewardArg) String() string            { return proto.CompactTextString(m) }
func (*GetMailRewardArg) ProtoMessage()               {}
func (*GetMailRewardArg) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{8} }

func (m *GetMailRewardArg) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

type ReadMailArg struct {
	ID int32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
}

func (m *ReadMailArg) Reset()                    { *m = ReadMailArg{} }
func (m *ReadMailArg) String() string            { return proto.CompactTextString(m) }
func (*ReadMailArg) ProtoMessage()               {}
func (*ReadMailArg) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{9} }

func (m *ReadMailArg) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

type MailRewardCard struct {
	CardID uint32 `protobuf:"varint,1,opt,name=CardID,proto3" json:"CardID,omitempty"`
	Amount int32  `protobuf:"varint,2,opt,name=Amount,proto3" json:"Amount,omitempty"`
}

func (m *MailRewardCard) Reset()                    { *m = MailRewardCard{} }
func (m *MailRewardCard) String() string            { return proto.CompactTextString(m) }
func (*MailRewardCard) ProtoMessage()               {}
func (*MailRewardCard) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{10} }

func (m *MailRewardCard) GetCardID() uint32 {
	if m != nil {
		return m.CardID
	}
	return 0
}

func (m *MailRewardCard) GetAmount() int32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

// gold、jade、Feats、Prestige、Contribution、Bowlder
type MailRewardAmountArg struct {
	Type   MailRewardType `protobuf:"varint,1,opt,name=Type,proto3,enum=pb.MailRewardType" json:"Type,omitempty"`
	Amount int32          `protobuf:"varint,2,opt,name=Amount,proto3" json:"Amount,omitempty"`
}

func (m *MailRewardAmountArg) Reset()                    { *m = MailRewardAmountArg{} }
func (m *MailRewardAmountArg) String() string            { return proto.CompactTextString(m) }
func (*MailRewardAmountArg) ProtoMessage()               {}
func (*MailRewardAmountArg) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{11} }

func (m *MailRewardAmountArg) GetType() MailRewardType {
	if m != nil {
		return m.Type
	}
	return MailRewardType_MrtGold
}

func (m *MailRewardAmountArg) GetAmount() int32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

// CardSkins、HeadFrames、Equips
type MailRewardItemArg struct {
	Type   MailRewardType `protobuf:"varint,1,opt,name=Type,proto3,enum=pb.MailRewardType" json:"Type,omitempty"`
	ItemID string         `protobuf:"bytes,2,opt,name=ItemID,proto3" json:"ItemID,omitempty"`
}

func (m *MailRewardItemArg) Reset()                    { *m = MailRewardItemArg{} }
func (m *MailRewardItemArg) String() string            { return proto.CompactTextString(m) }
func (*MailRewardItemArg) ProtoMessage()               {}
func (*MailRewardItemArg) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{12} }

func (m *MailRewardItemArg) GetType() MailRewardType {
	if m != nil {
		return m.Type
	}
	return MailRewardType_MrtGold
}

func (m *MailRewardItemArg) GetItemID() string {
	if m != nil {
		return m.ItemID
	}
	return ""
}

type MailRewardReply struct {
	AmountRewards   []*MailRewardAmountArg `protobuf:"bytes,1,rep,name=AmountRewards" json:"AmountRewards,omitempty"`
	TreasureRewards []*OpenTreasureReply   `protobuf:"bytes,2,rep,name=TreasureRewards" json:"TreasureRewards,omitempty"`
	Cards           []*MailRewardCard      `protobuf:"bytes,3,rep,name=Cards" json:"Cards,omitempty"`
	ItemRewards     []*MailRewardItemArg   `protobuf:"bytes,4,rep,name=ItemRewards" json:"ItemRewards,omitempty"`
	EmojiTeams      []int32                `protobuf:"varint,5,rep,packed,name=EmojiTeams" json:"EmojiTeams,omitempty"`
}

func (m *MailRewardReply) Reset()                    { *m = MailRewardReply{} }
func (m *MailRewardReply) String() string            { return proto.CompactTextString(m) }
func (*MailRewardReply) ProtoMessage()               {}
func (*MailRewardReply) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{13} }

func (m *MailRewardReply) GetAmountRewards() []*MailRewardAmountArg {
	if m != nil {
		return m.AmountRewards
	}
	return nil
}

func (m *MailRewardReply) GetTreasureRewards() []*OpenTreasureReply {
	if m != nil {
		return m.TreasureRewards
	}
	return nil
}

func (m *MailRewardReply) GetCards() []*MailRewardCard {
	if m != nil {
		return m.Cards
	}
	return nil
}

func (m *MailRewardReply) GetItemRewards() []*MailRewardItemArg {
	if m != nil {
		return m.ItemRewards
	}
	return nil
}

func (m *MailRewardReply) GetEmojiTeams() []int32 {
	if m != nil {
		return m.EmojiTeams
	}
	return nil
}

type WholeServerMail struct {
	MailData       *Mail           `protobuf:"bytes,1,opt,name=MailData" json:"MailData,omitempty"`
	AccountType    AccountTypeEnum `protobuf:"varint,2,opt,name=AccountType,proto3,enum=pb.AccountTypeEnum" json:"AccountType,omitempty"`
	NewbieDeadLine int64           `protobuf:"varint,3,opt,name=NewbieDeadLine,proto3" json:"NewbieDeadLine,omitempty"`
	Area           int32           `protobuf:"varint,4,opt,name=Area,proto3" json:"Area,omitempty"`
}

func (m *WholeServerMail) Reset()                    { *m = WholeServerMail{} }
func (m *WholeServerMail) String() string            { return proto.CompactTextString(m) }
func (*WholeServerMail) ProtoMessage()               {}
func (*WholeServerMail) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{14} }

func (m *WholeServerMail) GetMailData() *Mail {
	if m != nil {
		return m.MailData
	}
	return nil
}

func (m *WholeServerMail) GetAccountType() AccountTypeEnum {
	if m != nil {
		return m.AccountType
	}
	return AccountTypeEnum_UnknowAccountType
}

func (m *WholeServerMail) GetNewbieDeadLine() int64 {
	if m != nil {
		return m.NewbieDeadLine
	}
	return 0
}

func (m *WholeServerMail) GetArea() int32 {
	if m != nil {
		return m.Area
	}
	return 0
}

type ReimburseBackMailPrivID struct {
	PrivID int32 `protobuf:"varint,1,opt,name=PrivID,proto3" json:"PrivID,omitempty"`
}

func (m *ReimburseBackMailPrivID) Reset()                    { *m = ReimburseBackMailPrivID{} }
func (m *ReimburseBackMailPrivID) String() string            { return proto.CompactTextString(m) }
func (*ReimburseBackMailPrivID) ProtoMessage()               {}
func (*ReimburseBackMailPrivID) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{15} }

func (m *ReimburseBackMailPrivID) GetPrivID() int32 {
	if m != nil {
		return m.PrivID
	}
	return 0
}

type LeagueSeasonEndArg struct {
	OldScore int32 `protobuf:"varint,1,opt,name=OldScore,proto3" json:"OldScore,omitempty"`
	NewScore int32 `protobuf:"varint,2,opt,name=NewScore,proto3" json:"NewScore,omitempty"`
	Rank     int32 `protobuf:"varint,3,opt,name=Rank,proto3" json:"Rank,omitempty"`
}

func (m *LeagueSeasonEndArg) Reset()                    { *m = LeagueSeasonEndArg{} }
func (m *LeagueSeasonEndArg) String() string            { return proto.CompactTextString(m) }
func (*LeagueSeasonEndArg) ProtoMessage()               {}
func (*LeagueSeasonEndArg) Descriptor() ([]byte, []int) { return fileDescriptorMail, []int{16} }

func (m *LeagueSeasonEndArg) GetOldScore() int32 {
	if m != nil {
		return m.OldScore
	}
	return 0
}

func (m *LeagueSeasonEndArg) GetNewScore() int32 {
	if m != nil {
		return m.NewScore
	}
	return 0
}

func (m *LeagueSeasonEndArg) GetRank() int32 {
	if m != nil {
		return m.Rank
	}
	return 0
}

func init() {
	proto.RegisterType((*FetchMailListArg)(nil), "pb.FetchMailListArg")
	proto.RegisterType((*MailReward)(nil), "pb.MailReward")
	proto.RegisterType((*MailSeasonPvpBeginArg)(nil), "pb.MailSeasonPvpBeginArg")
	proto.RegisterType((*MailSeasonPvpEndArg)(nil), "pb.MailSeasonPvpEndArg")
	proto.RegisterType((*MailRankHonorRewardArg)(nil), "pb.MailRankHonorRewardArg")
	proto.RegisterType((*MailCampaignUnifiedArg)(nil), "pb.MailCampaignUnifiedArg")
	proto.RegisterType((*Mail)(nil), "pb.Mail")
	proto.RegisterType((*MailList)(nil), "pb.MailList")
	proto.RegisterType((*GetMailRewardArg)(nil), "pb.GetMailRewardArg")
	proto.RegisterType((*ReadMailArg)(nil), "pb.ReadMailArg")
	proto.RegisterType((*MailRewardCard)(nil), "pb.MailRewardCard")
	proto.RegisterType((*MailRewardAmountArg)(nil), "pb.MailRewardAmountArg")
	proto.RegisterType((*MailRewardItemArg)(nil), "pb.MailRewardItemArg")
	proto.RegisterType((*MailRewardReply)(nil), "pb.MailRewardReply")
	proto.RegisterType((*WholeServerMail)(nil), "pb.WholeServerMail")
	proto.RegisterType((*ReimburseBackMailPrivID)(nil), "pb.ReimburseBackMailPrivID")
	proto.RegisterType((*LeagueSeasonEndArg)(nil), "pb.LeagueSeasonEndArg")
	proto.RegisterEnum("pb.MailRewardType", MailRewardType_name, MailRewardType_value)
	proto.RegisterEnum("pb.MailTypeEnum", MailTypeEnum_name, MailTypeEnum_value)
}
func (m *FetchMailListArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchMailListArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MinMailID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.MinMailID))
	}
	return i, nil
}

func (m *MailReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailReward) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Type))
	}
	if m.Amount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Amount))
	}
	if m.CardID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.CardID))
	}
	if len(m.ItemID) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.ItemID)))
		i += copy(dAtA[i:], m.ItemID)
	}
	if m.EmojiTeam != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.EmojiTeam))
	}
	return i, nil
}

func (m *MailSeasonPvpBeginArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailSeasonPvpBeginArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PvpLevel != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.PvpLevel))
	}
	return i, nil
}

func (m *MailSeasonPvpEndArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailSeasonPvpEndArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.WinDiff != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.WinDiff))
	}
	return i, nil
}

func (m *MailRankHonorRewardArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailRankHonorRewardArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rank != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Rank))
	}
	if m.Honor != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Honor))
	}
	return i, nil
}

func (m *MailCampaignUnifiedArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailCampaignUnifiedArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.YourMajestyName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.YourMajestyName)))
		i += copy(dAtA[i:], m.YourMajestyName)
	}
	if len(m.CountryName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.CountryName)))
		i += copy(dAtA[i:], m.CountryName)
	}
	return i, nil
}

func (m *Mail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Mail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.ID))
	}
	if len(m.Title) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if m.Time != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Time))
	}
	if m.IsReward {
		dAtA[i] = 0x30
		i++
		if m.IsReward {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.SenderName) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.SenderName)))
		i += copy(dAtA[i:], m.SenderName)
	}
	if len(m.Rewards) > 0 {
		for _, msg := range m.Rewards {
			dAtA[i] = 0x42
			i++
			i = encodeVarintMail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.IsRead {
		dAtA[i] = 0x48
		i++
		if m.IsRead {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MailType != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.MailType))
	}
	if len(m.Arg) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.Arg)))
		i += copy(dAtA[i:], m.Arg)
	}
	return i, nil
}

func (m *MailList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Mails) > 0 {
		for _, msg := range m.Mails {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.HasMore {
		dAtA[i] = 0x10
		i++
		if m.HasMore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GetMailRewardArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetMailRewardArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.ID))
	}
	return i, nil
}

func (m *ReadMailArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadMailArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.ID))
	}
	return i, nil
}

func (m *MailRewardCard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailRewardCard) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CardID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.CardID))
	}
	if m.Amount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Amount))
	}
	return i, nil
}

func (m *MailRewardAmountArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailRewardAmountArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Type))
	}
	if m.Amount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Amount))
	}
	return i, nil
}

func (m *MailRewardItemArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailRewardItemArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Type))
	}
	if len(m.ItemID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMail(dAtA, i, uint64(len(m.ItemID)))
		i += copy(dAtA[i:], m.ItemID)
	}
	return i, nil
}

func (m *MailRewardReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailRewardReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AmountRewards) > 0 {
		for _, msg := range m.AmountRewards {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TreasureRewards) > 0 {
		for _, msg := range m.TreasureRewards {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Cards) > 0 {
		for _, msg := range m.Cards {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ItemRewards) > 0 {
		for _, msg := range m.ItemRewards {
			dAtA[i] = 0x22
			i++
			i = encodeVarintMail(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.EmojiTeams) > 0 {
		dAtA2 := make([]byte, len(m.EmojiTeams)*10)
		var j1 int
		for _, num1 := range m.EmojiTeams {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintMail(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *WholeServerMail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WholeServerMail) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MailData != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.MailData.Size()))
		n3, err := m.MailData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.AccountType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.AccountType))
	}
	if m.NewbieDeadLine != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.NewbieDeadLine))
	}
	if m.Area != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Area))
	}
	return i, nil
}

func (m *ReimburseBackMailPrivID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReimburseBackMailPrivID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PrivID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.PrivID))
	}
	return i, nil
}

func (m *LeagueSeasonEndArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeagueSeasonEndArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OldScore != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.OldScore))
	}
	if m.NewScore != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.NewScore))
	}
	if m.Rank != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMail(dAtA, i, uint64(m.Rank))
	}
	return i, nil
}

func encodeVarintMail(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *FetchMailListArg) Size() (n int) {
	var l int
	_ = l
	if m.MinMailID != 0 {
		n += 1 + sovMail(uint64(m.MinMailID))
	}
	return n
}

func (m *MailReward) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMail(uint64(m.Type))
	}
	if m.Amount != 0 {
		n += 1 + sovMail(uint64(m.Amount))
	}
	if m.CardID != 0 {
		n += 1 + sovMail(uint64(m.CardID))
	}
	l = len(m.ItemID)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	if m.EmojiTeam != 0 {
		n += 1 + sovMail(uint64(m.EmojiTeam))
	}
	return n
}

func (m *MailSeasonPvpBeginArg) Size() (n int) {
	var l int
	_ = l
	if m.PvpLevel != 0 {
		n += 1 + sovMail(uint64(m.PvpLevel))
	}
	return n
}

func (m *MailSeasonPvpEndArg) Size() (n int) {
	var l int
	_ = l
	if m.WinDiff != 0 {
		n += 1 + sovMail(uint64(m.WinDiff))
	}
	return n
}

func (m *MailRankHonorRewardArg) Size() (n int) {
	var l int
	_ = l
	if m.Rank != 0 {
		n += 1 + sovMail(uint64(m.Rank))
	}
	if m.Honor != 0 {
		n += 1 + sovMail(uint64(m.Honor))
	}
	return n
}

func (m *MailCampaignUnifiedArg) Size() (n int) {
	var l int
	_ = l
	l = len(m.YourMajestyName)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.CountryName)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *Mail) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMail(uint64(m.ID))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	if m.Time != 0 {
		n += 1 + sovMail(uint64(m.Time))
	}
	if m.IsReward {
		n += 2
	}
	l = len(m.SenderName)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	if len(m.Rewards) > 0 {
		for _, e := range m.Rewards {
			l = e.Size()
			n += 1 + l + sovMail(uint64(l))
		}
	}
	if m.IsRead {
		n += 2
	}
	if m.MailType != 0 {
		n += 1 + sovMail(uint64(m.MailType))
	}
	l = len(m.Arg)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *MailList) Size() (n int) {
	var l int
	_ = l
	if len(m.Mails) > 0 {
		for _, e := range m.Mails {
			l = e.Size()
			n += 1 + l + sovMail(uint64(l))
		}
	}
	if m.HasMore {
		n += 2
	}
	return n
}

func (m *GetMailRewardArg) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMail(uint64(m.ID))
	}
	return n
}

func (m *ReadMailArg) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMail(uint64(m.ID))
	}
	return n
}

func (m *MailRewardCard) Size() (n int) {
	var l int
	_ = l
	if m.CardID != 0 {
		n += 1 + sovMail(uint64(m.CardID))
	}
	if m.Amount != 0 {
		n += 1 + sovMail(uint64(m.Amount))
	}
	return n
}

func (m *MailRewardAmountArg) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMail(uint64(m.Type))
	}
	if m.Amount != 0 {
		n += 1 + sovMail(uint64(m.Amount))
	}
	return n
}

func (m *MailRewardItemArg) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMail(uint64(m.Type))
	}
	l = len(m.ItemID)
	if l > 0 {
		n += 1 + l + sovMail(uint64(l))
	}
	return n
}

func (m *MailRewardReply) Size() (n int) {
	var l int
	_ = l
	if len(m.AmountRewards) > 0 {
		for _, e := range m.AmountRewards {
			l = e.Size()
			n += 1 + l + sovMail(uint64(l))
		}
	}
	if len(m.TreasureRewards) > 0 {
		for _, e := range m.TreasureRewards {
			l = e.Size()
			n += 1 + l + sovMail(uint64(l))
		}
	}
	if len(m.Cards) > 0 {
		for _, e := range m.Cards {
			l = e.Size()
			n += 1 + l + sovMail(uint64(l))
		}
	}
	if len(m.ItemRewards) > 0 {
		for _, e := range m.ItemRewards {
			l = e.Size()
			n += 1 + l + sovMail(uint64(l))
		}
	}
	if len(m.EmojiTeams) > 0 {
		l = 0
		for _, e := range m.EmojiTeams {
			l += sovMail(uint64(e))
		}
		n += 1 + sovMail(uint64(l)) + l
	}
	return n
}

func (m *WholeServerMail) Size() (n int) {
	var l int
	_ = l
	if m.MailData != nil {
		l = m.MailData.Size()
		n += 1 + l + sovMail(uint64(l))
	}
	if m.AccountType != 0 {
		n += 1 + sovMail(uint64(m.AccountType))
	}
	if m.NewbieDeadLine != 0 {
		n += 1 + sovMail(uint64(m.NewbieDeadLine))
	}
	if m.Area != 0 {
		n += 1 + sovMail(uint64(m.Area))
	}
	return n
}

func (m *ReimburseBackMailPrivID) Size() (n int) {
	var l int
	_ = l
	if m.PrivID != 0 {
		n += 1 + sovMail(uint64(m.PrivID))
	}
	return n
}

func (m *LeagueSeasonEndArg) Size() (n int) {
	var l int
	_ = l
	if m.OldScore != 0 {
		n += 1 + sovMail(uint64(m.OldScore))
	}
	if m.NewScore != 0 {
		n += 1 + sovMail(uint64(m.NewScore))
	}
	if m.Rank != 0 {
		n += 1 + sovMail(uint64(m.Rank))
	}
	return n
}

func sovMail(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMail(x uint64) (n int) {
	return sovMail(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *FetchMailListArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchMailListArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchMailListArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinMailID", wireType)
			}
			m.MinMailID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinMailID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailReward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MailReward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MailReward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (MailRewardType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardID", wireType)
			}
			m.CardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmojiTeam", wireType)
			}
			m.EmojiTeam = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EmojiTeam |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailSeasonPvpBeginArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MailSeasonPvpBeginArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MailSeasonPvpBeginArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PvpLevel", wireType)
			}
			m.PvpLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PvpLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailSeasonPvpEndArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MailSeasonPvpEndArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MailSeasonPvpEndArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinDiff", wireType)
			}
			m.WinDiff = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WinDiff |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailRankHonorRewardArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MailRankHonorRewardArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MailRankHonorRewardArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Honor", wireType)
			}
			m.Honor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Honor |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailCampaignUnifiedArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MailCampaignUnifiedArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MailCampaignUnifiedArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YourMajestyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.YourMajestyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CountryName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Mail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Mail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Mail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsReward", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsReward = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SenderName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rewards = append(m.Rewards, &MailReward{})
			if err := m.Rewards[len(m.Rewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRead", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRead = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailType", wireType)
			}
			m.MailType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MailType |= (MailTypeEnum(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arg = append(m.Arg[:0], dAtA[iNdEx:postIndex]...)
			if m.Arg == nil {
				m.Arg = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MailList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MailList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mails = append(m.Mails, &Mail{})
			if err := m.Mails[len(m.Mails)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasMore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasMore = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetMailRewardArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetMailRewardArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetMailRewardArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadMailArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadMailArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadMailArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailRewardCard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MailRewardCard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MailRewardCard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardID", wireType)
			}
			m.CardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailRewardAmountArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MailRewardAmountArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MailRewardAmountArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (MailRewardType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailRewardItemArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MailRewardItemArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MailRewardItemArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (MailRewardType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailRewardReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MailRewardReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MailRewardReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountRewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmountRewards = append(m.AmountRewards, &MailRewardAmountArg{})
			if err := m.AmountRewards[len(m.AmountRewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasureRewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TreasureRewards = append(m.TreasureRewards, &OpenTreasureReply{})
			if err := m.TreasureRewards[len(m.TreasureRewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cards = append(m.Cards, &MailRewardCard{})
			if err := m.Cards[len(m.Cards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemRewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemRewards = append(m.ItemRewards, &MailRewardItemArg{})
			if err := m.ItemRewards[len(m.ItemRewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMail
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EmojiTeams = append(m.EmojiTeams, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMail
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMail
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMail
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EmojiTeams = append(m.EmojiTeams, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EmojiTeams", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WholeServerMail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WholeServerMail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WholeServerMail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMail
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MailData == nil {
				m.MailData = &Mail{}
			}
			if err := m.MailData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountType", wireType)
			}
			m.AccountType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountType |= (AccountTypeEnum(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewbieDeadLine", wireType)
			}
			m.NewbieDeadLine = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewbieDeadLine |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Area", wireType)
			}
			m.Area = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Area |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReimburseBackMailPrivID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReimburseBackMailPrivID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReimburseBackMailPrivID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivID", wireType)
			}
			m.PrivID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrivID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeagueSeasonEndArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMail
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeagueSeasonEndArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeagueSeasonEndArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldScore", wireType)
			}
			m.OldScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OldScore |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewScore", wireType)
			}
			m.NewScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewScore |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMail
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMail(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMail
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMail(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMail
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMail
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMail
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMail
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMail
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMail(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMail = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMail   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("mail.proto", fileDescriptorMail) }

var fileDescriptorMail = []byte{
	// 1120 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xdd, 0x6e, 0x1b, 0x45,
	0x14, 0xee, 0xae, 0xed, 0xc4, 0x3e, 0x76, 0xec, 0xe9, 0x94, 0xb6, 0x56, 0x04, 0x91, 0xb5, 0x42,
	0x95, 0x55, 0xa1, 0x02, 0xad, 0x10, 0x57, 0x08, 0x1c, 0x3b, 0x69, 0x03, 0x71, 0x1b, 0xad, 0x5d,
	0x55, 0xbd, 0x63, 0xec, 0x3d, 0x75, 0xa6, 0xb1, 0x77, 0x97, 0xd9, 0x71, 0xa2, 0xbc, 0x47, 0x2f,
	0x2a, 0x1e, 0x81, 0x27, 0xe1, 0x92, 0x47, 0x40, 0xe5, 0x31, 0xb8, 0x41, 0x67, 0x66, 0x76, 0xbd,
	0x31, 0xbd, 0x41, 0xdc, 0xcd, 0xf9, 0xce, 0xcf, 0x9c, 0x9f, 0xef, 0xcc, 0x2e, 0xc0, 0x4a, 0xc8,
	0xe5, 0xa3, 0x54, 0x25, 0x3a, 0xe1, 0x7e, 0x3a, 0xdb, 0x6f, 0x6b, 0x85, 0x22, 0x5b, 0x2b, 0xb4,
	0xd8, 0x7e, 0x2b, 0x5d, 0x8a, 0x6b, 0x54, 0x56, 0x0a, 0xbe, 0x02, 0x76, 0x8c, 0x7a, 0x7e, 0x3e,
	0x16, 0x72, 0x79, 0x2a, 0x33, 0x3d, 0x50, 0x0b, 0xfe, 0x29, 0x34, 0xc6, 0x32, 0x26, 0xe4, 0x64,
	0xd4, 0xf5, 0x7a, 0x5e, 0xbf, 0x16, 0x6e, 0x80, 0xe0, 0x57, 0x0f, 0x80, 0x8e, 0x21, 0x5e, 0x09,
	0x15, 0xf1, 0x07, 0x50, 0x9d, 0x5e, 0xa7, 0x68, 0xec, 0xda, 0x8f, 0xf9, 0xa3, 0x74, 0xf6, 0x68,
	0xa3, 0x25, 0x4d, 0x68, 0xf4, 0xfc, 0x1e, 0xec, 0x0c, 0x56, 0xc9, 0x3a, 0xd6, 0x5d, 0xdf, 0x44,
	0x74, 0x12, 0xe1, 0x43, 0xa1, 0xa2, 0x93, 0x51, 0xb7, 0xd2, 0xf3, 0xfa, 0x7b, 0xa1, 0x93, 0x08,
	0x3f, 0xd1, 0xb8, 0x3a, 0x19, 0x75, 0xab, 0x3d, 0xaf, 0xdf, 0x08, 0x9d, 0x44, 0xc9, 0x1d, 0xad,
	0x92, 0xb7, 0x72, 0x8a, 0x62, 0xd5, 0xad, 0xd9, 0xe4, 0x0a, 0x20, 0x78, 0x02, 0x77, 0xe9, 0xf6,
	0x09, 0x8a, 0x2c, 0x89, 0xcf, 0x2e, 0xd3, 0x43, 0x5c, 0xc8, 0x98, 0x6a, 0xda, 0x87, 0xfa, 0xd9,
	0x65, 0x7a, 0x8a, 0x97, 0xb8, 0x74, 0x25, 0x15, 0x72, 0xf0, 0x25, 0xdc, 0xb9, 0xe1, 0x74, 0x14,
	0x47, 0xe4, 0xd2, 0x85, 0xdd, 0x57, 0x32, 0x1e, 0xc9, 0x37, 0x6f, 0x9c, 0x47, 0x2e, 0x06, 0x87,
	0x70, 0xcf, 0xd4, 0x28, 0xe2, 0x8b, 0x67, 0x49, 0x9c, 0x28, 0x5b, 0x2c, 0xf9, 0x70, 0xa8, 0x12,
	0xea, 0x1c, 0xcc, 0x99, 0x7f, 0x02, 0x35, 0x63, 0xe5, 0x0a, 0xb7, 0x42, 0x10, 0xd9, 0x18, 0x43,
	0xb1, 0x4a, 0x85, 0x5c, 0xc4, 0x2f, 0x63, 0xf9, 0x46, 0xa2, 0x89, 0xd1, 0x87, 0xce, 0xeb, 0x64,
	0xad, 0xc6, 0xe2, 0x2d, 0x66, 0xfa, 0xfa, 0xb9, 0x58, 0xd9, 0xe6, 0x36, 0xc2, 0x6d, 0x98, 0xf7,
	0xa0, 0x39, 0xa4, 0x26, 0x2a, 0x6b, 0xe5, 0x1b, 0xab, 0x32, 0x14, 0xbc, 0xf7, 0xa1, 0x4a, 0xd7,
	0xf0, 0x36, 0xf8, 0xc5, 0x30, 0xfd, 0x93, 0x11, 0x25, 0x35, 0x95, 0x7a, 0x99, 0x3b, 0x59, 0x81,
	0x4a, 0x1e, 0x26, 0xb1, 0xc6, 0x58, 0x9b, 0x69, 0x34, 0xc2, 0x5c, 0xa4, 0xc2, 0xa6, 0x72, 0x85,
	0x66, 0x18, 0xb5, 0xd0, 0x9c, 0xa9, 0xa7, 0x27, 0x99, 0xad, 0xbd, 0xbb, 0xd3, 0xf3, 0xfa, 0xf5,
	0xb0, 0x90, 0xf9, 0x01, 0xc0, 0x04, 0xe3, 0x08, 0x95, 0xc9, 0x6c, 0xd7, 0x04, 0x2b, 0x21, 0xbc,
	0x0f, 0xbb, 0xd6, 0x32, 0xeb, 0xd6, 0x7b, 0x95, 0x7e, 0xf3, 0x71, 0xfb, 0x26, 0x73, 0xc2, 0x5c,
	0x6d, 0x88, 0x90, 0x85, 0x28, 0xa2, 0x6e, 0xc3, 0xdc, 0xe1, 0x24, 0xfe, 0x05, 0xd4, 0xc9, 0xdc,
	0x90, 0x0f, 0x0c, 0xf9, 0x58, 0x1e, 0x82, 0xb0, 0xa3, 0x78, 0xbd, 0x0a, 0x0b, 0x0b, 0xce, 0xa0,
	0x32, 0x50, 0x8b, 0x6e, 0xb3, 0xe7, 0xf5, 0x5b, 0x21, 0x1d, 0x83, 0x91, 0xf5, 0x27, 0xd2, 0xf3,
	0x03, 0xa8, 0xd1, 0x39, 0xeb, 0x7a, 0x26, 0x97, 0x7a, 0x91, 0x8b, 0x85, 0xa9, 0x2f, 0xcf, 0x44,
	0x36, 0x4e, 0x94, 0xed, 0x57, 0x3d, 0xcc, 0xc5, 0x20, 0x00, 0xf6, 0x14, 0xf5, 0x26, 0x6f, 0x1a,
	0xe0, 0x56, 0xaf, 0x83, 0xcf, 0xa0, 0x49, 0x19, 0x93, 0xd1, 0xc7, 0xd4, 0x3f, 0x40, 0x7b, 0xe3,
	0x4f, 0xec, 0x2f, 0xed, 0x84, 0xb7, 0xbd, 0x13, 0x1f, 0xdb, 0xa1, 0xe0, 0xa5, 0x25, 0xb0, 0xcb,
	0xc0, 0x60, 0x74, 0xd1, 0xff, 0x5c, 0xcd, 0x60, 0x02, 0xb7, 0x37, 0xf6, 0xb4, 0x7e, 0xff, 0x31,
	0xa8, 0xdb, 0x5f, 0xbf, 0xbc, 0xbf, 0xc1, 0x3b, 0x1f, 0x3a, 0xa5, 0x31, 0x63, 0xba, 0xbc, 0xe6,
	0xdf, 0xc1, 0x9e, 0xbd, 0x32, 0xa7, 0x84, 0x1d, 0xc3, 0xfd, 0x9b, 0xc1, 0x8b, 0xc2, 0xc2, 0x9b,
	0xd6, 0xfc, 0x7b, 0xe8, 0x4c, 0xdd, 0x1b, 0x97, 0x07, 0xf0, 0x4d, 0x80, 0xbb, 0x14, 0xe0, 0x45,
	0x8a, 0xf1, 0x46, 0x9d, 0x2e, 0xaf, 0xc3, 0x6d, 0x6b, 0xde, 0x87, 0xda, 0xd0, 0xb8, 0x55, 0x8c,
	0xdb, 0x56, 0x51, 0xa4, 0x0a, 0xad, 0x01, 0xff, 0x16, 0x9a, 0x54, 0x47, 0x7e, 0x4d, 0x75, 0x73,
	0xcd, 0xbf, 0x3a, 0x15, 0x96, 0x2d, 0x69, 0x1f, 0x8a, 0x57, 0x2a, 0xeb, 0xd6, 0x7a, 0x95, 0x7e,
	0x2d, 0x2c, 0x21, 0xc1, 0x6f, 0x1e, 0x74, 0x5e, 0x9d, 0x27, 0x4b, 0x9c, 0xa0, 0xba, 0x44, 0x65,
	0x76, 0xf6, 0x73, 0xcb, 0xd0, 0x91, 0xd0, 0xc2, 0xb4, 0xbb, 0x4c, 0xcc, 0x42, 0xc3, 0xbf, 0x81,
	0xe6, 0x60, 0x3e, 0xa7, 0x7e, 0x98, 0xb9, 0xf8, 0x66, 0x2e, 0x77, 0xc8, 0xb0, 0x04, 0x9b, 0x6d,
	0x28, 0xdb, 0xf1, 0x07, 0xd0, 0x7e, 0x8e, 0x57, 0x33, 0x89, 0x23, 0x14, 0xd1, 0xa9, 0x8c, 0xd1,
	0x6c, 0x7c, 0x25, 0xdc, 0x42, 0x69, 0xf1, 0x07, 0x0a, 0x45, 0xbe, 0xf8, 0x74, 0x0e, 0xbe, 0x86,
	0xfb, 0x21, 0xca, 0xd5, 0x6c, 0xad, 0x32, 0x3c, 0x14, 0xf3, 0x0b, 0xca, 0xe5, 0x4c, 0xc9, 0x4b,
	0x4b, 0x51, 0x7b, 0x72, 0x04, 0x77, 0x52, 0xf0, 0x33, 0xf0, 0x53, 0x14, 0x8b, 0x35, 0xda, 0x57,
	0xd6, 0x3d, 0xb1, 0xfb, 0x50, 0x7f, 0xb1, 0x8c, 0x26, 0x73, 0x5a, 0x2c, 0xf7, 0x2a, 0xe7, 0x32,
	0xe9, 0x9e, 0xe3, 0x95, 0xd5, 0x59, 0x5e, 0x16, 0x72, 0xf1, 0xcc, 0x56, 0x36, 0xcf, 0xec, 0xc3,
	0x77, 0x7e, 0x79, 0x8f, 0x4c, 0x8d, 0x4d, 0xd8, 0x1d, 0x2b, 0xfd, 0x34, 0x59, 0x46, 0xec, 0x96,
	0x13, 0x7e, 0x14, 0x11, 0x32, 0xcf, 0x09, 0x34, 0x53, 0xe6, 0xf3, 0x0e, 0x34, 0xc7, 0x4a, 0xe7,
	0xa4, 0x60, 0x15, 0x07, 0x90, 0x76, 0x72, 0x21, 0x63, 0x56, 0xe5, 0x0c, 0x5a, 0x63, 0xa5, 0x9f,
	0xa1, 0x88, 0x8e, 0x95, 0x58, 0x21, 0xab, 0xf1, 0x16, 0xd4, 0xc7, 0x4a, 0x1f, 0xa3, 0xd0, 0x19,
	0xdb, 0x71, 0x0e, 0x67, 0x0a, 0x33, 0x2d, 0x17, 0xc8, 0x76, 0x9d, 0xfa, 0xe8, 0x97, 0xb5, 0x4c,
	0x59, 0x3d, 0x97, 0x68, 0xda, 0xac, 0xc1, 0xef, 0x40, 0x87, 0xa2, 0x27, 0xb1, 0x56, 0x72, 0xb6,
	0xd6, 0x32, 0x89, 0x19, 0xf0, 0x36, 0xc0, 0x58, 0xe9, 0xc3, 0xe4, 0x6a, 0x19, 0xa1, 0x62, 0x4d,
	0x7e, 0x1b, 0xf6, 0xc6, 0x4a, 0x87, 0x98, 0xae, 0xb5, 0x30, 0x26, 0x2d, 0x97, 0x04, 0x65, 0x75,
	0x26, 0x71, 0x8e, 0x6c, 0xcf, 0x21, 0x94, 0xa3, 0x45, 0xda, 0x0e, 0x19, 0xcc, 0xe7, 0x53, 0x39,
	0xbf, 0x40, 0xcd, 0x3a, 0x0f, 0xff, 0xf6, 0xa0, 0x55, 0x7e, 0x13, 0x39, 0xc0, 0xce, 0xf0, 0xe5,
	0x64, 0xfa, 0x62, 0xcc, 0x6e, 0x71, 0x0e, 0xed, 0x9b, 0x9f, 0x4a, 0xe6, 0x51, 0x88, 0xf2, 0x97,
	0x90, 0xf9, 0x94, 0xfe, 0xf1, 0x6c, 0x10, 0x5d, 0xa2, 0xd2, 0xac, 0x42, 0x99, 0xfe, 0x24, 0xe3,
	0x85, 0x6d, 0x33, 0xab, 0x52, 0x39, 0xc3, 0x73, 0x25, 0x33, 0xbd, 0x12, 0xee, 0xf1, 0x67, 0x35,
	0x4a, 0xff, 0xf5, 0x5a, 0xc4, 0x91, 0x88, 0x1d, 0xb4, 0x63, 0xec, 0x6e, 0x7e, 0xec, 0xd8, 0xae,
	0x49, 0x20, 0x55, 0x26, 0xdc, 0xfc, 0x5c, 0xa8, 0x05, 0xb2, 0x3a, 0x19, 0x6e, 0x7d, 0x59, 0x59,
	0x83, 0xdf, 0x85, 0xdb, 0xc4, 0x34, 0x62, 0x53, 0x41, 0x3d, 0x06, 0xd4, 0x78, 0x47, 0x2b, 0x2d,
	0x94, 0x66, 0x4d, 0xbe, 0x07, 0x0d, 0x0b, 0x50, 0xea, 0xad, 0x43, 0xf6, 0xfb, 0x87, 0x03, 0xef,
	0x8f, 0x0f, 0x07, 0xde, 0x9f, 0x1f, 0x0e, 0xbc, 0xf7, 0x7f, 0x1d, 0xdc, 0x9a, 0xed, 0x98, 0xff,
	0x9e, 0x27, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0xaf, 0xad, 0x4c, 0x8f, 0x27, 0x09, 0x00, 0x00,
}
