// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: player.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type AccountTypeEnum int32

const (
	AccountTypeEnum_UnknowAccountType AccountTypeEnum = 0
	AccountTypeEnum_Ios               AccountTypeEnum = 1
	AccountTypeEnum_Android           AccountTypeEnum = 2
	AccountTypeEnum_Wxgame            AccountTypeEnum = 3
	AccountTypeEnum_WxgameIos         AccountTypeEnum = 4
)

var AccountTypeEnum_name = map[int32]string{
	0: "UnknowAccountType",
	1: "Ios",
	2: "Android",
	3: "Wxgame",
	4: "WxgameIos",
}
var AccountTypeEnum_value = map[string]int32{
	"UnknowAccountType": 0,
	"Ios":               1,
	"Android":           2,
	"Wxgame":            3,
	"WxgameIos":         4,
}

func (x AccountTypeEnum) String() string {
	return proto.EnumName(AccountTypeEnum_name, int32(x))
}
func (AccountTypeEnum) EnumDescriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{0} }

type KickOut struct {
	Reason int32 `protobuf:"varint,1,opt,name=Reason,proto3" json:"Reason,omitempty"`
}

func (m *KickOut) Reset()                    { *m = KickOut{} }
func (m *KickOut) String() string            { return proto.CompactTextString(m) }
func (*KickOut) ProtoMessage()               {}
func (*KickOut) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{0} }

func (m *KickOut) GetReason() int32 {
	if m != nil {
		return m.Reason
	}
	return 0
}

type FinishGuide struct {
	GuideID int32 `protobuf:"varint,1,opt,name=GuideID,proto3" json:"GuideID,omitempty"`
}

func (m *FinishGuide) Reset()                    { *m = FinishGuide{} }
func (m *FinishGuide) String() string            { return proto.CompactTextString(m) }
func (*FinishGuide) ProtoMessage()               {}
func (*FinishGuide) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{1} }

func (m *FinishGuide) GetGuideID() int32 {
	if m != nil {
		return m.GuideID
	}
	return 0
}

type AllFinishGuide struct {
	GuideIDs []int32 `protobuf:"varint,1,rep,packed,name=GuideIDs" json:"GuideIDs,omitempty"`
}

func (m *AllFinishGuide) Reset()                    { *m = AllFinishGuide{} }
func (m *AllFinishGuide) String() string            { return proto.CompactTextString(m) }
func (*AllFinishGuide) ProtoMessage()               {}
func (*AllFinishGuide) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{2} }

func (m *AllFinishGuide) GetGuideIDs() []int32 {
	if m != nil {
		return m.GuideIDs
	}
	return nil
}

type GuideGroup struct {
	GroupID int32 `protobuf:"varint,1,opt,name=GroupID,proto3" json:"GroupID,omitempty"`
}

func (m *GuideGroup) Reset()                    { *m = GuideGroup{} }
func (m *GuideGroup) String() string            { return proto.CompactTextString(m) }
func (*GuideGroup) ProtoMessage()               {}
func (*GuideGroup) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{3} }

func (m *GuideGroup) GetGroupID() int32 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

type LoginArg struct {
	ArchiveID    int32           `protobuf:"varint,1,opt,name=ArchiveID,proto3" json:"ArchiveID,omitempty"`
	Channel      string          `protobuf:"bytes,2,opt,name=Channel,proto3" json:"Channel,omitempty"`
	ChannelID    string          `protobuf:"bytes,3,opt,name=ChannelID,proto3" json:"ChannelID,omitempty"`
	AccountType  AccountTypeEnum `protobuf:"varint,4,opt,name=AccountType,proto3,enum=pb.AccountTypeEnum" json:"AccountType,omitempty"`
	IsTourist    bool            `protobuf:"varint,5,opt,name=IsTourist,proto3" json:"IsTourist,omitempty"`
	LoginChannel string          `protobuf:"bytes,6,opt,name=LoginChannel,proto3" json:"LoginChannel,omitempty"`
	Country      string          `protobuf:"bytes,7,opt,name=Country,proto3" json:"Country,omitempty"`
	SubChannel   string          `protobuf:"bytes,8,opt,name=SubChannel,proto3" json:"SubChannel,omitempty"`
}

func (m *LoginArg) Reset()                    { *m = LoginArg{} }
func (m *LoginArg) String() string            { return proto.CompactTextString(m) }
func (*LoginArg) ProtoMessage()               {}
func (*LoginArg) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{4} }

func (m *LoginArg) GetArchiveID() int32 {
	if m != nil {
		return m.ArchiveID
	}
	return 0
}

func (m *LoginArg) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *LoginArg) GetChannelID() string {
	if m != nil {
		return m.ChannelID
	}
	return ""
}

func (m *LoginArg) GetAccountType() AccountTypeEnum {
	if m != nil {
		return m.AccountType
	}
	return AccountTypeEnum_UnknowAccountType
}

func (m *LoginArg) GetIsTourist() bool {
	if m != nil {
		return m.IsTourist
	}
	return false
}

func (m *LoginArg) GetLoginChannel() string {
	if m != nil {
		return m.LoginChannel
	}
	return ""
}

func (m *LoginArg) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

func (m *LoginArg) GetSubChannel() string {
	if m != nil {
		return m.SubChannel
	}
	return ""
}

type LoginReply struct {
	Uid                   uint64         `protobuf:"varint,1,opt,name=Uid,proto3" json:"Uid,omitempty"`
	Cards                 []*CardInfo    `protobuf:"bytes,2,rep,name=Cards" json:"Cards,omitempty"`
	Res                   []*Resource    `protobuf:"bytes,3,rep,name=Res" json:"Res,omitempty"`
	DiyCards              []*DiyCardData `protobuf:"bytes,4,rep,name=DiyCards" json:"DiyCards,omitempty"`
	FightID               uint64         `protobuf:"varint,5,opt,name=FightID,proto3" json:"FightID,omitempty"`
	ServerID              string         `protobuf:"bytes,6,opt,name=ServerID,proto3" json:"ServerID,omitempty"`
	GuideCamp             int32          `protobuf:"varint,7,opt,name=GuideCamp,proto3" json:"GuideCamp,omitempty"`
	Name                  string         `protobuf:"bytes,8,opt,name=Name,proto3" json:"Name,omitempty"`
	Ver                   *Version       `protobuf:"bytes,9,opt,name=Ver" json:"Ver,omitempty"`
	IsExamined            bool           `protobuf:"varint,10,opt,name=IsExamined,proto3" json:"IsExamined,omitempty"`
	HeadImg               string         `protobuf:"bytes,11,opt,name=HeadImg,proto3" json:"HeadImg,omitempty"`
	CumulativePay         int32          `protobuf:"varint,12,opt,name=CumulativePay,proto3" json:"CumulativePay,omitempty"`
	SharedState           int32          `protobuf:"varint,13,opt,name=SharedState,proto3" json:"SharedState,omitempty"`
	SeasonPvpLimitTime    int32          `protobuf:"varint,14,opt,name=SeasonPvpLimitTime,proto3" json:"SeasonPvpLimitTime,omitempty"`
	CardSkins             []string       `protobuf:"bytes,15,rep,name=CardSkins" json:"CardSkins,omitempty"`
	HeadFrame             string         `protobuf:"bytes,16,opt,name=HeadFrame,proto3" json:"HeadFrame,omitempty"`
	IsSeasonPvpChooseCard bool           `protobuf:"varint,17,opt,name=IsSeasonPvpChooseCard,proto3" json:"IsSeasonPvpChooseCard,omitempty"`
	IsInCampaignMatch     bool           `protobuf:"varint,18,opt,name=IsInCampaignMatch,proto3" json:"IsInCampaignMatch,omitempty"`
	Huodongs              []*HuodongData `protobuf:"bytes,19,rep,name=Huodongs" json:"Huodongs,omitempty"`
	RebornCnt             int32          `protobuf:"varint,20,opt,name=RebornCnt,proto3" json:"RebornCnt,omitempty"`
	Hints                 []*Hint        `protobuf:"bytes,21,rep,name=Hints" json:"Hints,omitempty"`
	OutStatuses           []*OutStatus   `protobuf:"bytes,22,rep,name=OutStatuses" json:"OutStatuses,omitempty"`
	Area                  int32          `protobuf:"varint,23,opt,name=Area,proto3" json:"Area,omitempty"`
	ChatPop               string         `protobuf:"bytes,24,opt,name=ChatPop,proto3" json:"ChatPop,omitempty"`
	Notice                *LoginNotice   `protobuf:"bytes,25,opt,name=Notice" json:"Notice,omitempty"`
	CountryFlag           string         `protobuf:"bytes,26,opt,name=CountryFlag,proto3" json:"CountryFlag,omitempty"`
}

func (m *LoginReply) Reset()                    { *m = LoginReply{} }
func (m *LoginReply) String() string            { return proto.CompactTextString(m) }
func (*LoginReply) ProtoMessage()               {}
func (*LoginReply) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{5} }

func (m *LoginReply) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *LoginReply) GetCards() []*CardInfo {
	if m != nil {
		return m.Cards
	}
	return nil
}

func (m *LoginReply) GetRes() []*Resource {
	if m != nil {
		return m.Res
	}
	return nil
}

func (m *LoginReply) GetDiyCards() []*DiyCardData {
	if m != nil {
		return m.DiyCards
	}
	return nil
}

func (m *LoginReply) GetFightID() uint64 {
	if m != nil {
		return m.FightID
	}
	return 0
}

func (m *LoginReply) GetServerID() string {
	if m != nil {
		return m.ServerID
	}
	return ""
}

func (m *LoginReply) GetGuideCamp() int32 {
	if m != nil {
		return m.GuideCamp
	}
	return 0
}

func (m *LoginReply) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LoginReply) GetVer() *Version {
	if m != nil {
		return m.Ver
	}
	return nil
}

func (m *LoginReply) GetIsExamined() bool {
	if m != nil {
		return m.IsExamined
	}
	return false
}

func (m *LoginReply) GetHeadImg() string {
	if m != nil {
		return m.HeadImg
	}
	return ""
}

func (m *LoginReply) GetCumulativePay() int32 {
	if m != nil {
		return m.CumulativePay
	}
	return 0
}

func (m *LoginReply) GetSharedState() int32 {
	if m != nil {
		return m.SharedState
	}
	return 0
}

func (m *LoginReply) GetSeasonPvpLimitTime() int32 {
	if m != nil {
		return m.SeasonPvpLimitTime
	}
	return 0
}

func (m *LoginReply) GetCardSkins() []string {
	if m != nil {
		return m.CardSkins
	}
	return nil
}

func (m *LoginReply) GetHeadFrame() string {
	if m != nil {
		return m.HeadFrame
	}
	return ""
}

func (m *LoginReply) GetIsSeasonPvpChooseCard() bool {
	if m != nil {
		return m.IsSeasonPvpChooseCard
	}
	return false
}

func (m *LoginReply) GetIsInCampaignMatch() bool {
	if m != nil {
		return m.IsInCampaignMatch
	}
	return false
}

func (m *LoginReply) GetHuodongs() []*HuodongData {
	if m != nil {
		return m.Huodongs
	}
	return nil
}

func (m *LoginReply) GetRebornCnt() int32 {
	if m != nil {
		return m.RebornCnt
	}
	return 0
}

func (m *LoginReply) GetHints() []*Hint {
	if m != nil {
		return m.Hints
	}
	return nil
}

func (m *LoginReply) GetOutStatuses() []*OutStatus {
	if m != nil {
		return m.OutStatuses
	}
	return nil
}

func (m *LoginReply) GetArea() int32 {
	if m != nil {
		return m.Area
	}
	return 0
}

func (m *LoginReply) GetChatPop() string {
	if m != nil {
		return m.ChatPop
	}
	return ""
}

func (m *LoginReply) GetNotice() *LoginNotice {
	if m != nil {
		return m.Notice
	}
	return nil
}

func (m *LoginReply) GetCountryFlag() string {
	if m != nil {
		return m.CountryFlag
	}
	return ""
}

type AccountLoginArg struct {
	Channel      string `protobuf:"bytes,1,opt,name=Channel,proto3" json:"Channel,omitempty"`
	ChannelID    string `protobuf:"bytes,2,opt,name=ChannelID,proto3" json:"ChannelID,omitempty"`
	Account      string `protobuf:"bytes,3,opt,name=Account,proto3" json:"Account,omitempty"`
	Password     string `protobuf:"bytes,4,opt,name=Password,proto3" json:"Password,omitempty"`
	SdkToken     string `protobuf:"bytes,5,opt,name=SdkToken,proto3" json:"SdkToken,omitempty"`
	IsTourist    bool   `protobuf:"varint,6,opt,name=IsTourist,proto3" json:"IsTourist,omitempty"`
	LoginChannel string `protobuf:"bytes,7,opt,name=LoginChannel,proto3" json:"LoginChannel,omitempty"`
	WxOpenID     string `protobuf:"bytes,8,opt,name=WxOpenID,proto3" json:"WxOpenID,omitempty"`
}

func (m *AccountLoginArg) Reset()                    { *m = AccountLoginArg{} }
func (m *AccountLoginArg) String() string            { return proto.CompactTextString(m) }
func (*AccountLoginArg) ProtoMessage()               {}
func (*AccountLoginArg) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{6} }

func (m *AccountLoginArg) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *AccountLoginArg) GetChannelID() string {
	if m != nil {
		return m.ChannelID
	}
	return ""
}

func (m *AccountLoginArg) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *AccountLoginArg) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *AccountLoginArg) GetSdkToken() string {
	if m != nil {
		return m.SdkToken
	}
	return ""
}

func (m *AccountLoginArg) GetIsTourist() bool {
	if m != nil {
		return m.IsTourist
	}
	return false
}

func (m *AccountLoginArg) GetLoginChannel() string {
	if m != nil {
		return m.LoginChannel
	}
	return ""
}

func (m *AccountLoginArg) GetWxOpenID() string {
	if m != nil {
		return m.WxOpenID
	}
	return ""
}

type Archive struct {
	ID       int32  `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Uid      uint64 `protobuf:"varint,2,opt,name=Uid,proto3" json:"Uid,omitempty"`
	LastTime uint32 `protobuf:"varint,3,opt,name=LastTime,proto3" json:"LastTime,omitempty"`
}

func (m *Archive) Reset()                    { *m = Archive{} }
func (m *Archive) String() string            { return proto.CompactTextString(m) }
func (*Archive) ProtoMessage()               {}
func (*Archive) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{7} }

func (m *Archive) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Archive) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *Archive) GetLastTime() uint32 {
	if m != nil {
		return m.LastTime
	}
	return 0
}

type GateHost struct {
	Host    string `protobuf:"bytes,1,opt,name=Host,proto3" json:"Host,omitempty"`
	Port    int32  `protobuf:"varint,2,opt,name=Port,proto3" json:"Port,omitempty"`
	WssPort int32  `protobuf:"varint,3,opt,name=WssPort,proto3" json:"WssPort,omitempty"`
}

func (m *GateHost) Reset()                    { *m = GateHost{} }
func (m *GateHost) String() string            { return proto.CompactTextString(m) }
func (*GateHost) ProtoMessage()               {}
func (*GateHost) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{8} }

func (m *GateHost) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *GateHost) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *GateHost) GetWssPort() int32 {
	if m != nil {
		return m.WssPort
	}
	return 0
}

type AccountArchives struct {
	Archives     []*Archive    `protobuf:"bytes,1,rep,name=Archives" json:"Archives,omitempty"`
	ServerSt     *ServerStatus `protobuf:"bytes,2,opt,name=ServerSt" json:"ServerSt,omitempty"`
	Ok           bool          `protobuf:"varint,3,opt,name=Ok,proto3" json:"Ok,omitempty"`
	RedirectHost *GateHost     `protobuf:"bytes,4,opt,name=RedirectHost" json:"RedirectHost,omitempty"`
}

func (m *AccountArchives) Reset()                    { *m = AccountArchives{} }
func (m *AccountArchives) String() string            { return proto.CompactTextString(m) }
func (*AccountArchives) ProtoMessage()               {}
func (*AccountArchives) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{9} }

func (m *AccountArchives) GetArchives() []*Archive {
	if m != nil {
		return m.Archives
	}
	return nil
}

func (m *AccountArchives) GetServerSt() *ServerStatus {
	if m != nil {
		return m.ServerSt
	}
	return nil
}

func (m *AccountArchives) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func (m *AccountArchives) GetRedirectHost() *GateHost {
	if m != nil {
		return m.RedirectHost
	}
	return nil
}

type RegisterAccount struct {
	Channel  string `protobuf:"bytes,1,opt,name=Channel,proto3" json:"Channel,omitempty"`
	Account  string `protobuf:"bytes,2,opt,name=Account,proto3" json:"Account,omitempty"`
	Password string `protobuf:"bytes,3,opt,name=Password,proto3" json:"Password,omitempty"`
}

func (m *RegisterAccount) Reset()                    { *m = RegisterAccount{} }
func (m *RegisterAccount) String() string            { return proto.CompactTextString(m) }
func (*RegisterAccount) ProtoMessage()               {}
func (*RegisterAccount) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{10} }

func (m *RegisterAccount) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *RegisterAccount) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *RegisterAccount) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type DelArchiveArg struct {
	Channel   string `protobuf:"bytes,1,opt,name=Channel,proto3" json:"Channel,omitempty"`
	ChannelID string `protobuf:"bytes,2,opt,name=ChannelID,proto3" json:"ChannelID,omitempty"`
	ArchiveID int32  `protobuf:"varint,3,opt,name=ArchiveID,proto3" json:"ArchiveID,omitempty"`
}

func (m *DelArchiveArg) Reset()                    { *m = DelArchiveArg{} }
func (m *DelArchiveArg) String() string            { return proto.CompactTextString(m) }
func (*DelArchiveArg) ProtoMessage()               {}
func (*DelArchiveArg) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{11} }

func (m *DelArchiveArg) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *DelArchiveArg) GetChannelID() string {
	if m != nil {
		return m.ChannelID
	}
	return ""
}

func (m *DelArchiveArg) GetArchiveID() int32 {
	if m != nil {
		return m.ArchiveID
	}
	return 0
}

type ResourceModify struct {
	Res []*Resource `protobuf:"bytes,1,rep,name=Res" json:"Res,omitempty"`
}

func (m *ResourceModify) Reset()                    { *m = ResourceModify{} }
func (m *ResourceModify) String() string            { return proto.CompactTextString(m) }
func (*ResourceModify) ProtoMessage()               {}
func (*ResourceModify) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{12} }

func (m *ResourceModify) GetRes() []*Resource {
	if m != nil {
		return m.Res
	}
	return nil
}

type ModifyNameArg struct {
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
}

func (m *ModifyNameArg) Reset()                    { *m = ModifyNameArg{} }
func (m *ModifyNameArg) String() string            { return proto.CompactTextString(m) }
func (*ModifyNameArg) ProtoMessage()               {}
func (*ModifyNameArg) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{13} }

func (m *ModifyNameArg) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type UpdateNameArg struct {
	Name string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
}

func (m *UpdateNameArg) Reset()                    { *m = UpdateNameArg{} }
func (m *UpdateNameArg) String() string            { return proto.CompactTextString(m) }
func (*UpdateNameArg) ProtoMessage()               {}
func (*UpdateNameArg) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{14} }

func (m *UpdateNameArg) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Version struct {
	V1 int32 `protobuf:"varint,1,opt,name=V1,proto3" json:"V1,omitempty"`
	V2 int32 `protobuf:"varint,2,opt,name=V2,proto3" json:"V2,omitempty"`
	V3 int32 `protobuf:"varint,3,opt,name=V3,proto3" json:"V3,omitempty"`
}

func (m *Version) Reset()                    { *m = Version{} }
func (m *Version) String() string            { return proto.CompactTextString(m) }
func (*Version) ProtoMessage()               {}
func (*Version) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{15} }

func (m *Version) GetV1() int32 {
	if m != nil {
		return m.V1
	}
	return 0
}

func (m *Version) GetV2() int32 {
	if m != nil {
		return m.V2
	}
	return 0
}

func (m *Version) GetV3() int32 {
	if m != nil {
		return m.V3
	}
	return 0
}

type LoadPlayerArg struct {
	Uid uint64 `protobuf:"varint,1,opt,name=Uid,proto3" json:"Uid,omitempty"`
}

func (m *LoadPlayerArg) Reset()                    { *m = LoadPlayerArg{} }
func (m *LoadPlayerArg) String() string            { return proto.CompactTextString(m) }
func (*LoadPlayerArg) ProtoMessage()               {}
func (*LoadPlayerArg) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{16} }

func (m *LoadPlayerArg) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

type SimplePlayerInfo struct {
	Name               string       `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	PvpScore           int32        `protobuf:"varint,2,opt,name=PvpScore,proto3" json:"PvpScore,omitempty"`
	HeadImgUrl         string       `protobuf:"bytes,3,opt,name=HeadImgUrl,proto3" json:"HeadImgUrl,omitempty"`
	FirstHandAmount    int32        `protobuf:"varint,4,opt,name=FirstHandAmount,proto3" json:"FirstHandAmount,omitempty"`
	BackHandAmount     int32        `protobuf:"varint,5,opt,name=BackHandAmount,proto3" json:"BackHandAmount,omitempty"`
	FirstHandWinAmount int32        `protobuf:"varint,6,opt,name=FirstHandWinAmount,proto3" json:"FirstHandWinAmount,omitempty"`
	BackHandWinAmount  int32        `protobuf:"varint,7,opt,name=BackHandWinAmount,proto3" json:"BackHandWinAmount,omitempty"`
	RankScore          int32        `protobuf:"varint,8,opt,name=RankScore,proto3" json:"RankScore,omitempty"`
	FavoriteCards      []*SkinGCard `protobuf:"bytes,9,rep,name=FavoriteCards" json:"FavoriteCards,omitempty"`
	FightCards         []*SkinGCard `protobuf:"bytes,10,rep,name=FightCards" json:"FightCards,omitempty"`
	IsWechatFriend     bool         `protobuf:"varint,11,opt,name=IsWechatFriend,proto3" json:"IsWechatFriend,omitempty"`
	IsOnline           bool         `protobuf:"varint,12,opt,name=IsOnline,proto3" json:"IsOnline,omitempty"`
	IsInBattle         bool         `protobuf:"varint,13,opt,name=IsInBattle,proto3" json:"IsInBattle,omitempty"`
	LastOnlineTime     int32        `protobuf:"varint,14,opt,name=LastOnlineTime,proto3" json:"LastOnlineTime,omitempty"`
	Uid                uint64       `protobuf:"varint,15,opt,name=Uid,proto3" json:"Uid,omitempty"`
	PvpCamp            int32        `protobuf:"varint,16,opt,name=PvpCamp,proto3" json:"PvpCamp,omitempty"`
	Country            string       `protobuf:"bytes,17,opt,name=Country,proto3" json:"Country,omitempty"`
	HeadFrame          string       `protobuf:"bytes,18,opt,name=HeadFrame,proto3" json:"HeadFrame,omitempty"`
	RebornCnt          int32        `protobuf:"varint,19,opt,name=RebornCnt,proto3" json:"RebornCnt,omitempty"`
	StatusIDs          []string     `protobuf:"bytes,20,rep,name=StatusIDs" json:"StatusIDs,omitempty"`
	CrossAreaHonor     int32        `protobuf:"varint,21,opt,name=CrossAreaHonor,proto3" json:"CrossAreaHonor,omitempty"`
	// int32 CrossAreaBlotHonor = 22;
	CountryFlag  string `protobuf:"bytes,23,opt,name=CountryFlag,proto3" json:"CountryFlag,omitempty"`
	Area         int32  `protobuf:"varint,24,opt,name=Area,proto3" json:"Area,omitempty"`
	MaxRankScore int32  `protobuf:"varint,25,opt,name=MaxRankScore,proto3" json:"MaxRankScore,omitempty"`
}

func (m *SimplePlayerInfo) Reset()                    { *m = SimplePlayerInfo{} }
func (m *SimplePlayerInfo) String() string            { return proto.CompactTextString(m) }
func (*SimplePlayerInfo) ProtoMessage()               {}
func (*SimplePlayerInfo) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{17} }

func (m *SimplePlayerInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SimplePlayerInfo) GetPvpScore() int32 {
	if m != nil {
		return m.PvpScore
	}
	return 0
}

func (m *SimplePlayerInfo) GetHeadImgUrl() string {
	if m != nil {
		return m.HeadImgUrl
	}
	return ""
}

func (m *SimplePlayerInfo) GetFirstHandAmount() int32 {
	if m != nil {
		return m.FirstHandAmount
	}
	return 0
}

func (m *SimplePlayerInfo) GetBackHandAmount() int32 {
	if m != nil {
		return m.BackHandAmount
	}
	return 0
}

func (m *SimplePlayerInfo) GetFirstHandWinAmount() int32 {
	if m != nil {
		return m.FirstHandWinAmount
	}
	return 0
}

func (m *SimplePlayerInfo) GetBackHandWinAmount() int32 {
	if m != nil {
		return m.BackHandWinAmount
	}
	return 0
}

func (m *SimplePlayerInfo) GetRankScore() int32 {
	if m != nil {
		return m.RankScore
	}
	return 0
}

func (m *SimplePlayerInfo) GetFavoriteCards() []*SkinGCard {
	if m != nil {
		return m.FavoriteCards
	}
	return nil
}

func (m *SimplePlayerInfo) GetFightCards() []*SkinGCard {
	if m != nil {
		return m.FightCards
	}
	return nil
}

func (m *SimplePlayerInfo) GetIsWechatFriend() bool {
	if m != nil {
		return m.IsWechatFriend
	}
	return false
}

func (m *SimplePlayerInfo) GetIsOnline() bool {
	if m != nil {
		return m.IsOnline
	}
	return false
}

func (m *SimplePlayerInfo) GetIsInBattle() bool {
	if m != nil {
		return m.IsInBattle
	}
	return false
}

func (m *SimplePlayerInfo) GetLastOnlineTime() int32 {
	if m != nil {
		return m.LastOnlineTime
	}
	return 0
}

func (m *SimplePlayerInfo) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *SimplePlayerInfo) GetPvpCamp() int32 {
	if m != nil {
		return m.PvpCamp
	}
	return 0
}

func (m *SimplePlayerInfo) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

func (m *SimplePlayerInfo) GetHeadFrame() string {
	if m != nil {
		return m.HeadFrame
	}
	return ""
}

func (m *SimplePlayerInfo) GetRebornCnt() int32 {
	if m != nil {
		return m.RebornCnt
	}
	return 0
}

func (m *SimplePlayerInfo) GetStatusIDs() []string {
	if m != nil {
		return m.StatusIDs
	}
	return nil
}

func (m *SimplePlayerInfo) GetCrossAreaHonor() int32 {
	if m != nil {
		return m.CrossAreaHonor
	}
	return 0
}

func (m *SimplePlayerInfo) GetCountryFlag() string {
	if m != nil {
		return m.CountryFlag
	}
	return ""
}

func (m *SimplePlayerInfo) GetArea() int32 {
	if m != nil {
		return m.Area
	}
	return 0
}

func (m *SimplePlayerInfo) GetMaxRankScore() int32 {
	if m != nil {
		return m.MaxRankScore
	}
	return 0
}

type SdkUserInfo struct {
	NickName   string `protobuf:"bytes,1,opt,name=NickName,proto3" json:"NickName,omitempty"`
	HeadImgUrl string `protobuf:"bytes,2,opt,name=HeadImgUrl,proto3" json:"HeadImgUrl,omitempty"`
	InviterUid uint64 `protobuf:"varint,3,opt,name=InviterUid,proto3" json:"InviterUid,omitempty"`
}

func (m *SdkUserInfo) Reset()                    { *m = SdkUserInfo{} }
func (m *SdkUserInfo) String() string            { return proto.CompactTextString(m) }
func (*SdkUserInfo) ProtoMessage()               {}
func (*SdkUserInfo) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{18} }

func (m *SdkUserInfo) GetNickName() string {
	if m != nil {
		return m.NickName
	}
	return ""
}

func (m *SdkUserInfo) GetHeadImgUrl() string {
	if m != nil {
		return m.HeadImgUrl
	}
	return ""
}

func (m *SdkUserInfo) GetInviterUid() uint64 {
	if m != nil {
		return m.InviterUid
	}
	return 0
}

type UpdateHeadImgArg struct {
	HeadImg string `protobuf:"bytes,1,opt,name=HeadImg,proto3" json:"HeadImg,omitempty"`
}

func (m *UpdateHeadImgArg) Reset()                    { *m = UpdateHeadImgArg{} }
func (m *UpdateHeadImgArg) String() string            { return proto.CompactTextString(m) }
func (*UpdateHeadImgArg) ProtoMessage()               {}
func (*UpdateHeadImgArg) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{19} }

func (m *UpdateHeadImgArg) GetHeadImg() string {
	if m != nil {
		return m.HeadImg
	}
	return ""
}

type TouristRegisterAccountArg struct {
	Channel string `protobuf:"bytes,1,opt,name=Channel,proto3" json:"Channel,omitempty"`
}

func (m *TouristRegisterAccountArg) Reset()                    { *m = TouristRegisterAccountArg{} }
func (m *TouristRegisterAccountArg) String() string            { return proto.CompactTextString(m) }
func (*TouristRegisterAccountArg) ProtoMessage()               {}
func (*TouristRegisterAccountArg) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{20} }

func (m *TouristRegisterAccountArg) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

type TouristRegisterAccountRelpy struct {
	Account  string `protobuf:"bytes,1,opt,name=Account,proto3" json:"Account,omitempty"`
	Password string `protobuf:"bytes,2,opt,name=Password,proto3" json:"Password,omitempty"`
}

func (m *TouristRegisterAccountRelpy) Reset()         { *m = TouristRegisterAccountRelpy{} }
func (m *TouristRegisterAccountRelpy) String() string { return proto.CompactTextString(m) }
func (*TouristRegisterAccountRelpy) ProtoMessage()    {}
func (*TouristRegisterAccountRelpy) Descriptor() ([]byte, []int) {
	return fileDescriptorPlayer, []int{21}
}

func (m *TouristRegisterAccountRelpy) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *TouristRegisterAccountRelpy) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

type TouristBindAccountArg struct {
	Channel         string           `protobuf:"bytes,1,opt,name=Channel,proto3" json:"Channel,omitempty"`
	TouristAccount  string           `protobuf:"bytes,2,opt,name=TouristAccount,proto3" json:"TouristAccount,omitempty"`
	TouristPassword string           `protobuf:"bytes,3,opt,name=TouristPassword,proto3" json:"TouristPassword,omitempty"`
	BindAccount     *AccountLoginArg `protobuf:"bytes,4,opt,name=BindAccount" json:"BindAccount,omitempty"`
}

func (m *TouristBindAccountArg) Reset()                    { *m = TouristBindAccountArg{} }
func (m *TouristBindAccountArg) String() string            { return proto.CompactTextString(m) }
func (*TouristBindAccountArg) ProtoMessage()               {}
func (*TouristBindAccountArg) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{22} }

func (m *TouristBindAccountArg) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *TouristBindAccountArg) GetTouristAccount() string {
	if m != nil {
		return m.TouristAccount
	}
	return ""
}

func (m *TouristBindAccountArg) GetTouristPassword() string {
	if m != nil {
		return m.TouristPassword
	}
	return ""
}

func (m *TouristBindAccountArg) GetBindAccount() *AccountLoginArg {
	if m != nil {
		return m.BindAccount
	}
	return nil
}

type FetchHeadFrameReply struct {
	HeadFrames []string `protobuf:"bytes,1,rep,name=HeadFrames" json:"HeadFrames,omitempty"`
}

func (m *FetchHeadFrameReply) Reset()                    { *m = FetchHeadFrameReply{} }
func (m *FetchHeadFrameReply) String() string            { return proto.CompactTextString(m) }
func (*FetchHeadFrameReply) ProtoMessage()               {}
func (*FetchHeadFrameReply) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{23} }

func (m *FetchHeadFrameReply) GetHeadFrames() []string {
	if m != nil {
		return m.HeadFrames
	}
	return nil
}

type UpdateHeadFrameArg struct {
	HeadFrame string `protobuf:"bytes,1,opt,name=HeadFrame,proto3" json:"HeadFrame,omitempty"`
}

func (m *UpdateHeadFrameArg) Reset()                    { *m = UpdateHeadFrameArg{} }
func (m *UpdateHeadFrameArg) String() string            { return proto.CompactTextString(m) }
func (*UpdateHeadFrameArg) ProtoMessage()               {}
func (*UpdateHeadFrameArg) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{24} }

func (m *UpdateHeadFrameArg) GetHeadFrame() string {
	if m != nil {
		return m.HeadFrame
	}
	return ""
}

type HeadData struct {
	// 曾经拥有过，但现在没有的卡，OnceCards + LoginReply.Cards 就是拥有过得所有卡，用于显示头像
	OnceCards []uint32 `protobuf:"varint,1,rep,packed,name=OnceCards" json:"OnceCards,omitempty"`
}

func (m *HeadData) Reset()                    { *m = HeadData{} }
func (m *HeadData) String() string            { return proto.CompactTextString(m) }
func (*HeadData) ProtoMessage()               {}
func (*HeadData) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{25} }

func (m *HeadData) GetOnceCards() []uint32 {
	if m != nil {
		return m.OnceCards
	}
	return nil
}

type EmojiData struct {
	EmojiTeams []int32 `protobuf:"varint,1,rep,packed,name=EmojiTeams" json:"EmojiTeams,omitempty"`
}

func (m *EmojiData) Reset()                    { *m = EmojiData{} }
func (m *EmojiData) String() string            { return proto.CompactTextString(m) }
func (*EmojiData) ProtoMessage()               {}
func (*EmojiData) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{26} }

func (m *EmojiData) GetEmojiTeams() []int32 {
	if m != nil {
		return m.EmojiTeams
	}
	return nil
}

type TellMe struct {
	Msg  string `protobuf:"bytes,1,opt,name=Msg,proto3" json:"Msg,omitempty"`
	Text int32  `protobuf:"varint,2,opt,name=Text,proto3" json:"Text,omitempty"`
}

func (m *TellMe) Reset()                    { *m = TellMe{} }
func (m *TellMe) String() string            { return proto.CompactTextString(m) }
func (*TellMe) ProtoMessage()               {}
func (*TellMe) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{27} }

func (m *TellMe) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *TellMe) GetText() int32 {
	if m != nil {
		return m.Text
	}
	return 0
}

type UnlockEmojiArg struct {
	EmojiTeam int32 `protobuf:"varint,1,opt,name=EmojiTeam,proto3" json:"EmojiTeam,omitempty"`
}

func (m *UnlockEmojiArg) Reset()                    { *m = UnlockEmojiArg{} }
func (m *UnlockEmojiArg) String() string            { return proto.CompactTextString(m) }
func (*UnlockEmojiArg) ProtoMessage()               {}
func (*UnlockEmojiArg) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{28} }

func (m *UnlockEmojiArg) GetEmojiTeam() int32 {
	if m != nil {
		return m.EmojiTeam
	}
	return 0
}

type VipRemainTime struct {
	RemainTime int32 `protobuf:"varint,1,opt,name=RemainTime,proto3" json:"RemainTime,omitempty"`
}

func (m *VipRemainTime) Reset()                    { *m = VipRemainTime{} }
func (m *VipRemainTime) String() string            { return proto.CompactTextString(m) }
func (*VipRemainTime) ProtoMessage()               {}
func (*VipRemainTime) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{29} }

func (m *VipRemainTime) GetRemainTime() int32 {
	if m != nil {
		return m.RemainTime
	}
	return 0
}

type MinVipRemainTime struct {
	RemainTime int32 `protobuf:"varint,1,opt,name=RemainTime,proto3" json:"RemainTime,omitempty"`
}

func (m *MinVipRemainTime) Reset()                    { *m = MinVipRemainTime{} }
func (m *MinVipRemainTime) String() string            { return proto.CompactTextString(m) }
func (*MinVipRemainTime) ProtoMessage()               {}
func (*MinVipRemainTime) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{30} }

func (m *MinVipRemainTime) GetRemainTime() int32 {
	if m != nil {
		return m.RemainTime
	}
	return 0
}

type AccountCode struct {
	Code string `protobuf:"bytes,1,opt,name=Code,proto3" json:"Code,omitempty"`
}

func (m *AccountCode) Reset()                    { *m = AccountCode{} }
func (m *AccountCode) String() string            { return proto.CompactTextString(m) }
func (*AccountCode) ProtoMessage()               {}
func (*AccountCode) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{31} }

func (m *AccountCode) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

type AccountCodePlayerInfo struct {
	Uid       uint64 `protobuf:"varint,1,opt,name=Uid,proto3" json:"Uid,omitempty"`
	Name      string `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	PvpScore  int32  `protobuf:"varint,3,opt,name=PvpScore,proto3" json:"PvpScore,omitempty"`
	HeadImg   string `protobuf:"bytes,4,opt,name=HeadImg,proto3" json:"HeadImg,omitempty"`
	HeadFrame string `protobuf:"bytes,5,opt,name=HeadFrame,proto3" json:"HeadFrame,omitempty"`
}

func (m *AccountCodePlayerInfo) Reset()                    { *m = AccountCodePlayerInfo{} }
func (m *AccountCodePlayerInfo) String() string            { return proto.CompactTextString(m) }
func (*AccountCodePlayerInfo) ProtoMessage()               {}
func (*AccountCodePlayerInfo) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{32} }

func (m *AccountCodePlayerInfo) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *AccountCodePlayerInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AccountCodePlayerInfo) GetPvpScore() int32 {
	if m != nil {
		return m.PvpScore
	}
	return 0
}

func (m *AccountCodePlayerInfo) GetHeadImg() string {
	if m != nil {
		return m.HeadImg
	}
	return ""
}

func (m *AccountCodePlayerInfo) GetHeadFrame() string {
	if m != nil {
		return m.HeadFrame
	}
	return ""
}

type FetchChatPopReply struct {
	ChatPops   []string `protobuf:"bytes,1,rep,name=ChatPops" json:"ChatPops,omitempty"`
	CurChatPop string   `protobuf:"bytes,2,opt,name=CurChatPop,proto3" json:"CurChatPop,omitempty"`
}

func (m *FetchChatPopReply) Reset()                    { *m = FetchChatPopReply{} }
func (m *FetchChatPopReply) String() string            { return proto.CompactTextString(m) }
func (*FetchChatPopReply) ProtoMessage()               {}
func (*FetchChatPopReply) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{33} }

func (m *FetchChatPopReply) GetChatPops() []string {
	if m != nil {
		return m.ChatPops
	}
	return nil
}

func (m *FetchChatPopReply) GetCurChatPop() string {
	if m != nil {
		return m.CurChatPop
	}
	return ""
}

type UpdateChatPopArg struct {
	ChatPop string `protobuf:"bytes,1,opt,name=ChatPop,proto3" json:"ChatPop,omitempty"`
}

func (m *UpdateChatPopArg) Reset()                    { *m = UpdateChatPopArg{} }
func (m *UpdateChatPopArg) String() string            { return proto.CompactTextString(m) }
func (*UpdateChatPopArg) ProtoMessage()               {}
func (*UpdateChatPopArg) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{34} }

func (m *UpdateChatPopArg) GetChatPop() string {
	if m != nil {
		return m.ChatPop
	}
	return ""
}

type AdultCertificationArg struct {
	IsAdult bool `protobuf:"varint,1,opt,name=IsAdult,proto3" json:"IsAdult,omitempty"`
}

func (m *AdultCertificationArg) Reset()                    { *m = AdultCertificationArg{} }
func (m *AdultCertificationArg) String() string            { return proto.CompactTextString(m) }
func (*AdultCertificationArg) ProtoMessage()               {}
func (*AdultCertificationArg) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{35} }

func (m *AdultCertificationArg) GetIsAdult() bool {
	if m != nil {
		return m.IsAdult
	}
	return false
}

type UpdateSimplePlayerArg struct {
	Uid        uint64 `protobuf:"varint,1,opt,name=Uid,proto3" json:"Uid,omitempty"`
	Name       string `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	HeadImgUrl string `protobuf:"bytes,3,opt,name=HeadImgUrl,proto3" json:"HeadImgUrl,omitempty"`
	PvpScore   int32  `protobuf:"varint,4,opt,name=PvpScore,proto3" json:"PvpScore,omitempty"`
	HeadFrame  string `protobuf:"bytes,5,opt,name=HeadFrame,proto3" json:"HeadFrame,omitempty"`
}

func (m *UpdateSimplePlayerArg) Reset()                    { *m = UpdateSimplePlayerArg{} }
func (m *UpdateSimplePlayerArg) String() string            { return proto.CompactTextString(m) }
func (*UpdateSimplePlayerArg) ProtoMessage()               {}
func (*UpdateSimplePlayerArg) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{36} }

func (m *UpdateSimplePlayerArg) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *UpdateSimplePlayerArg) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UpdateSimplePlayerArg) GetHeadImgUrl() string {
	if m != nil {
		return m.HeadImgUrl
	}
	return ""
}

func (m *UpdateSimplePlayerArg) GetPvpScore() int32 {
	if m != nil {
		return m.PvpScore
	}
	return 0
}

func (m *UpdateSimplePlayerArg) GetHeadFrame() string {
	if m != nil {
		return m.HeadFrame
	}
	return ""
}

type OnBindAccountArg struct {
	AccountID  string `protobuf:"bytes,1,opt,name=AccountID,proto3" json:"AccountID,omitempty"`
	BindRegion uint32 `protobuf:"varint,2,opt,name=BindRegion,proto3" json:"BindRegion,omitempty"`
}

func (m *OnBindAccountArg) Reset()                    { *m = OnBindAccountArg{} }
func (m *OnBindAccountArg) String() string            { return proto.CompactTextString(m) }
func (*OnBindAccountArg) ProtoMessage()               {}
func (*OnBindAccountArg) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{37} }

func (m *OnBindAccountArg) GetAccountID() string {
	if m != nil {
		return m.AccountID
	}
	return ""
}

func (m *OnBindAccountArg) GetBindRegion() uint32 {
	if m != nil {
		return m.BindRegion
	}
	return 0
}

type LoginNoticeData struct {
	Title   string `protobuf:"bytes,1,opt,name=Title,proto3" json:"Title,omitempty"`
	Content string `protobuf:"bytes,2,opt,name=Content,proto3" json:"Content,omitempty"`
}

func (m *LoginNoticeData) Reset()                    { *m = LoginNoticeData{} }
func (m *LoginNoticeData) String() string            { return proto.CompactTextString(m) }
func (*LoginNoticeData) ProtoMessage()               {}
func (*LoginNoticeData) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{38} }

func (m *LoginNoticeData) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *LoginNoticeData) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

type LoginNotice struct {
	Version int32              `protobuf:"varint,1,opt,name=Version,proto3" json:"Version,omitempty"`
	Notices []*LoginNoticeData `protobuf:"bytes,2,rep,name=Notices" json:"Notices,omitempty"`
}

func (m *LoginNotice) Reset()                    { *m = LoginNotice{} }
func (m *LoginNotice) String() string            { return proto.CompactTextString(m) }
func (*LoginNotice) ProtoMessage()               {}
func (*LoginNotice) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{39} }

func (m *LoginNotice) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *LoginNotice) GetNotices() []*LoginNoticeData {
	if m != nil {
		return m.Notices
	}
	return nil
}

type OnLoginNoticeShowArg struct {
	Version int32 `protobuf:"varint,1,opt,name=Version,proto3" json:"Version,omitempty"`
}

func (m *OnLoginNoticeShowArg) Reset()                    { *m = OnLoginNoticeShowArg{} }
func (m *OnLoginNoticeShowArg) String() string            { return proto.CompactTextString(m) }
func (*OnLoginNoticeShowArg) ProtoMessage()               {}
func (*OnLoginNoticeShowArg) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{40} }

func (m *OnLoginNoticeShowArg) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

type UpdateNationalFlagArg struct {
	CountryFlag string `protobuf:"bytes,1,opt,name=CountryFlag,proto3" json:"CountryFlag,omitempty"`
}

func (m *UpdateNationalFlagArg) Reset()                    { *m = UpdateNationalFlagArg{} }
func (m *UpdateNationalFlagArg) String() string            { return proto.CompactTextString(m) }
func (*UpdateNationalFlagArg) ProtoMessage()               {}
func (*UpdateNationalFlagArg) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{41} }

func (m *UpdateNationalFlagArg) GetCountryFlag() string {
	if m != nil {
		return m.CountryFlag
	}
	return ""
}

type UpdateCountryFlagRemainTime struct {
	RemainTime int32 `protobuf:"varint,1,opt,name=RemainTime,proto3" json:"RemainTime,omitempty"`
}

func (m *UpdateCountryFlagRemainTime) Reset()         { *m = UpdateCountryFlagRemainTime{} }
func (m *UpdateCountryFlagRemainTime) String() string { return proto.CompactTextString(m) }
func (*UpdateCountryFlagRemainTime) ProtoMessage()    {}
func (*UpdateCountryFlagRemainTime) Descriptor() ([]byte, []int) {
	return fileDescriptorPlayer, []int{42}
}

func (m *UpdateCountryFlagRemainTime) GetRemainTime() int32 {
	if m != nil {
		return m.RemainTime
	}
	return 0
}

type Pong struct {
	ServerTime int32 `protobuf:"varint,1,opt,name=ServerTime,proto3" json:"ServerTime,omitempty"`
}

func (m *Pong) Reset()                    { *m = Pong{} }
func (m *Pong) String() string            { return proto.CompactTextString(m) }
func (*Pong) ProtoMessage()               {}
func (*Pong) Descriptor() ([]byte, []int) { return fileDescriptorPlayer, []int{43} }

func (m *Pong) GetServerTime() int32 {
	if m != nil {
		return m.ServerTime
	}
	return 0
}

func init() {
	proto.RegisterType((*KickOut)(nil), "pb.KickOut")
	proto.RegisterType((*FinishGuide)(nil), "pb.FinishGuide")
	proto.RegisterType((*AllFinishGuide)(nil), "pb.AllFinishGuide")
	proto.RegisterType((*GuideGroup)(nil), "pb.GuideGroup")
	proto.RegisterType((*LoginArg)(nil), "pb.LoginArg")
	proto.RegisterType((*LoginReply)(nil), "pb.LoginReply")
	proto.RegisterType((*AccountLoginArg)(nil), "pb.AccountLoginArg")
	proto.RegisterType((*Archive)(nil), "pb.Archive")
	proto.RegisterType((*GateHost)(nil), "pb.GateHost")
	proto.RegisterType((*AccountArchives)(nil), "pb.AccountArchives")
	proto.RegisterType((*RegisterAccount)(nil), "pb.RegisterAccount")
	proto.RegisterType((*DelArchiveArg)(nil), "pb.DelArchiveArg")
	proto.RegisterType((*ResourceModify)(nil), "pb.ResourceModify")
	proto.RegisterType((*ModifyNameArg)(nil), "pb.ModifyNameArg")
	proto.RegisterType((*UpdateNameArg)(nil), "pb.UpdateNameArg")
	proto.RegisterType((*Version)(nil), "pb.Version")
	proto.RegisterType((*LoadPlayerArg)(nil), "pb.LoadPlayerArg")
	proto.RegisterType((*SimplePlayerInfo)(nil), "pb.SimplePlayerInfo")
	proto.RegisterType((*SdkUserInfo)(nil), "pb.SdkUserInfo")
	proto.RegisterType((*UpdateHeadImgArg)(nil), "pb.UpdateHeadImgArg")
	proto.RegisterType((*TouristRegisterAccountArg)(nil), "pb.TouristRegisterAccountArg")
	proto.RegisterType((*TouristRegisterAccountRelpy)(nil), "pb.TouristRegisterAccountRelpy")
	proto.RegisterType((*TouristBindAccountArg)(nil), "pb.TouristBindAccountArg")
	proto.RegisterType((*FetchHeadFrameReply)(nil), "pb.FetchHeadFrameReply")
	proto.RegisterType((*UpdateHeadFrameArg)(nil), "pb.UpdateHeadFrameArg")
	proto.RegisterType((*HeadData)(nil), "pb.HeadData")
	proto.RegisterType((*EmojiData)(nil), "pb.EmojiData")
	proto.RegisterType((*TellMe)(nil), "pb.TellMe")
	proto.RegisterType((*UnlockEmojiArg)(nil), "pb.UnlockEmojiArg")
	proto.RegisterType((*VipRemainTime)(nil), "pb.VipRemainTime")
	proto.RegisterType((*MinVipRemainTime)(nil), "pb.MinVipRemainTime")
	proto.RegisterType((*AccountCode)(nil), "pb.AccountCode")
	proto.RegisterType((*AccountCodePlayerInfo)(nil), "pb.AccountCodePlayerInfo")
	proto.RegisterType((*FetchChatPopReply)(nil), "pb.FetchChatPopReply")
	proto.RegisterType((*UpdateChatPopArg)(nil), "pb.UpdateChatPopArg")
	proto.RegisterType((*AdultCertificationArg)(nil), "pb.AdultCertificationArg")
	proto.RegisterType((*UpdateSimplePlayerArg)(nil), "pb.UpdateSimplePlayerArg")
	proto.RegisterType((*OnBindAccountArg)(nil), "pb.OnBindAccountArg")
	proto.RegisterType((*LoginNoticeData)(nil), "pb.LoginNoticeData")
	proto.RegisterType((*LoginNotice)(nil), "pb.LoginNotice")
	proto.RegisterType((*OnLoginNoticeShowArg)(nil), "pb.OnLoginNoticeShowArg")
	proto.RegisterType((*UpdateNationalFlagArg)(nil), "pb.UpdateNationalFlagArg")
	proto.RegisterType((*UpdateCountryFlagRemainTime)(nil), "pb.UpdateCountryFlagRemainTime")
	proto.RegisterType((*Pong)(nil), "pb.Pong")
	proto.RegisterEnum("pb.AccountTypeEnum", AccountTypeEnum_name, AccountTypeEnum_value)
}
func (m *KickOut) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KickOut) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Reason != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.Reason))
	}
	return i, nil
}

func (m *FinishGuide) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FinishGuide) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GuideID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.GuideID))
	}
	return i, nil
}

func (m *AllFinishGuide) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllFinishGuide) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.GuideIDs) > 0 {
		dAtA2 := make([]byte, len(m.GuideIDs)*10)
		var j1 int
		for _, num1 := range m.GuideIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *GuideGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GuideGroup) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GroupID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.GroupID))
	}
	return i, nil
}

func (m *LoginArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ArchiveID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.ArchiveID))
	}
	if len(m.Channel) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if len(m.ChannelID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.ChannelID)))
		i += copy(dAtA[i:], m.ChannelID)
	}
	if m.AccountType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.AccountType))
	}
	if m.IsTourist {
		dAtA[i] = 0x28
		i++
		if m.IsTourist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.LoginChannel) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.LoginChannel)))
		i += copy(dAtA[i:], m.LoginChannel)
	}
	if len(m.Country) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Country)))
		i += copy(dAtA[i:], m.Country)
	}
	if len(m.SubChannel) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.SubChannel)))
		i += copy(dAtA[i:], m.SubChannel)
	}
	return i, nil
}

func (m *LoginReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.Uid))
	}
	if len(m.Cards) > 0 {
		for _, msg := range m.Cards {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPlayer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Res) > 0 {
		for _, msg := range m.Res {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintPlayer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DiyCards) > 0 {
		for _, msg := range m.DiyCards {
			dAtA[i] = 0x22
			i++
			i = encodeVarintPlayer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.FightID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.FightID))
	}
	if len(m.ServerID) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.ServerID)))
		i += copy(dAtA[i:], m.ServerID)
	}
	if m.GuideCamp != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.GuideCamp))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Ver != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.Ver.Size()))
		n3, err := m.Ver.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.IsExamined {
		dAtA[i] = 0x50
		i++
		if m.IsExamined {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.HeadImg) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.HeadImg)))
		i += copy(dAtA[i:], m.HeadImg)
	}
	if m.CumulativePay != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.CumulativePay))
	}
	if m.SharedState != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.SharedState))
	}
	if m.SeasonPvpLimitTime != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.SeasonPvpLimitTime))
	}
	if len(m.CardSkins) > 0 {
		for _, s := range m.CardSkins {
			dAtA[i] = 0x7a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.HeadFrame) > 0 {
		dAtA[i] = 0x82
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.HeadFrame)))
		i += copy(dAtA[i:], m.HeadFrame)
	}
	if m.IsSeasonPvpChooseCard {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		if m.IsSeasonPvpChooseCard {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsInCampaignMatch {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		if m.IsInCampaignMatch {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Huodongs) > 0 {
		for _, msg := range m.Huodongs {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintPlayer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.RebornCnt != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.RebornCnt))
	}
	if len(m.Hints) > 0 {
		for _, msg := range m.Hints {
			dAtA[i] = 0xaa
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintPlayer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OutStatuses) > 0 {
		for _, msg := range m.OutStatuses {
			dAtA[i] = 0xb2
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintPlayer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Area != 0 {
		dAtA[i] = 0xb8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.Area))
	}
	if len(m.ChatPop) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.ChatPop)))
		i += copy(dAtA[i:], m.ChatPop)
	}
	if m.Notice != nil {
		dAtA[i] = 0xca
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.Notice.Size()))
		n4, err := m.Notice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.CountryFlag) > 0 {
		dAtA[i] = 0xd2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.CountryFlag)))
		i += copy(dAtA[i:], m.CountryFlag)
	}
	return i, nil
}

func (m *AccountLoginArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountLoginArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Channel) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if len(m.ChannelID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.ChannelID)))
		i += copy(dAtA[i:], m.ChannelID)
	}
	if len(m.Account) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Account)))
		i += copy(dAtA[i:], m.Account)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	if len(m.SdkToken) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.SdkToken)))
		i += copy(dAtA[i:], m.SdkToken)
	}
	if m.IsTourist {
		dAtA[i] = 0x30
		i++
		if m.IsTourist {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.LoginChannel) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.LoginChannel)))
		i += copy(dAtA[i:], m.LoginChannel)
	}
	if len(m.WxOpenID) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.WxOpenID)))
		i += copy(dAtA[i:], m.WxOpenID)
	}
	return i, nil
}

func (m *Archive) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Archive) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.ID))
	}
	if m.Uid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.Uid))
	}
	if m.LastTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.LastTime))
	}
	return i, nil
}

func (m *GateHost) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GateHost) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Host) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Host)))
		i += copy(dAtA[i:], m.Host)
	}
	if m.Port != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.Port))
	}
	if m.WssPort != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.WssPort))
	}
	return i, nil
}

func (m *AccountArchives) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountArchives) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Archives) > 0 {
		for _, msg := range m.Archives {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPlayer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ServerSt != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.ServerSt.Size()))
		n5, err := m.ServerSt.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Ok {
		dAtA[i] = 0x18
		i++
		if m.Ok {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.RedirectHost != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.RedirectHost.Size()))
		n6, err := m.RedirectHost.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *RegisterAccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterAccount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Channel) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if len(m.Account) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Account)))
		i += copy(dAtA[i:], m.Account)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	return i, nil
}

func (m *DelArchiveArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelArchiveArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Channel) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if len(m.ChannelID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.ChannelID)))
		i += copy(dAtA[i:], m.ChannelID)
	}
	if m.ArchiveID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.ArchiveID))
	}
	return i, nil
}

func (m *ResourceModify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceModify) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Res) > 0 {
		for _, msg := range m.Res {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPlayer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ModifyNameArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModifyNameArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *UpdateNameArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateNameArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *Version) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Version) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.V1 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.V1))
	}
	if m.V2 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.V2))
	}
	if m.V3 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.V3))
	}
	return i, nil
}

func (m *LoadPlayerArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadPlayerArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.Uid))
	}
	return i, nil
}

func (m *SimplePlayerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimplePlayerInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.PvpScore != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.PvpScore))
	}
	if len(m.HeadImgUrl) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.HeadImgUrl)))
		i += copy(dAtA[i:], m.HeadImgUrl)
	}
	if m.FirstHandAmount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.FirstHandAmount))
	}
	if m.BackHandAmount != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.BackHandAmount))
	}
	if m.FirstHandWinAmount != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.FirstHandWinAmount))
	}
	if m.BackHandWinAmount != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.BackHandWinAmount))
	}
	if m.RankScore != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.RankScore))
	}
	if len(m.FavoriteCards) > 0 {
		for _, msg := range m.FavoriteCards {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintPlayer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.FightCards) > 0 {
		for _, msg := range m.FightCards {
			dAtA[i] = 0x52
			i++
			i = encodeVarintPlayer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.IsWechatFriend {
		dAtA[i] = 0x58
		i++
		if m.IsWechatFriend {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsOnline {
		dAtA[i] = 0x60
		i++
		if m.IsOnline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsInBattle {
		dAtA[i] = 0x68
		i++
		if m.IsInBattle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LastOnlineTime != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.LastOnlineTime))
	}
	if m.Uid != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.Uid))
	}
	if m.PvpCamp != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.PvpCamp))
	}
	if len(m.Country) > 0 {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Country)))
		i += copy(dAtA[i:], m.Country)
	}
	if len(m.HeadFrame) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.HeadFrame)))
		i += copy(dAtA[i:], m.HeadFrame)
	}
	if m.RebornCnt != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.RebornCnt))
	}
	if len(m.StatusIDs) > 0 {
		for _, s := range m.StatusIDs {
			dAtA[i] = 0xa2
			i++
			dAtA[i] = 0x1
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.CrossAreaHonor != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.CrossAreaHonor))
	}
	if len(m.CountryFlag) > 0 {
		dAtA[i] = 0xba
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.CountryFlag)))
		i += copy(dAtA[i:], m.CountryFlag)
	}
	if m.Area != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.Area))
	}
	if m.MaxRankScore != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.MaxRankScore))
	}
	return i, nil
}

func (m *SdkUserInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SdkUserInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.NickName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.NickName)))
		i += copy(dAtA[i:], m.NickName)
	}
	if len(m.HeadImgUrl) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.HeadImgUrl)))
		i += copy(dAtA[i:], m.HeadImgUrl)
	}
	if m.InviterUid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.InviterUid))
	}
	return i, nil
}

func (m *UpdateHeadImgArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateHeadImgArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HeadImg) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.HeadImg)))
		i += copy(dAtA[i:], m.HeadImg)
	}
	return i, nil
}

func (m *TouristRegisterAccountArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TouristRegisterAccountArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Channel) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	return i, nil
}

func (m *TouristRegisterAccountRelpy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TouristRegisterAccountRelpy) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Account) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Account)))
		i += copy(dAtA[i:], m.Account)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	return i, nil
}

func (m *TouristBindAccountArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TouristBindAccountArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Channel) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Channel)))
		i += copy(dAtA[i:], m.Channel)
	}
	if len(m.TouristAccount) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.TouristAccount)))
		i += copy(dAtA[i:], m.TouristAccount)
	}
	if len(m.TouristPassword) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.TouristPassword)))
		i += copy(dAtA[i:], m.TouristPassword)
	}
	if m.BindAccount != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.BindAccount.Size()))
		n7, err := m.BindAccount.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *FetchHeadFrameReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchHeadFrameReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HeadFrames) > 0 {
		for _, s := range m.HeadFrames {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *UpdateHeadFrameArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateHeadFrameArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.HeadFrame) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.HeadFrame)))
		i += copy(dAtA[i:], m.HeadFrame)
	}
	return i, nil
}

func (m *HeadData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeadData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OnceCards) > 0 {
		dAtA9 := make([]byte, len(m.OnceCards)*10)
		var j8 int
		for _, num := range m.OnceCards {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(j8))
		i += copy(dAtA[i:], dAtA9[:j8])
	}
	return i, nil
}

func (m *EmojiData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EmojiData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EmojiTeams) > 0 {
		dAtA11 := make([]byte, len(m.EmojiTeams)*10)
		var j10 int
		for _, num1 := range m.EmojiTeams {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(j10))
		i += copy(dAtA[i:], dAtA11[:j10])
	}
	return i, nil
}

func (m *TellMe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TellMe) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.Text != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.Text))
	}
	return i, nil
}

func (m *UnlockEmojiArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnlockEmojiArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EmojiTeam != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.EmojiTeam))
	}
	return i, nil
}

func (m *VipRemainTime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VipRemainTime) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RemainTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.RemainTime))
	}
	return i, nil
}

func (m *MinVipRemainTime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MinVipRemainTime) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RemainTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.RemainTime))
	}
	return i, nil
}

func (m *AccountCode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountCode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Code) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Code)))
		i += copy(dAtA[i:], m.Code)
	}
	return i, nil
}

func (m *AccountCodePlayerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountCodePlayerInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.Uid))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.PvpScore != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.PvpScore))
	}
	if len(m.HeadImg) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.HeadImg)))
		i += copy(dAtA[i:], m.HeadImg)
	}
	if len(m.HeadFrame) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.HeadFrame)))
		i += copy(dAtA[i:], m.HeadFrame)
	}
	return i, nil
}

func (m *FetchChatPopReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchChatPopReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatPops) > 0 {
		for _, s := range m.ChatPops {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.CurChatPop) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.CurChatPop)))
		i += copy(dAtA[i:], m.CurChatPop)
	}
	return i, nil
}

func (m *UpdateChatPopArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateChatPopArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChatPop) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.ChatPop)))
		i += copy(dAtA[i:], m.ChatPop)
	}
	return i, nil
}

func (m *AdultCertificationArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdultCertificationArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsAdult {
		dAtA[i] = 0x8
		i++
		if m.IsAdult {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *UpdateSimplePlayerArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateSimplePlayerArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.Uid))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.HeadImgUrl) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.HeadImgUrl)))
		i += copy(dAtA[i:], m.HeadImgUrl)
	}
	if m.PvpScore != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.PvpScore))
	}
	if len(m.HeadFrame) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.HeadFrame)))
		i += copy(dAtA[i:], m.HeadFrame)
	}
	return i, nil
}

func (m *OnBindAccountArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OnBindAccountArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AccountID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.AccountID)))
		i += copy(dAtA[i:], m.AccountID)
	}
	if m.BindRegion != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.BindRegion))
	}
	return i, nil
}

func (m *LoginNoticeData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginNoticeData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Title) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	return i, nil
}

func (m *LoginNotice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginNotice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.Version))
	}
	if len(m.Notices) > 0 {
		for _, msg := range m.Notices {
			dAtA[i] = 0x12
			i++
			i = encodeVarintPlayer(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *OnLoginNoticeShowArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OnLoginNoticeShowArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.Version))
	}
	return i, nil
}

func (m *UpdateNationalFlagArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateNationalFlagArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CountryFlag) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(len(m.CountryFlag)))
		i += copy(dAtA[i:], m.CountryFlag)
	}
	return i, nil
}

func (m *UpdateCountryFlagRemainTime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateCountryFlagRemainTime) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RemainTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.RemainTime))
	}
	return i, nil
}

func (m *Pong) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pong) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ServerTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlayer(dAtA, i, uint64(m.ServerTime))
	}
	return i, nil
}

func encodeVarintPlayer(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *KickOut) Size() (n int) {
	var l int
	_ = l
	if m.Reason != 0 {
		n += 1 + sovPlayer(uint64(m.Reason))
	}
	return n
}

func (m *FinishGuide) Size() (n int) {
	var l int
	_ = l
	if m.GuideID != 0 {
		n += 1 + sovPlayer(uint64(m.GuideID))
	}
	return n
}

func (m *AllFinishGuide) Size() (n int) {
	var l int
	_ = l
	if len(m.GuideIDs) > 0 {
		l = 0
		for _, e := range m.GuideIDs {
			l += sovPlayer(uint64(e))
		}
		n += 1 + sovPlayer(uint64(l)) + l
	}
	return n
}

func (m *GuideGroup) Size() (n int) {
	var l int
	_ = l
	if m.GroupID != 0 {
		n += 1 + sovPlayer(uint64(m.GroupID))
	}
	return n
}

func (m *LoginArg) Size() (n int) {
	var l int
	_ = l
	if m.ArchiveID != 0 {
		n += 1 + sovPlayer(uint64(m.ArchiveID))
	}
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	l = len(m.ChannelID)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	if m.AccountType != 0 {
		n += 1 + sovPlayer(uint64(m.AccountType))
	}
	if m.IsTourist {
		n += 2
	}
	l = len(m.LoginChannel)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	l = len(m.Country)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	l = len(m.SubChannel)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *LoginReply) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovPlayer(uint64(m.Uid))
	}
	if len(m.Cards) > 0 {
		for _, e := range m.Cards {
			l = e.Size()
			n += 1 + l + sovPlayer(uint64(l))
		}
	}
	if len(m.Res) > 0 {
		for _, e := range m.Res {
			l = e.Size()
			n += 1 + l + sovPlayer(uint64(l))
		}
	}
	if len(m.DiyCards) > 0 {
		for _, e := range m.DiyCards {
			l = e.Size()
			n += 1 + l + sovPlayer(uint64(l))
		}
	}
	if m.FightID != 0 {
		n += 1 + sovPlayer(uint64(m.FightID))
	}
	l = len(m.ServerID)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	if m.GuideCamp != 0 {
		n += 1 + sovPlayer(uint64(m.GuideCamp))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	if m.Ver != nil {
		l = m.Ver.Size()
		n += 1 + l + sovPlayer(uint64(l))
	}
	if m.IsExamined {
		n += 2
	}
	l = len(m.HeadImg)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	if m.CumulativePay != 0 {
		n += 1 + sovPlayer(uint64(m.CumulativePay))
	}
	if m.SharedState != 0 {
		n += 1 + sovPlayer(uint64(m.SharedState))
	}
	if m.SeasonPvpLimitTime != 0 {
		n += 1 + sovPlayer(uint64(m.SeasonPvpLimitTime))
	}
	if len(m.CardSkins) > 0 {
		for _, s := range m.CardSkins {
			l = len(s)
			n += 1 + l + sovPlayer(uint64(l))
		}
	}
	l = len(m.HeadFrame)
	if l > 0 {
		n += 2 + l + sovPlayer(uint64(l))
	}
	if m.IsSeasonPvpChooseCard {
		n += 3
	}
	if m.IsInCampaignMatch {
		n += 3
	}
	if len(m.Huodongs) > 0 {
		for _, e := range m.Huodongs {
			l = e.Size()
			n += 2 + l + sovPlayer(uint64(l))
		}
	}
	if m.RebornCnt != 0 {
		n += 2 + sovPlayer(uint64(m.RebornCnt))
	}
	if len(m.Hints) > 0 {
		for _, e := range m.Hints {
			l = e.Size()
			n += 2 + l + sovPlayer(uint64(l))
		}
	}
	if len(m.OutStatuses) > 0 {
		for _, e := range m.OutStatuses {
			l = e.Size()
			n += 2 + l + sovPlayer(uint64(l))
		}
	}
	if m.Area != 0 {
		n += 2 + sovPlayer(uint64(m.Area))
	}
	l = len(m.ChatPop)
	if l > 0 {
		n += 2 + l + sovPlayer(uint64(l))
	}
	if m.Notice != nil {
		l = m.Notice.Size()
		n += 2 + l + sovPlayer(uint64(l))
	}
	l = len(m.CountryFlag)
	if l > 0 {
		n += 2 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *AccountLoginArg) Size() (n int) {
	var l int
	_ = l
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	l = len(m.ChannelID)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	l = len(m.SdkToken)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	if m.IsTourist {
		n += 2
	}
	l = len(m.LoginChannel)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	l = len(m.WxOpenID)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *Archive) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovPlayer(uint64(m.ID))
	}
	if m.Uid != 0 {
		n += 1 + sovPlayer(uint64(m.Uid))
	}
	if m.LastTime != 0 {
		n += 1 + sovPlayer(uint64(m.LastTime))
	}
	return n
}

func (m *GateHost) Size() (n int) {
	var l int
	_ = l
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovPlayer(uint64(m.Port))
	}
	if m.WssPort != 0 {
		n += 1 + sovPlayer(uint64(m.WssPort))
	}
	return n
}

func (m *AccountArchives) Size() (n int) {
	var l int
	_ = l
	if len(m.Archives) > 0 {
		for _, e := range m.Archives {
			l = e.Size()
			n += 1 + l + sovPlayer(uint64(l))
		}
	}
	if m.ServerSt != nil {
		l = m.ServerSt.Size()
		n += 1 + l + sovPlayer(uint64(l))
	}
	if m.Ok {
		n += 2
	}
	if m.RedirectHost != nil {
		l = m.RedirectHost.Size()
		n += 1 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *RegisterAccount) Size() (n int) {
	var l int
	_ = l
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *DelArchiveArg) Size() (n int) {
	var l int
	_ = l
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	l = len(m.ChannelID)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	if m.ArchiveID != 0 {
		n += 1 + sovPlayer(uint64(m.ArchiveID))
	}
	return n
}

func (m *ResourceModify) Size() (n int) {
	var l int
	_ = l
	if len(m.Res) > 0 {
		for _, e := range m.Res {
			l = e.Size()
			n += 1 + l + sovPlayer(uint64(l))
		}
	}
	return n
}

func (m *ModifyNameArg) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *UpdateNameArg) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *Version) Size() (n int) {
	var l int
	_ = l
	if m.V1 != 0 {
		n += 1 + sovPlayer(uint64(m.V1))
	}
	if m.V2 != 0 {
		n += 1 + sovPlayer(uint64(m.V2))
	}
	if m.V3 != 0 {
		n += 1 + sovPlayer(uint64(m.V3))
	}
	return n
}

func (m *LoadPlayerArg) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovPlayer(uint64(m.Uid))
	}
	return n
}

func (m *SimplePlayerInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	if m.PvpScore != 0 {
		n += 1 + sovPlayer(uint64(m.PvpScore))
	}
	l = len(m.HeadImgUrl)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	if m.FirstHandAmount != 0 {
		n += 1 + sovPlayer(uint64(m.FirstHandAmount))
	}
	if m.BackHandAmount != 0 {
		n += 1 + sovPlayer(uint64(m.BackHandAmount))
	}
	if m.FirstHandWinAmount != 0 {
		n += 1 + sovPlayer(uint64(m.FirstHandWinAmount))
	}
	if m.BackHandWinAmount != 0 {
		n += 1 + sovPlayer(uint64(m.BackHandWinAmount))
	}
	if m.RankScore != 0 {
		n += 1 + sovPlayer(uint64(m.RankScore))
	}
	if len(m.FavoriteCards) > 0 {
		for _, e := range m.FavoriteCards {
			l = e.Size()
			n += 1 + l + sovPlayer(uint64(l))
		}
	}
	if len(m.FightCards) > 0 {
		for _, e := range m.FightCards {
			l = e.Size()
			n += 1 + l + sovPlayer(uint64(l))
		}
	}
	if m.IsWechatFriend {
		n += 2
	}
	if m.IsOnline {
		n += 2
	}
	if m.IsInBattle {
		n += 2
	}
	if m.LastOnlineTime != 0 {
		n += 1 + sovPlayer(uint64(m.LastOnlineTime))
	}
	if m.Uid != 0 {
		n += 1 + sovPlayer(uint64(m.Uid))
	}
	if m.PvpCamp != 0 {
		n += 2 + sovPlayer(uint64(m.PvpCamp))
	}
	l = len(m.Country)
	if l > 0 {
		n += 2 + l + sovPlayer(uint64(l))
	}
	l = len(m.HeadFrame)
	if l > 0 {
		n += 2 + l + sovPlayer(uint64(l))
	}
	if m.RebornCnt != 0 {
		n += 2 + sovPlayer(uint64(m.RebornCnt))
	}
	if len(m.StatusIDs) > 0 {
		for _, s := range m.StatusIDs {
			l = len(s)
			n += 2 + l + sovPlayer(uint64(l))
		}
	}
	if m.CrossAreaHonor != 0 {
		n += 2 + sovPlayer(uint64(m.CrossAreaHonor))
	}
	l = len(m.CountryFlag)
	if l > 0 {
		n += 2 + l + sovPlayer(uint64(l))
	}
	if m.Area != 0 {
		n += 2 + sovPlayer(uint64(m.Area))
	}
	if m.MaxRankScore != 0 {
		n += 2 + sovPlayer(uint64(m.MaxRankScore))
	}
	return n
}

func (m *SdkUserInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.NickName)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	l = len(m.HeadImgUrl)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	if m.InviterUid != 0 {
		n += 1 + sovPlayer(uint64(m.InviterUid))
	}
	return n
}

func (m *UpdateHeadImgArg) Size() (n int) {
	var l int
	_ = l
	l = len(m.HeadImg)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *TouristRegisterAccountArg) Size() (n int) {
	var l int
	_ = l
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *TouristRegisterAccountRelpy) Size() (n int) {
	var l int
	_ = l
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *TouristBindAccountArg) Size() (n int) {
	var l int
	_ = l
	l = len(m.Channel)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	l = len(m.TouristAccount)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	l = len(m.TouristPassword)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	if m.BindAccount != nil {
		l = m.BindAccount.Size()
		n += 1 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *FetchHeadFrameReply) Size() (n int) {
	var l int
	_ = l
	if len(m.HeadFrames) > 0 {
		for _, s := range m.HeadFrames {
			l = len(s)
			n += 1 + l + sovPlayer(uint64(l))
		}
	}
	return n
}

func (m *UpdateHeadFrameArg) Size() (n int) {
	var l int
	_ = l
	l = len(m.HeadFrame)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *HeadData) Size() (n int) {
	var l int
	_ = l
	if len(m.OnceCards) > 0 {
		l = 0
		for _, e := range m.OnceCards {
			l += sovPlayer(uint64(e))
		}
		n += 1 + sovPlayer(uint64(l)) + l
	}
	return n
}

func (m *EmojiData) Size() (n int) {
	var l int
	_ = l
	if len(m.EmojiTeams) > 0 {
		l = 0
		for _, e := range m.EmojiTeams {
			l += sovPlayer(uint64(e))
		}
		n += 1 + sovPlayer(uint64(l)) + l
	}
	return n
}

func (m *TellMe) Size() (n int) {
	var l int
	_ = l
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	if m.Text != 0 {
		n += 1 + sovPlayer(uint64(m.Text))
	}
	return n
}

func (m *UnlockEmojiArg) Size() (n int) {
	var l int
	_ = l
	if m.EmojiTeam != 0 {
		n += 1 + sovPlayer(uint64(m.EmojiTeam))
	}
	return n
}

func (m *VipRemainTime) Size() (n int) {
	var l int
	_ = l
	if m.RemainTime != 0 {
		n += 1 + sovPlayer(uint64(m.RemainTime))
	}
	return n
}

func (m *MinVipRemainTime) Size() (n int) {
	var l int
	_ = l
	if m.RemainTime != 0 {
		n += 1 + sovPlayer(uint64(m.RemainTime))
	}
	return n
}

func (m *AccountCode) Size() (n int) {
	var l int
	_ = l
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *AccountCodePlayerInfo) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovPlayer(uint64(m.Uid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	if m.PvpScore != 0 {
		n += 1 + sovPlayer(uint64(m.PvpScore))
	}
	l = len(m.HeadImg)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	l = len(m.HeadFrame)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *FetchChatPopReply) Size() (n int) {
	var l int
	_ = l
	if len(m.ChatPops) > 0 {
		for _, s := range m.ChatPops {
			l = len(s)
			n += 1 + l + sovPlayer(uint64(l))
		}
	}
	l = len(m.CurChatPop)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *UpdateChatPopArg) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChatPop)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *AdultCertificationArg) Size() (n int) {
	var l int
	_ = l
	if m.IsAdult {
		n += 2
	}
	return n
}

func (m *UpdateSimplePlayerArg) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovPlayer(uint64(m.Uid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	l = len(m.HeadImgUrl)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	if m.PvpScore != 0 {
		n += 1 + sovPlayer(uint64(m.PvpScore))
	}
	l = len(m.HeadFrame)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *OnBindAccountArg) Size() (n int) {
	var l int
	_ = l
	l = len(m.AccountID)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	if m.BindRegion != 0 {
		n += 1 + sovPlayer(uint64(m.BindRegion))
	}
	return n
}

func (m *LoginNoticeData) Size() (n int) {
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *LoginNotice) Size() (n int) {
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovPlayer(uint64(m.Version))
	}
	if len(m.Notices) > 0 {
		for _, e := range m.Notices {
			l = e.Size()
			n += 1 + l + sovPlayer(uint64(l))
		}
	}
	return n
}

func (m *OnLoginNoticeShowArg) Size() (n int) {
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovPlayer(uint64(m.Version))
	}
	return n
}

func (m *UpdateNationalFlagArg) Size() (n int) {
	var l int
	_ = l
	l = len(m.CountryFlag)
	if l > 0 {
		n += 1 + l + sovPlayer(uint64(l))
	}
	return n
}

func (m *UpdateCountryFlagRemainTime) Size() (n int) {
	var l int
	_ = l
	if m.RemainTime != 0 {
		n += 1 + sovPlayer(uint64(m.RemainTime))
	}
	return n
}

func (m *Pong) Size() (n int) {
	var l int
	_ = l
	if m.ServerTime != 0 {
		n += 1 + sovPlayer(uint64(m.ServerTime))
	}
	return n
}

func sovPlayer(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPlayer(x uint64) (n int) {
	return sovPlayer(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *KickOut) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KickOut: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KickOut: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FinishGuide) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FinishGuide: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FinishGuide: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuideID", wireType)
			}
			m.GuideID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuideID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllFinishGuide) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllFinishGuide: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllFinishGuide: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlayer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GuideIDs = append(m.GuideIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlayer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlayer
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlayer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GuideIDs = append(m.GuideIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GuideIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GuideGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GuideGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GuideGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArchiveID", wireType)
			}
			m.ArchiveID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArchiveID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountType", wireType)
			}
			m.AccountType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccountType |= (AccountTypeEnum(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTourist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTourist = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoginChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Country = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cards = append(m.Cards, &CardInfo{})
			if err := m.Cards[len(m.Cards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Res", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Res = append(m.Res, &Resource{})
			if err := m.Res[len(m.Res)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiyCards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiyCards = append(m.DiyCards, &DiyCardData{})
			if err := m.DiyCards[len(m.DiyCards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightID", wireType)
			}
			m.FightID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuideCamp", wireType)
			}
			m.GuideCamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuideCamp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ver", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ver == nil {
				m.Ver = &Version{}
			}
			if err := m.Ver.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsExamined", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsExamined = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadImg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeadImg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CumulativePay", wireType)
			}
			m.CumulativePay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CumulativePay |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SharedState", wireType)
			}
			m.SharedState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SharedState |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonPvpLimitTime", wireType)
			}
			m.SeasonPvpLimitTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeasonPvpLimitTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardSkins", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CardSkins = append(m.CardSkins, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadFrame", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeadFrame = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSeasonPvpChooseCard", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSeasonPvpChooseCard = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsInCampaignMatch", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsInCampaignMatch = bool(v != 0)
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Huodongs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Huodongs = append(m.Huodongs, &HuodongData{})
			if err := m.Huodongs[len(m.Huodongs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RebornCnt", wireType)
			}
			m.RebornCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RebornCnt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hints = append(m.Hints, &Hint{})
			if err := m.Hints[len(m.Hints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutStatuses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutStatuses = append(m.OutStatuses, &OutStatus{})
			if err := m.OutStatuses[len(m.OutStatuses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Area", wireType)
			}
			m.Area = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Area |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatPop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatPop = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Notice == nil {
				m.Notice = &LoginNotice{}
			}
			if err := m.Notice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryFlag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CountryFlag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountLoginArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountLoginArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountLoginArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SdkToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SdkToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTourist", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTourist = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoginChannel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoginChannel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WxOpenID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WxOpenID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Archive) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Archive: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Archive: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTime", wireType)
			}
			m.LastTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastTime |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GateHost) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GateHost: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GateHost: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WssPort", wireType)
			}
			m.WssPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WssPort |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountArchives) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountArchives: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountArchives: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Archives", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Archives = append(m.Archives, &Archive{})
			if err := m.Archives[len(m.Archives)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServerSt == nil {
				m.ServerSt = &ServerStatus{}
			}
			if err := m.ServerSt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ok = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectHost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RedirectHost == nil {
				m.RedirectHost = &GateHost{}
			}
			if err := m.RedirectHost.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterAccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelArchiveArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelArchiveArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelArchiveArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArchiveID", wireType)
			}
			m.ArchiveID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArchiveID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceModify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceModify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceModify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Res", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Res = append(m.Res, &Resource{})
			if err := m.Res[len(m.Res)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModifyNameArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModifyNameArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModifyNameArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateNameArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateNameArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateNameArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Version) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Version: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Version: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field V1", wireType)
			}
			m.V1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.V1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field V2", wireType)
			}
			m.V2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.V2 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field V3", wireType)
			}
			m.V3 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.V3 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadPlayerArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadPlayerArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadPlayerArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimplePlayerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimplePlayerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimplePlayerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PvpScore", wireType)
			}
			m.PvpScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PvpScore |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadImgUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeadImgUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstHandAmount", wireType)
			}
			m.FirstHandAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FirstHandAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackHandAmount", wireType)
			}
			m.BackHandAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BackHandAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstHandWinAmount", wireType)
			}
			m.FirstHandWinAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FirstHandWinAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackHandWinAmount", wireType)
			}
			m.BackHandWinAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BackHandWinAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankScore", wireType)
			}
			m.RankScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankScore |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FavoriteCards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FavoriteCards = append(m.FavoriteCards, &SkinGCard{})
			if err := m.FavoriteCards[len(m.FavoriteCards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightCards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FightCards = append(m.FightCards, &SkinGCard{})
			if err := m.FightCards[len(m.FightCards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsWechatFriend", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsWechatFriend = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOnline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOnline = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsInBattle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsInBattle = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastOnlineTime", wireType)
			}
			m.LastOnlineTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastOnlineTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PvpCamp", wireType)
			}
			m.PvpCamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PvpCamp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Country = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadFrame", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeadFrame = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RebornCnt", wireType)
			}
			m.RebornCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RebornCnt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusIDs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusIDs = append(m.StatusIDs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossAreaHonor", wireType)
			}
			m.CrossAreaHonor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrossAreaHonor |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryFlag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CountryFlag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Area", wireType)
			}
			m.Area = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Area |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRankScore", wireType)
			}
			m.MaxRankScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRankScore |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SdkUserInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SdkUserInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SdkUserInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NickName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NickName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadImgUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeadImgUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InviterUid", wireType)
			}
			m.InviterUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InviterUid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateHeadImgArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateHeadImgArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateHeadImgArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadImg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeadImg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TouristRegisterAccountArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TouristRegisterAccountArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TouristRegisterAccountArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TouristRegisterAccountRelpy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TouristRegisterAccountRelpy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TouristRegisterAccountRelpy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TouristBindAccountArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TouristBindAccountArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TouristBindAccountArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Channel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TouristAccount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TouristAccount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TouristPassword", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TouristPassword = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindAccount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BindAccount == nil {
				m.BindAccount = &AccountLoginArg{}
			}
			if err := m.BindAccount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchHeadFrameReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchHeadFrameReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchHeadFrameReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadFrames", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeadFrames = append(m.HeadFrames, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateHeadFrameArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateHeadFrameArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateHeadFrameArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadFrame", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeadFrame = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeadData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeadData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeadData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlayer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OnceCards = append(m.OnceCards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlayer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlayer
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlayer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OnceCards = append(m.OnceCards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OnceCards", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EmojiData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EmojiData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EmojiData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlayer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EmojiTeams = append(m.EmojiTeams, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlayer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPlayer
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlayer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EmojiTeams = append(m.EmojiTeams, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EmojiTeams", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TellMe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TellMe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TellMe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			m.Text = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Text |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnlockEmojiArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnlockEmojiArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnlockEmojiArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmojiTeam", wireType)
			}
			m.EmojiTeam = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EmojiTeam |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VipRemainTime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VipRemainTime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VipRemainTime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainTime", wireType)
			}
			m.RemainTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemainTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MinVipRemainTime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MinVipRemainTime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MinVipRemainTime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainTime", wireType)
			}
			m.RemainTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemainTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountCode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountCode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountCode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountCodePlayerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountCodePlayerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountCodePlayerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PvpScore", wireType)
			}
			m.PvpScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PvpScore |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadImg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeadImg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadFrame", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeadFrame = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchChatPopReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchChatPopReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchChatPopReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatPops", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatPops = append(m.ChatPops, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurChatPop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CurChatPop = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateChatPopArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateChatPopArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateChatPopArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatPop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatPop = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdultCertificationArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdultCertificationArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdultCertificationArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAdult", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAdult = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateSimplePlayerArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateSimplePlayerArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateSimplePlayerArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadImgUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeadImgUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PvpScore", wireType)
			}
			m.PvpScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PvpScore |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadFrame", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeadFrame = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OnBindAccountArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OnBindAccountArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OnBindAccountArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BindRegion", wireType)
			}
			m.BindRegion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BindRegion |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginNoticeData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginNoticeData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginNoticeData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoginNotice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginNotice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginNotice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notices = append(m.Notices, &LoginNoticeData{})
			if err := m.Notices[len(m.Notices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OnLoginNoticeShowArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OnLoginNoticeShowArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OnLoginNoticeShowArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateNationalFlagArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateNationalFlagArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateNationalFlagArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryFlag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CountryFlag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateCountryFlagRemainTime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateCountryFlagRemainTime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateCountryFlagRemainTime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainTime", wireType)
			}
			m.RemainTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemainTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pong) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pong: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pong: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerTime", wireType)
			}
			m.ServerTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPlayer(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPlayer
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPlayer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthPlayer
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPlayer
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPlayer(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPlayer = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPlayer   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("player.proto", fileDescriptorPlayer) }

var fileDescriptorPlayer = []byte{
	// 2023 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x58, 0xcd, 0x72, 0xdb, 0xc8,
	0x11, 0x5e, 0xf0, 0x9f, 0x4d, 0x51, 0xa2, 0x61, 0x6b, 0x17, 0xd6, 0x6e, 0x54, 0x32, 0x92, 0xb2,
	0x55, 0x59, 0xaf, 0xd6, 0x96, 0xe3, 0xc3, 0x1e, 0x72, 0x90, 0x29, 0xcb, 0x62, 0x45, 0x32, 0x55,
	0xa0, 0x7e, 0x2a, 0xc7, 0x11, 0x31, 0x26, 0x27, 0x24, 0x67, 0x58, 0x00, 0x28, 0x4b, 0x8f, 0x91,
	0xca, 0x21, 0x79, 0x86, 0x3c, 0x42, 0x8e, 0x39, 0xe5, 0x98, 0x47, 0x48, 0x39, 0x4f, 0x91, 0x43,
	0xaa, 0x52, 0xdd, 0x33, 0x03, 0x80, 0x90, 0xe4, 0xcd, 0xd6, 0x9e, 0x38, 0xfd, 0x4d, 0x4f, 0x63,
	0x7e, 0x7a, 0xbe, 0xaf, 0x87, 0xb0, 0x32, 0x9f, 0xb2, 0x1b, 0x1e, 0xed, 0xcc, 0x23, 0x95, 0x28,
	0xb7, 0x34, 0xbf, 0xdc, 0x80, 0x21, 0x8b, 0x42, 0x6d, 0x6f, 0x34, 0xe7, 0x57, 0x73, 0xd3, 0x5c,
	0x1d, 0xb2, 0xd9, 0x9c, 0x89, 0x91, 0x34, 0x76, 0x7b, 0xbc, 0x50, 0xa1, 0x92, 0x23, 0x63, 0xae,
	0x0c, 0xd5, 0x6c, 0xa6, 0x6c, 0x27, 0x8c, 0x85, 0x4c, 0x4c, 0x7b, 0x4d, 0x2d, 0x92, 0x38, 0x61,
	0xc9, 0x22, 0xd6, 0x80, 0xff, 0x04, 0xea, 0xbf, 0x13, 0xc3, 0x49, 0x7f, 0x91, 0xb8, 0x5f, 0x42,
	0x2d, 0xe0, 0x2c, 0x56, 0xd2, 0x73, 0xb6, 0x9c, 0xed, 0x6a, 0x60, 0x2c, 0xff, 0x19, 0xb4, 0x0e,
	0x84, 0x14, 0xf1, 0xf8, 0xdd, 0x42, 0x84, 0xdc, 0xf5, 0xa0, 0x4e, 0x8d, 0xde, 0xbe, 0xf1, 0xb3,
	0xa6, 0xff, 0x1c, 0x56, 0xf7, 0xa6, 0xd3, 0xbc, 0xef, 0x06, 0x34, 0x4c, 0x67, 0xec, 0x39, 0x5b,
	0xe5, 0xed, 0x6a, 0x90, 0xda, 0xfe, 0x53, 0x00, 0x6a, 0xbf, 0x8b, 0xd4, 0x62, 0x4e, 0x51, 0xb1,
	0x91, 0x8b, 0xaa, 0x4d, 0xff, 0x4f, 0x25, 0x68, 0x1c, 0xa9, 0x91, 0x90, 0x7b, 0xd1, 0xc8, 0xfd,
	0x06, 0x9a, 0x7b, 0xd1, 0x70, 0x2c, 0xae, 0xb2, 0xcf, 0x67, 0x00, 0x06, 0xe9, 0x8e, 0x99, 0x94,
	0x7c, 0xea, 0x95, 0xb6, 0x9c, 0xed, 0x66, 0x60, 0x4d, 0x1c, 0x67, 0x9a, 0xbd, 0x7d, 0xaf, 0x4c,
	0x7d, 0x19, 0xe0, 0xbe, 0x86, 0xd6, 0xde, 0x70, 0xa8, 0x16, 0x32, 0x39, 0xbd, 0x99, 0x73, 0xaf,
	0xb2, 0xe5, 0x6c, 0xaf, 0xee, 0x3e, 0xdc, 0x99, 0x5f, 0xee, 0xe4, 0xe0, 0xb7, 0x72, 0x31, 0x0b,
	0xf2, 0x7e, 0x18, 0xb4, 0x17, 0x9f, 0xaa, 0x45, 0x24, 0xe2, 0xc4, 0xab, 0x6e, 0x39, 0xdb, 0x8d,
	0x20, 0x03, 0x5c, 0x1f, 0x56, 0x68, 0xda, 0x76, 0x46, 0x35, 0xfa, 0xea, 0x12, 0x46, 0x13, 0xc6,
	0x70, 0xd1, 0x8d, 0x57, 0x37, 0x13, 0xd6, 0xa6, 0xbb, 0x09, 0x30, 0x58, 0x5c, 0xda, 0xb1, 0x0d,
	0xea, 0xcc, 0x21, 0xfe, 0x7f, 0x6b, 0x00, 0x14, 0x2a, 0xe0, 0xf3, 0xe9, 0x8d, 0xdb, 0x81, 0xf2,
	0x99, 0x08, 0x69, 0x47, 0x2a, 0x01, 0x36, 0x5d, 0x1f, 0xaa, 0x5d, 0x16, 0x85, 0xb1, 0x57, 0xda,
	0x2a, 0x6f, 0xb7, 0x76, 0x57, 0x70, 0x35, 0x08, 0xf4, 0xe4, 0x07, 0x15, 0xe8, 0x2e, 0x77, 0x13,
	0xca, 0x01, 0x8f, 0xbd, 0x72, 0xe6, 0x11, 0xf0, 0x58, 0x2d, 0xa2, 0x21, 0x0f, 0xb0, 0xc3, 0xfd,
	0x16, 0x1a, 0xfb, 0xe2, 0x46, 0x87, 0xa9, 0x90, 0xd3, 0x1a, 0x3a, 0x19, 0x6c, 0x9f, 0x25, 0x2c,
	0x48, 0x1d, 0x70, 0x2d, 0x07, 0x62, 0x34, 0x4e, 0x7a, 0xfb, 0xb4, 0x17, 0x95, 0xc0, 0x9a, 0x98,
	0x05, 0x03, 0x1e, 0x5d, 0xf1, 0xa8, 0xb7, 0x6f, 0x76, 0x21, 0xb5, 0x71, 0x0f, 0x29, 0x0b, 0xba,
	0x6c, 0x36, 0xa7, 0x3d, 0xa8, 0x06, 0x19, 0xe0, 0xba, 0x50, 0x79, 0xcf, 0x66, 0xdc, 0xac, 0x9f,
	0xda, 0xee, 0x2f, 0xa0, 0x7c, 0xce, 0x23, 0xaf, 0xb9, 0xe5, 0x6c, 0xb7, 0x76, 0x5b, 0x38, 0x9f,
	0x73, 0x1e, 0xc5, 0x42, 0xc9, 0x00, 0x71, 0xdc, 0xb8, 0x5e, 0xfc, 0xf6, 0x9a, 0xcd, 0x84, 0xe4,
	0xa1, 0x07, 0x74, 0x2a, 0x39, 0x04, 0xa7, 0x79, 0xc8, 0x59, 0xd8, 0x9b, 0x8d, 0xbc, 0x96, 0xde,
	0x72, 0x63, 0xba, 0xbf, 0x82, 0x76, 0x77, 0x31, 0x5b, 0x4c, 0x59, 0x22, 0xae, 0xf8, 0x09, 0xbb,
	0xf1, 0x56, 0x68, 0x3a, 0xcb, 0xa0, 0xbb, 0x05, 0xad, 0xc1, 0x98, 0x45, 0x3c, 0x1c, 0x24, 0x2c,
	0xe1, 0x5e, 0x9b, 0x7c, 0xf2, 0x90, 0xbb, 0x03, 0xee, 0x80, 0x6e, 0xce, 0xc9, 0xd5, 0xfc, 0x48,
	0xcc, 0x44, 0x72, 0x2a, 0x66, 0xdc, 0x5b, 0x25, 0xc7, 0x3b, 0x7a, 0x28, 0x37, 0x59, 0x14, 0x0e,
	0x26, 0x42, 0xc6, 0xde, 0xda, 0x56, 0x99, 0x72, 0xd3, 0x02, 0xd8, 0x8b, 0x13, 0x3c, 0x88, 0x70,
	0x1f, 0x3a, 0x3a, 0x73, 0x53, 0xc0, 0xfd, 0x0d, 0xac, 0xf7, 0xe2, 0x34, 0x66, 0x77, 0xac, 0x54,
	0xcc, 0x71, 0xac, 0xf7, 0x80, 0x16, 0x7e, 0x77, 0xa7, 0xfb, 0x1c, 0x1e, 0xf4, 0xe2, 0x9e, 0xec,
	0x1a, 0x12, 0x39, 0x66, 0xc9, 0x70, 0xec, 0xb9, 0x34, 0xe2, 0x76, 0x07, 0x66, 0xc1, 0xa1, 0xa6,
	0x97, 0xd8, 0x7b, 0x98, 0x65, 0x81, 0xc1, 0x74, 0x16, 0x58, 0x07, 0x9c, 0x6e, 0xc0, 0x2f, 0x55,
	0x24, 0xbb, 0x32, 0xf1, 0x1e, 0xe9, 0xf3, 0x4c, 0x01, 0x77, 0x13, 0xaa, 0x87, 0x42, 0x26, 0xb1,
	0xb7, 0x4e, 0x71, 0x1a, 0x14, 0x47, 0xc8, 0x24, 0xd0, 0xb0, 0xfb, 0x3d, 0xb4, 0xfa, 0x8b, 0x64,
	0x40, 0x04, 0xc5, 0x63, 0xef, 0x4b, 0xf2, 0x6a, 0xa3, 0x57, 0x0a, 0x07, 0x79, 0x0f, 0x4c, 0x90,
	0xbd, 0x88, 0x33, 0xef, 0x2b, 0xfa, 0x12, 0xb5, 0x0d, 0x0b, 0x24, 0x27, 0x6a, 0xee, 0x79, 0x29,
	0x0b, 0xa0, 0xe9, 0x3e, 0x83, 0xda, 0x7b, 0x95, 0x88, 0x21, 0xf7, 0x1e, 0x53, 0xf6, 0xd0, 0x3a,
	0xe8, 0x16, 0x69, 0x38, 0x30, 0xdd, 0x78, 0xc8, 0xe6, 0x22, 0x1e, 0x4c, 0xd9, 0xc8, 0xdb, 0xa0,
	0x30, 0x79, 0xc8, 0xff, 0x8f, 0x03, 0x6b, 0x86, 0x0b, 0x52, 0x72, 0xca, 0xd1, 0x8f, 0xf3, 0x19,
	0xfa, 0x29, 0x15, 0xe9, 0xc7, 0x83, 0xba, 0x09, 0x65, 0xa8, 0xc9, 0x9a, 0x78, 0x73, 0x4e, 0x58,
	0x1c, 0x7f, 0x54, 0x51, 0x48, 0xac, 0xd4, 0x0c, 0x52, 0x9b, 0x6e, 0x55, 0x38, 0x39, 0x55, 0x13,
	0x2e, 0xe9, 0xc2, 0xe1, 0xad, 0x32, 0xf6, 0x32, 0x33, 0xd5, 0x7e, 0x8c, 0x99, 0xea, 0x77, 0x30,
	0xd3, 0x06, 0x34, 0x2e, 0xae, 0xfb, 0x73, 0x2e, 0x7b, 0xfb, 0xe6, 0xf6, 0xa5, 0xb6, 0xff, 0x0e,
	0xea, 0x86, 0x73, 0xdd, 0x55, 0x28, 0xa5, 0x44, 0x5c, 0xea, 0xed, 0x5b, 0x1e, 0x2a, 0x65, 0x3c,
	0xb4, 0x01, 0x8d, 0x23, 0x16, 0xeb, 0x3b, 0x80, 0xab, 0x6b, 0x07, 0xa9, 0xed, 0x1f, 0x41, 0xe3,
	0x1d, 0x4b, 0xf8, 0xa1, 0x8a, 0x13, 0x3c, 0x49, 0xfc, 0x35, 0x3b, 0x57, 0xb1, 0xd8, 0x89, 0x8a,
	0x12, 0x0a, 0x57, 0x0d, 0xa8, 0x8d, 0x9b, 0x75, 0x11, 0xc7, 0x04, 0x97, 0xb5, 0x50, 0x18, 0xd3,
	0xff, 0x6b, 0x76, 0x24, 0x66, 0x7a, 0xb1, 0xfb, 0x0c, 0x1a, 0xb6, 0x4d, 0x02, 0x64, 0x18, 0xc3,
	0x60, 0x41, 0xda, 0xe9, 0x3e, 0xb7, 0x1c, 0x35, 0xd0, 0x9f, 0x6b, 0xed, 0x76, 0xd0, 0xd1, 0x62,
	0x94, 0x79, 0xa9, 0x07, 0x2e, 0xbb, 0x3f, 0xa1, 0xef, 0x37, 0x82, 0x52, 0x7f, 0xe2, 0xbe, 0x80,
	0x95, 0x80, 0x87, 0x22, 0xe2, 0xc3, 0x84, 0x16, 0x51, 0xa1, 0x08, 0xc4, 0xa8, 0x76, 0x81, 0xc1,
	0x92, 0x87, 0xcf, 0x60, 0x2d, 0xe0, 0x23, 0x11, 0x27, 0x3c, 0xb2, 0x87, 0x7d, 0x7f, 0xfa, 0xe4,
	0x12, 0xa4, 0x74, 0x7f, 0x82, 0x94, 0x97, 0x13, 0xc4, 0xe7, 0xd0, 0xde, 0xe7, 0x53, 0xb3, 0xc2,
	0x9f, 0x93, 0x9f, 0x4b, 0xa2, 0x5b, 0x2e, 0x88, 0xae, 0xff, 0x02, 0x56, 0xad, 0x6a, 0x1c, 0xab,
	0x50, 0x7c, 0xb8, 0xb1, 0xb2, 0xe2, 0xdc, 0x23, 0x2b, 0xfe, 0x2f, 0xa1, 0xad, 0x3d, 0x91, 0xcf,
	0x71, 0x62, 0x96, 0xe6, 0x9d, 0x8c, 0xe6, 0xd1, 0xe9, 0x6c, 0x1e, 0xb2, 0x84, 0x7f, 0xce, 0xe9,
	0x07, 0xa8, 0x1b, 0xf2, 0xc7, 0x23, 0x39, 0x7f, 0x69, 0x33, 0xf1, 0xfc, 0x25, 0xd9, 0xbb, 0x26,
	0x73, 0x4a, 0xe7, 0xbb, 0x64, 0xbf, 0x32, 0xb3, 0x2f, 0x9d, 0xbf, 0xf2, 0x9f, 0x40, 0xfb, 0x48,
	0xb1, 0xf0, 0x84, 0x2a, 0x2e, 0x8c, 0x7f, 0x4b, 0x42, 0xfd, 0xbf, 0xd7, 0xa0, 0x33, 0x10, 0xb3,
	0xf9, 0x94, 0x6b, 0x2f, 0x94, 0xce, 0xbb, 0xa6, 0x41, 0xa7, 0x70, 0x35, 0x1f, 0x0c, 0x55, 0xc4,
	0xcd, 0x17, 0x53, 0x1b, 0xf5, 0xc8, 0x08, 0xcc, 0x59, 0x34, 0x35, 0x67, 0x94, 0x43, 0xdc, 0x6d,
	0x58, 0x3b, 0x10, 0x51, 0x9c, 0x1c, 0x32, 0x19, 0xee, 0xcd, 0xe8, 0x8c, 0x2b, 0x14, 0xa2, 0x08,
	0xbb, 0x4f, 0x61, 0xf5, 0x0d, 0x1b, 0x4e, 0x72, 0x8e, 0x55, 0x72, 0x2c, 0xa0, 0xa8, 0x3f, 0xe9,
	0xd0, 0x0b, 0x21, 0x8d, 0x6f, 0x4d, 0xeb, 0xcf, 0xed, 0x1e, 0x54, 0x03, 0x1b, 0x21, 0x73, 0xd7,
	0x52, 0x7c, 0xbb, 0x83, 0x08, 0x9e, 0xc9, 0x89, 0x5e, 0x6c, 0xc3, 0x10, 0xbc, 0x05, 0xdc, 0x57,
	0xd0, 0x3e, 0x60, 0x57, 0x2a, 0x12, 0x09, 0xd7, 0x65, 0x43, 0x33, 0xa3, 0x70, 0xd4, 0xb3, 0x77,
	0x88, 0x06, 0xcb, 0x3e, 0xee, 0x77, 0x00, 0x54, 0x2a, 0xe8, 0x11, 0x70, 0xd7, 0x88, 0x9c, 0x03,
	0xee, 0x43, 0x2f, 0xbe, 0xe0, 0xc3, 0x31, 0x4b, 0x0e, 0x22, 0xc1, 0x65, 0x48, 0x42, 0xde, 0x08,
	0x0a, 0x28, 0x9e, 0x4a, 0x2f, 0xee, 0xcb, 0xa9, 0x90, 0x9c, 0xa4, 0xbc, 0x11, 0xa4, 0xb6, 0xae,
	0x12, 0x7a, 0xf2, 0x0d, 0x4b, 0x92, 0xa9, 0x16, 0x71, 0xaa, 0x12, 0x2c, 0x82, 0xdf, 0x40, 0x96,
	0xd2, 0xde, 0x39, 0xfd, 0x2e, 0xa0, 0x36, 0x69, 0xd6, 0x32, 0xbe, 0xf3, 0xa0, 0x8e, 0x62, 0x8b,
	0xe5, 0x4c, 0x47, 0xf3, 0x93, 0x31, 0xf3, 0xc5, 0xde, 0x83, 0xe5, 0x62, 0x6f, 0x49, 0xe3, 0xdd,
	0xa2, 0xc6, 0x2f, 0x49, 0xea, 0xc3, 0xa2, 0xa4, 0x7e, 0x03, 0x4d, 0x4d, 0x4f, 0x58, 0x63, 0x3f,
	0xd2, 0xd5, 0x43, 0x0a, 0xe0, 0x3a, 0xba, 0x91, 0x8a, 0x63, 0x14, 0xc6, 0x43, 0x25, 0x55, 0xe4,
	0xad, 0xeb, 0x75, 0x2c, 0xa3, 0x45, 0xc1, 0xfb, 0xea, 0x96, 0xe0, 0xa5, 0x4a, 0xeb, 0xe5, 0x94,
	0xd6, 0x87, 0x95, 0x63, 0x76, 0x9d, 0xa5, 0xc3, 0x63, 0xea, 0x5b, 0xc2, 0x7c, 0x01, 0xad, 0x41,
	0x38, 0x39, 0x8b, 0xcd, 0xf5, 0xd9, 0x80, 0xc6, 0x7b, 0x31, 0x9c, 0xe4, 0xae, 0x50, 0x6a, 0x17,
	0xae, 0x4a, 0xe9, 0xd6, 0x55, 0xc1, 0x43, 0x93, 0x57, 0x22, 0xe1, 0x11, 0xee, 0x79, 0x99, 0xf6,
	0x3c, 0x87, 0xf8, 0xcf, 0xa1, 0xa3, 0x29, 0xc3, 0x8c, 0x31, 0x9c, 0x67, 0xcb, 0x3d, 0x67, 0xa9,
	0xdc, 0xf3, 0x5f, 0xc3, 0x63, 0x23, 0x88, 0x05, 0x22, 0xfe, 0x2c, 0x55, 0xfa, 0x03, 0xf8, 0xfa,
	0xee, 0x61, 0x01, 0x9f, 0xce, 0x6f, 0xf2, 0x54, 0xed, 0xdc, 0x4f, 0xd5, 0xa5, 0x02, 0x55, 0xff,
	0xcd, 0x81, 0x75, 0x13, 0xf5, 0x8d, 0x90, 0xe1, 0xff, 0x33, 0x11, 0x3c, 0x5a, 0x33, 0x64, 0x59,
	0x1b, 0x0a, 0x28, 0x12, 0x8c, 0x41, 0x0a, 0x4a, 0x51, 0x84, 0xf1, 0x19, 0x94, 0xfb, 0xba, 0x11,
	0xb1, 0xfc, 0x33, 0xc8, 0x56, 0x3a, 0x41, 0xde, 0xcf, 0x7f, 0x0d, 0x0f, 0x0f, 0x78, 0x32, 0x1c,
	0xa7, 0x19, 0xab, 0x9f, 0x24, 0xe6, 0x34, 0x09, 0xd1, 0x62, 0x60, 0x4e, 0x53, 0x23, 0xfe, 0x2e,
	0xb8, 0xd9, 0x69, 0x11, 0x66, 0x1e, 0x78, 0xd9, 0x55, 0x70, 0x0a, 0x57, 0xc1, 0xdf, 0x86, 0x06,
	0x1a, 0x58, 0x73, 0xa2, 0x67, 0x5f, 0x0e, 0x0d, 0xcd, 0x60, 0xf8, 0x76, 0x90, 0x01, 0xfe, 0xb7,
	0xd0, 0x7c, 0x3b, 0x53, 0x7f, 0x10, 0xe4, 0xba, 0x09, 0x40, 0xc6, 0x29, 0x67, 0x33, 0xfb, 0x10,
	0xcd, 0x21, 0xfe, 0x0e, 0xd4, 0x4e, 0xf9, 0x74, 0x7a, 0x4c, 0xf7, 0xf9, 0x38, 0xb6, 0xa9, 0x82,
	0x4d, 0xcc, 0xfb, 0x53, 0x7e, 0x9d, 0xd6, 0x20, 0xd8, 0xf6, 0x77, 0x60, 0xf5, 0x4c, 0x4e, 0xd5,
	0x70, 0x42, 0x31, 0xcc, 0xb4, 0xd3, 0x78, 0xf6, 0x5d, 0x9a, 0x02, 0xfe, 0xf7, 0xd0, 0x3e, 0x17,
	0xf3, 0x80, 0xcf, 0x98, 0x90, 0x44, 0x1b, 0x9b, 0x00, 0x99, 0x65, 0xfc, 0x73, 0x88, 0xbf, 0x0b,
	0x9d, 0x63, 0x21, 0x7f, 0xda, 0x98, 0x27, 0xe9, 0x23, 0xb6, 0xab, 0x42, 0x8e, 0xf3, 0xc6, 0x5f,
	0xab, 0x53, 0xd8, 0xf6, 0xff, 0xe8, 0xc0, 0x7a, 0xce, 0x27, 0xa7, 0x6a, 0xb7, 0xdf, 0x8f, 0x56,
	0xe7, 0x4a, 0xf7, 0xe8, 0x5c, 0xb9, 0xa0, 0x73, 0xb9, 0x8b, 0x56, 0x59, 0x7e, 0x57, 0x2d, 0x1d,
	0x69, 0xb5, 0x78, 0xa4, 0x7d, 0x78, 0x40, 0xd9, 0x63, 0x6a, 0x74, 0x9d, 0x3b, 0x1b, 0xd0, 0x30,
	0xb6, 0xcd, 0x9c, 0xd4, 0xc6, 0x7d, 0xe8, 0x2e, 0x22, 0x5b, 0xe1, 0x1b, 0x96, 0xc8, 0x90, 0x8c,
	0x05, 0x0c, 0x90, 0xdd, 0x22, 0x1a, 0xe0, 0x2c, 0x3d, 0x09, 0xfc, 0x97, 0xb0, 0xbe, 0x17, 0x2e,
	0xa6, 0x49, 0x97, 0x47, 0x89, 0xf8, 0x20, 0x86, 0x2c, 0x11, 0xca, 0x16, 0xf3, 0xbd, 0x98, 0xba,
	0x68, 0x48, 0x23, 0xb0, 0xa6, 0xff, 0x67, 0x07, 0xd6, 0xf5, 0x17, 0xf2, 0xc5, 0xc1, 0x9d, 0x25,
	0xc4, 0x9d, 0xbb, 0xf8, 0x63, 0x15, 0x41, 0x7e, 0x97, 0x2b, 0x85, 0x5d, 0xfe, 0xfc, 0x5e, 0x9e,
	0x40, 0xa7, 0x2f, 0x0b, 0x04, 0x82, 0xc5, 0x9b, 0xb6, 0x4c, 0xa1, 0xde, 0x0c, 0x32, 0x00, 0xe7,
	0x82, 0xfe, 0x48, 0x65, 0x4a, 0xd2, 0x2c, 0xdb, 0x41, 0x0e, 0xf1, 0xf7, 0x60, 0x2d, 0xf7, 0x3e,
	0xa2, 0xcb, 0xf4, 0x08, 0xaa, 0xa7, 0x02, 0x55, 0x53, 0x07, 0xd3, 0x86, 0x16, 0x37, 0x99, 0xf0,
	0xac, 0x44, 0x35, 0xa6, 0x7f, 0x0e, 0xad, 0x5c, 0x08, 0x74, 0x34, 0x25, 0x9b, 0xfd, 0xa3, 0xc7,
	0x56, 0x70, 0xdf, 0x41, 0x5d, 0xfb, 0xd8, 0xff, 0x2c, 0x1e, 0x16, 0x9e, 0x67, 0xf4, 0xd4, 0xb4,
	0x3e, 0xfe, 0x0b, 0x78, 0xd4, 0x97, 0xb9, 0xde, 0xc1, 0x58, 0x7d, 0x34, 0x07, 0x77, 0xf7, 0x07,
	0xfc, 0x1f, 0xec, 0xb9, 0xbd, 0xa7, 0x53, 0x66, 0x53, 0x14, 0x36, 0x1c, 0x52, 0x50, 0x3f, 0xe7,
	0xf6, 0x73, 0xef, 0xb7, 0xf0, 0xb5, 0x49, 0xaa, 0x0c, 0xfc, 0x09, 0x77, 0xf3, 0x29, 0x3e, 0x64,
	0xe4, 0x88, 0xfe, 0xd5, 0xa1, 0x37, 0x44, 0xde, 0x2f, 0x43, 0x7e, 0xfd, 0xfb, 0xf4, 0x05, 0x63,
	0xff, 0x71, 0x72, 0xd7, 0xe1, 0xc1, 0x99, 0x9c, 0x48, 0xf5, 0x31, 0xd7, 0xd1, 0xf9, 0xc2, 0xad,
	0x43, 0xb9, 0xa7, 0xe2, 0x8e, 0xe3, 0xb6, 0xa0, 0xbe, 0x27, 0xc3, 0x48, 0x89, 0xb0, 0x53, 0x72,
	0x01, 0x6a, 0x17, 0xd7, 0x23, 0x36, 0xe3, 0x9d, 0xb2, 0xdb, 0x86, 0xa6, 0x6e, 0xa3, 0x5f, 0xe5,
	0x4d, 0xe7, 0x1f, 0x9f, 0x36, 0x9d, 0x7f, 0x7e, 0xda, 0x74, 0xfe, 0xf5, 0x69, 0xd3, 0xf9, 0xcb,
	0xbf, 0x37, 0xbf, 0xb8, 0xac, 0xd1, 0x3f, 0x80, 0xaf, 0xfe, 0x17, 0x00, 0x00, 0xff, 0xff, 0x5d,
	0x09, 0x78, 0xe0, 0x76, 0x14, 0x00, 0x00,
}
