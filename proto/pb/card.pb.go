// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: card.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type CardState int32

const (
	CardState_NormalCState CardState = 0
	CardState_InCampaignMs CardState = 1
	CardState_InSeasonPvp  CardState = 2
)

var CardState_name = map[int32]string{
	0: "NormalCState",
	1: "InCampaignMs",
	2: "InSeasonPvp",
}
var CardState_value = map[string]int32{
	"NormalCState": 0,
	"InCampaignMs": 1,
	"InSeasonPvp":  2,
}

func (x CardState) String() string {
	return proto.EnumName(CardState_name, int32(x))
}
func (CardState) EnumDescriptor() ([]byte, []int) { return fileDescriptorCard, []int{0} }

type CardPool struct {
	PoolId  int32    `protobuf:"varint,1,opt,name=PoolId,proto3" json:"PoolId,omitempty"`
	Cards   []uint32 `protobuf:"varint,2,rep,packed,name=Cards" json:"Cards,omitempty"`
	Camp    int32    `protobuf:"varint,3,opt,name=Camp,proto3" json:"Camp,omitempty"`
	IsFight bool     `protobuf:"varint,4,opt,name=IsFight,proto3" json:"IsFight,omitempty"`
}

func (m *CardPool) Reset()                    { *m = CardPool{} }
func (m *CardPool) String() string            { return proto.CompactTextString(m) }
func (*CardPool) ProtoMessage()               {}
func (*CardPool) Descriptor() ([]byte, []int) { return fileDescriptorCard, []int{0} }

func (m *CardPool) GetPoolId() int32 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *CardPool) GetCards() []uint32 {
	if m != nil {
		return m.Cards
	}
	return nil
}

func (m *CardPool) GetCamp() int32 {
	if m != nil {
		return m.Camp
	}
	return 0
}

func (m *CardPool) GetIsFight() bool {
	if m != nil {
		return m.IsFight
	}
	return false
}

type CardInfo struct {
	CardId         uint32    `protobuf:"varint,1,opt,name=CardId,proto3" json:"CardId,omitempty"`
	Level          int32     `protobuf:"varint,2,opt,name=Level,proto3" json:"Level,omitempty"`
	Amount         int32     `protobuf:"varint,3,opt,name=Amount,proto3" json:"Amount,omitempty"`
	Energy         float32   `protobuf:"fixed32,4,opt,name=Energy,proto3" json:"Energy,omitempty"`
	Skin           string    `protobuf:"bytes,5,opt,name=Skin,proto3" json:"Skin,omitempty"`
	Equip          string    `protobuf:"bytes,6,opt,name=Equip,proto3" json:"Equip,omitempty"`
	State          CardState `protobuf:"varint,7,opt,name=State,proto3,enum=pb.CardState" json:"State,omitempty"`
	MaxUnlockLevel int32     `protobuf:"varint,8,opt,name=MaxUnlockLevel,proto3" json:"MaxUnlockLevel,omitempty"`
}

func (m *CardInfo) Reset()                    { *m = CardInfo{} }
func (m *CardInfo) String() string            { return proto.CompactTextString(m) }
func (*CardInfo) ProtoMessage()               {}
func (*CardInfo) Descriptor() ([]byte, []int) { return fileDescriptorCard, []int{1} }

func (m *CardInfo) GetCardId() uint32 {
	if m != nil {
		return m.CardId
	}
	return 0
}

func (m *CardInfo) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *CardInfo) GetAmount() int32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *CardInfo) GetEnergy() float32 {
	if m != nil {
		return m.Energy
	}
	return 0
}

func (m *CardInfo) GetSkin() string {
	if m != nil {
		return m.Skin
	}
	return ""
}

func (m *CardInfo) GetEquip() string {
	if m != nil {
		return m.Equip
	}
	return ""
}

func (m *CardInfo) GetState() CardState {
	if m != nil {
		return m.State
	}
	return CardState_NormalCState
}

func (m *CardInfo) GetMaxUnlockLevel() int32 {
	if m != nil {
		return m.MaxUnlockLevel
	}
	return 0
}

type CardPools struct {
	Pools []*CardPool `protobuf:"bytes,1,rep,name=Pools" json:"Pools,omitempty"`
	// repeated CardInfo Cards = 2;
	FightCamp int32 `protobuf:"varint,2,opt,name=FightCamp,proto3" json:"FightCamp,omitempty"`
}

func (m *CardPools) Reset()                    { *m = CardPools{} }
func (m *CardPools) String() string            { return proto.CompactTextString(m) }
func (*CardPools) ProtoMessage()               {}
func (*CardPools) Descriptor() ([]byte, []int) { return fileDescriptorCard, []int{2} }

func (m *CardPools) GetPools() []*CardPool {
	if m != nil {
		return m.Pools
	}
	return nil
}

func (m *CardPools) GetFightCamp() int32 {
	if m != nil {
		return m.FightCamp
	}
	return 0
}

type CardDatas struct {
	Cards    []*CardInfo    `protobuf:"bytes,1,rep,name=Cards" json:"Cards,omitempty"`
	DiyCards []*DiyCardData `protobuf:"bytes,2,rep,name=DiyCards" json:"DiyCards,omitempty"`
}

func (m *CardDatas) Reset()                    { *m = CardDatas{} }
func (m *CardDatas) String() string            { return proto.CompactTextString(m) }
func (*CardDatas) ProtoMessage()               {}
func (*CardDatas) Descriptor() ([]byte, []int) { return fileDescriptorCard, []int{3} }

func (m *CardDatas) GetCards() []*CardInfo {
	if m != nil {
		return m.Cards
	}
	return nil
}

func (m *CardDatas) GetDiyCards() []*DiyCardData {
	if m != nil {
		return m.DiyCards
	}
	return nil
}

type PoolAddCard struct {
	Card   uint32 `protobuf:"varint,1,opt,name=Card,proto3" json:"Card,omitempty"`
	Idx    int32  `protobuf:"varint,2,opt,name=Idx,proto3" json:"Idx,omitempty"`
	PoolId int32  `protobuf:"varint,3,opt,name=PoolId,proto3" json:"PoolId,omitempty"`
}

func (m *PoolAddCard) Reset()                    { *m = PoolAddCard{} }
func (m *PoolAddCard) String() string            { return proto.CompactTextString(m) }
func (*PoolAddCard) ProtoMessage()               {}
func (*PoolAddCard) Descriptor() ([]byte, []int) { return fileDescriptorCard, []int{4} }

func (m *PoolAddCard) GetCard() uint32 {
	if m != nil {
		return m.Card
	}
	return 0
}

func (m *PoolAddCard) GetIdx() int32 {
	if m != nil {
		return m.Idx
	}
	return 0
}

func (m *PoolAddCard) GetPoolId() int32 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

type PoolUpdateCard struct {
	PoolId int32    `protobuf:"varint,1,opt,name=PoolId,proto3" json:"PoolId,omitempty"`
	Cards  []uint32 `protobuf:"varint,2,rep,packed,name=Cards" json:"Cards,omitempty"`
}

func (m *PoolUpdateCard) Reset()                    { *m = PoolUpdateCard{} }
func (m *PoolUpdateCard) String() string            { return proto.CompactTextString(m) }
func (*PoolUpdateCard) ProtoMessage()               {}
func (*PoolUpdateCard) Descriptor() ([]byte, []int) { return fileDescriptorCard, []int{5} }

func (m *PoolUpdateCard) GetPoolId() int32 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *PoolUpdateCard) GetCards() []uint32 {
	if m != nil {
		return m.Cards
	}
	return nil
}

type FightPool struct {
	PoolId int32 `protobuf:"varint,1,opt,name=PoolId,proto3" json:"PoolId,omitempty"`
	Camp   int32 `protobuf:"varint,2,opt,name=Camp,proto3" json:"Camp,omitempty"`
}

func (m *FightPool) Reset()                    { *m = FightPool{} }
func (m *FightPool) String() string            { return proto.CompactTextString(m) }
func (*FightPool) ProtoMessage()               {}
func (*FightPool) Descriptor() ([]byte, []int) { return fileDescriptorCard, []int{6} }

func (m *FightPool) GetPoolId() int32 {
	if m != nil {
		return m.PoolId
	}
	return 0
}

func (m *FightPool) GetCamp() int32 {
	if m != nil {
		return m.Camp
	}
	return 0
}

type UpdateCardPools struct {
	Pools     []*FightPool `protobuf:"bytes,1,rep,name=Pools" json:"Pools,omitempty"`
	FightCamp int32        `protobuf:"varint,2,opt,name=FightCamp,proto3" json:"FightCamp,omitempty"`
}

func (m *UpdateCardPools) Reset()                    { *m = UpdateCardPools{} }
func (m *UpdateCardPools) String() string            { return proto.CompactTextString(m) }
func (*UpdateCardPools) ProtoMessage()               {}
func (*UpdateCardPools) Descriptor() ([]byte, []int) { return fileDescriptorCard, []int{7} }

func (m *UpdateCardPools) GetPools() []*FightPool {
	if m != nil {
		return m.Pools
	}
	return nil
}

func (m *UpdateCardPools) GetFightCamp() int32 {
	if m != nil {
		return m.FightCamp
	}
	return 0
}

type TargetCard struct {
	CardId uint32 `protobuf:"varint,1,opt,name=CardId,proto3" json:"CardId,omitempty"`
}

func (m *TargetCard) Reset()                    { *m = TargetCard{} }
func (m *TargetCard) String() string            { return proto.CompactTextString(m) }
func (*TargetCard) ProtoMessage()               {}
func (*TargetCard) Descriptor() ([]byte, []int) { return fileDescriptorCard, []int{8} }

func (m *TargetCard) GetCardId() uint32 {
	if m != nil {
		return m.CardId
	}
	return 0
}

type DiyCardArg struct {
	Name        string `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	DiySkillId1 int32  `protobuf:"varint,2,opt,name=DiySkillId1,proto3" json:"DiySkillId1,omitempty"`
	DiySkillId2 int32  `protobuf:"varint,3,opt,name=DiySkillId2,proto3" json:"DiySkillId2,omitempty"`
	Weapon      string `protobuf:"bytes,4,opt,name=Weapon,proto3" json:"Weapon,omitempty"`
	Img         string `protobuf:"bytes,5,opt,name=Img,proto3" json:"Img,omitempty"`
}

func (m *DiyCardArg) Reset()                    { *m = DiyCardArg{} }
func (m *DiyCardArg) String() string            { return proto.CompactTextString(m) }
func (*DiyCardArg) ProtoMessage()               {}
func (*DiyCardArg) Descriptor() ([]byte, []int) { return fileDescriptorCard, []int{9} }

func (m *DiyCardArg) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DiyCardArg) GetDiySkillId1() int32 {
	if m != nil {
		return m.DiySkillId1
	}
	return 0
}

func (m *DiyCardArg) GetDiySkillId2() int32 {
	if m != nil {
		return m.DiySkillId2
	}
	return 0
}

func (m *DiyCardArg) GetWeapon() string {
	if m != nil {
		return m.Weapon
	}
	return ""
}

func (m *DiyCardArg) GetImg() string {
	if m != nil {
		return m.Img
	}
	return ""
}

type DiyCardReply struct {
	CardId   uint32 `protobuf:"varint,1,opt,name=CardId,proto3" json:"CardId,omitempty"`
	MinUp    int32  `protobuf:"varint,2,opt,name=MinUp,proto3" json:"MinUp,omitempty"`
	MaxUp    int32  `protobuf:"varint,3,opt,name=MaxUp,proto3" json:"MaxUp,omitempty"`
	MinDown  int32  `protobuf:"varint,4,opt,name=MinDown,proto3" json:"MinDown,omitempty"`
	MaxDown  int32  `protobuf:"varint,5,opt,name=MaxDown,proto3" json:"MaxDown,omitempty"`
	MinLeft  int32  `protobuf:"varint,6,opt,name=MinLeft,proto3" json:"MinLeft,omitempty"`
	MaxLeft  int32  `protobuf:"varint,7,opt,name=MaxLeft,proto3" json:"MaxLeft,omitempty"`
	MinRight int32  `protobuf:"varint,8,opt,name=MinRight,proto3" json:"MinRight,omitempty"`
	MaxRight int32  `protobuf:"varint,9,opt,name=MaxRight,proto3" json:"MaxRight,omitempty"`
}

func (m *DiyCardReply) Reset()                    { *m = DiyCardReply{} }
func (m *DiyCardReply) String() string            { return proto.CompactTextString(m) }
func (*DiyCardReply) ProtoMessage()               {}
func (*DiyCardReply) Descriptor() ([]byte, []int) { return fileDescriptorCard, []int{10} }

func (m *DiyCardReply) GetCardId() uint32 {
	if m != nil {
		return m.CardId
	}
	return 0
}

func (m *DiyCardReply) GetMinUp() int32 {
	if m != nil {
		return m.MinUp
	}
	return 0
}

func (m *DiyCardReply) GetMaxUp() int32 {
	if m != nil {
		return m.MaxUp
	}
	return 0
}

func (m *DiyCardReply) GetMinDown() int32 {
	if m != nil {
		return m.MinDown
	}
	return 0
}

func (m *DiyCardReply) GetMaxDown() int32 {
	if m != nil {
		return m.MaxDown
	}
	return 0
}

func (m *DiyCardReply) GetMinLeft() int32 {
	if m != nil {
		return m.MinLeft
	}
	return 0
}

func (m *DiyCardReply) GetMaxLeft() int32 {
	if m != nil {
		return m.MaxLeft
	}
	return 0
}

func (m *DiyCardReply) GetMinRight() int32 {
	if m != nil {
		return m.MinRight
	}
	return 0
}

func (m *DiyCardReply) GetMaxRight() int32 {
	if m != nil {
		return m.MaxRight
	}
	return 0
}

type DiyCardData struct {
	CardId      uint32 `protobuf:"varint,1,opt,name=CardId,proto3" json:"CardId,omitempty"`
	Name        string `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	DiySkillId1 int32  `protobuf:"varint,3,opt,name=DiySkillId1,proto3" json:"DiySkillId1,omitempty"`
	DiySkillId2 int32  `protobuf:"varint,4,opt,name=DiySkillId2,proto3" json:"DiySkillId2,omitempty"`
	MinUp       int32  `protobuf:"varint,5,opt,name=MinUp,proto3" json:"MinUp,omitempty"`
	MaxUp       int32  `protobuf:"varint,6,opt,name=MaxUp,proto3" json:"MaxUp,omitempty"`
	MinDown     int32  `protobuf:"varint,7,opt,name=MinDown,proto3" json:"MinDown,omitempty"`
	MaxDown     int32  `protobuf:"varint,8,opt,name=MaxDown,proto3" json:"MaxDown,omitempty"`
	MinLeft     int32  `protobuf:"varint,9,opt,name=MinLeft,proto3" json:"MinLeft,omitempty"`
	MaxLeft     int32  `protobuf:"varint,10,opt,name=MaxLeft,proto3" json:"MaxLeft,omitempty"`
	MinRight    int32  `protobuf:"varint,11,opt,name=MinRight,proto3" json:"MinRight,omitempty"`
	MaxRight    int32  `protobuf:"varint,12,opt,name=MaxRight,proto3" json:"MaxRight,omitempty"`
	Weapon      string `protobuf:"bytes,13,opt,name=Weapon,proto3" json:"Weapon,omitempty"`
}

func (m *DiyCardData) Reset()                    { *m = DiyCardData{} }
func (m *DiyCardData) String() string            { return proto.CompactTextString(m) }
func (*DiyCardData) ProtoMessage()               {}
func (*DiyCardData) Descriptor() ([]byte, []int) { return fileDescriptorCard, []int{11} }

func (m *DiyCardData) GetCardId() uint32 {
	if m != nil {
		return m.CardId
	}
	return 0
}

func (m *DiyCardData) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DiyCardData) GetDiySkillId1() int32 {
	if m != nil {
		return m.DiySkillId1
	}
	return 0
}

func (m *DiyCardData) GetDiySkillId2() int32 {
	if m != nil {
		return m.DiySkillId2
	}
	return 0
}

func (m *DiyCardData) GetMinUp() int32 {
	if m != nil {
		return m.MinUp
	}
	return 0
}

func (m *DiyCardData) GetMaxUp() int32 {
	if m != nil {
		return m.MaxUp
	}
	return 0
}

func (m *DiyCardData) GetMinDown() int32 {
	if m != nil {
		return m.MinDown
	}
	return 0
}

func (m *DiyCardData) GetMaxDown() int32 {
	if m != nil {
		return m.MaxDown
	}
	return 0
}

func (m *DiyCardData) GetMinLeft() int32 {
	if m != nil {
		return m.MinLeft
	}
	return 0
}

func (m *DiyCardData) GetMaxLeft() int32 {
	if m != nil {
		return m.MaxLeft
	}
	return 0
}

func (m *DiyCardData) GetMinRight() int32 {
	if m != nil {
		return m.MinRight
	}
	return 0
}

func (m *DiyCardData) GetMaxRight() int32 {
	if m != nil {
		return m.MaxRight
	}
	return 0
}

func (m *DiyCardData) GetWeapon() string {
	if m != nil {
		return m.Weapon
	}
	return ""
}

type DiyCardImg struct {
	Img string `protobuf:"bytes,1,opt,name=Img,proto3" json:"Img,omitempty"`
}

func (m *DiyCardImg) Reset()                    { *m = DiyCardImg{} }
func (m *DiyCardImg) String() string            { return proto.CompactTextString(m) }
func (*DiyCardImg) ProtoMessage()               {}
func (*DiyCardImg) Descriptor() ([]byte, []int) { return fileDescriptorCard, []int{12} }

func (m *DiyCardImg) GetImg() string {
	if m != nil {
		return m.Img
	}
	return ""
}

type AddCardSkinArg struct {
	Skin string `protobuf:"bytes,1,opt,name=Skin,proto3" json:"Skin,omitempty"`
}

func (m *AddCardSkinArg) Reset()                    { *m = AddCardSkinArg{} }
func (m *AddCardSkinArg) String() string            { return proto.CompactTextString(m) }
func (*AddCardSkinArg) ProtoMessage()               {}
func (*AddCardSkinArg) Descriptor() ([]byte, []int) { return fileDescriptorCard, []int{13} }

func (m *AddCardSkinArg) GetSkin() string {
	if m != nil {
		return m.Skin
	}
	return ""
}

type SkinGCard struct {
	GCardID uint32 `protobuf:"varint,1,opt,name=GCardID,proto3" json:"GCardID,omitempty"`
	Skin    string `protobuf:"bytes,2,opt,name=Skin,proto3" json:"Skin,omitempty"`
	Equip   string `protobuf:"bytes,3,opt,name=Equip,proto3" json:"Equip,omitempty"`
}

func (m *SkinGCard) Reset()                    { *m = SkinGCard{} }
func (m *SkinGCard) String() string            { return proto.CompactTextString(m) }
func (*SkinGCard) ProtoMessage()               {}
func (*SkinGCard) Descriptor() ([]byte, []int) { return fileDescriptorCard, []int{14} }

func (m *SkinGCard) GetGCardID() uint32 {
	if m != nil {
		return m.GCardID
	}
	return 0
}

func (m *SkinGCard) GetSkin() string {
	if m != nil {
		return m.Skin
	}
	return ""
}

func (m *SkinGCard) GetEquip() string {
	if m != nil {
		return m.Equip
	}
	return ""
}

type SkinCard struct {
	CardID uint32 `protobuf:"varint,1,opt,name=CardID,proto3" json:"CardID,omitempty"`
	Skin   string `protobuf:"bytes,2,opt,name=Skin,proto3" json:"Skin,omitempty"`
	Equip  string `protobuf:"bytes,3,opt,name=Equip,proto3" json:"Equip,omitempty"`
}

func (m *SkinCard) Reset()                    { *m = SkinCard{} }
func (m *SkinCard) String() string            { return proto.CompactTextString(m) }
func (*SkinCard) ProtoMessage()               {}
func (*SkinCard) Descriptor() ([]byte, []int) { return fileDescriptorCard, []int{15} }

func (m *SkinCard) GetCardID() uint32 {
	if m != nil {
		return m.CardID
	}
	return 0
}

func (m *SkinCard) GetSkin() string {
	if m != nil {
		return m.Skin
	}
	return ""
}

func (m *SkinCard) GetEquip() string {
	if m != nil {
		return m.Equip
	}
	return ""
}

type UpLevelCardArg struct {
	CardId        uint32 `protobuf:"varint,1,opt,name=CardId,proto3" json:"CardId,omitempty"`
	IsConsumeJade bool   `protobuf:"varint,2,opt,name=IsConsumeJade,proto3" json:"IsConsumeJade,omitempty"`
	IsNeedJade    bool   `protobuf:"varint,3,opt,name=IsNeedJade,proto3" json:"IsNeedJade,omitempty"`
}

func (m *UpLevelCardArg) Reset()                    { *m = UpLevelCardArg{} }
func (m *UpLevelCardArg) String() string            { return proto.CompactTextString(m) }
func (*UpLevelCardArg) ProtoMessage()               {}
func (*UpLevelCardArg) Descriptor() ([]byte, []int) { return fileDescriptorCard, []int{16} }

func (m *UpLevelCardArg) GetCardId() uint32 {
	if m != nil {
		return m.CardId
	}
	return 0
}

func (m *UpLevelCardArg) GetIsConsumeJade() bool {
	if m != nil {
		return m.IsConsumeJade
	}
	return false
}

func (m *UpLevelCardArg) GetIsNeedJade() bool {
	if m != nil {
		return m.IsNeedJade
	}
	return false
}

type UnlockCardLevelArg struct {
	CardID uint32 `protobuf:"varint,1,opt,name=CardID,proto3" json:"CardID,omitempty"`
	Level  int32  `protobuf:"varint,2,opt,name=Level,proto3" json:"Level,omitempty"`
}

func (m *UnlockCardLevelArg) Reset()                    { *m = UnlockCardLevelArg{} }
func (m *UnlockCardLevelArg) String() string            { return proto.CompactTextString(m) }
func (*UnlockCardLevelArg) ProtoMessage()               {}
func (*UnlockCardLevelArg) Descriptor() ([]byte, []int) { return fileDescriptorCard, []int{17} }

func (m *UnlockCardLevelArg) GetCardID() uint32 {
	if m != nil {
		return m.CardID
	}
	return 0
}

func (m *UnlockCardLevelArg) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

type BackCardUnlockArg struct {
	CardID uint32 `protobuf:"varint,1,opt,name=CardID,proto3" json:"CardID,omitempty"`
	Level  int32  `protobuf:"varint,2,opt,name=Level,proto3" json:"Level,omitempty"`
}

func (m *BackCardUnlockArg) Reset()                    { *m = BackCardUnlockArg{} }
func (m *BackCardUnlockArg) String() string            { return proto.CompactTextString(m) }
func (*BackCardUnlockArg) ProtoMessage()               {}
func (*BackCardUnlockArg) Descriptor() ([]byte, []int) { return fileDescriptorCard, []int{18} }

func (m *BackCardUnlockArg) GetCardID() uint32 {
	if m != nil {
		return m.CardID
	}
	return 0
}

func (m *BackCardUnlockArg) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

type BackCardUnlockReply struct {
	CardId     uint32      `protobuf:"varint,1,opt,name=CardId,proto3" json:"CardId,omitempty"`
	CardAmount int32       `protobuf:"varint,2,opt,name=CardAmount,proto3" json:"CardAmount,omitempty"`
	Resources  []*Resource `protobuf:"bytes,3,rep,name=Resources" json:"Resources,omitempty"`
}

func (m *BackCardUnlockReply) Reset()                    { *m = BackCardUnlockReply{} }
func (m *BackCardUnlockReply) String() string            { return proto.CompactTextString(m) }
func (*BackCardUnlockReply) ProtoMessage()               {}
func (*BackCardUnlockReply) Descriptor() ([]byte, []int) { return fileDescriptorCard, []int{19} }

func (m *BackCardUnlockReply) GetCardId() uint32 {
	if m != nil {
		return m.CardId
	}
	return 0
}

func (m *BackCardUnlockReply) GetCardAmount() int32 {
	if m != nil {
		return m.CardAmount
	}
	return 0
}

func (m *BackCardUnlockReply) GetResources() []*Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

func init() {
	proto.RegisterType((*CardPool)(nil), "pb.CardPool")
	proto.RegisterType((*CardInfo)(nil), "pb.CardInfo")
	proto.RegisterType((*CardPools)(nil), "pb.CardPools")
	proto.RegisterType((*CardDatas)(nil), "pb.CardDatas")
	proto.RegisterType((*PoolAddCard)(nil), "pb.PoolAddCard")
	proto.RegisterType((*PoolUpdateCard)(nil), "pb.PoolUpdateCard")
	proto.RegisterType((*FightPool)(nil), "pb.FightPool")
	proto.RegisterType((*UpdateCardPools)(nil), "pb.UpdateCardPools")
	proto.RegisterType((*TargetCard)(nil), "pb.TargetCard")
	proto.RegisterType((*DiyCardArg)(nil), "pb.DiyCardArg")
	proto.RegisterType((*DiyCardReply)(nil), "pb.DiyCardReply")
	proto.RegisterType((*DiyCardData)(nil), "pb.DiyCardData")
	proto.RegisterType((*DiyCardImg)(nil), "pb.DiyCardImg")
	proto.RegisterType((*AddCardSkinArg)(nil), "pb.AddCardSkinArg")
	proto.RegisterType((*SkinGCard)(nil), "pb.SkinGCard")
	proto.RegisterType((*SkinCard)(nil), "pb.SkinCard")
	proto.RegisterType((*UpLevelCardArg)(nil), "pb.UpLevelCardArg")
	proto.RegisterType((*UnlockCardLevelArg)(nil), "pb.UnlockCardLevelArg")
	proto.RegisterType((*BackCardUnlockArg)(nil), "pb.BackCardUnlockArg")
	proto.RegisterType((*BackCardUnlockReply)(nil), "pb.BackCardUnlockReply")
	proto.RegisterEnum("pb.CardState", CardState_name, CardState_value)
}
func (m *CardPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardPool) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PoolId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.PoolId))
	}
	if len(m.Cards) > 0 {
		dAtA2 := make([]byte, len(m.Cards)*10)
		var j1 int
		for _, num := range m.Cards {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintCard(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if m.Camp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.Camp))
	}
	if m.IsFight {
		dAtA[i] = 0x20
		i++
		if m.IsFight {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CardInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CardId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.CardId))
	}
	if m.Level != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.Level))
	}
	if m.Amount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.Amount))
	}
	if m.Energy != 0 {
		dAtA[i] = 0x25
		i++
		binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Energy))))
		i += 4
	}
	if len(m.Skin) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCard(dAtA, i, uint64(len(m.Skin)))
		i += copy(dAtA[i:], m.Skin)
	}
	if len(m.Equip) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintCard(dAtA, i, uint64(len(m.Equip)))
		i += copy(dAtA[i:], m.Equip)
	}
	if m.State != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.State))
	}
	if m.MaxUnlockLevel != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.MaxUnlockLevel))
	}
	return i, nil
}

func (m *CardPools) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardPools) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Pools) > 0 {
		for _, msg := range m.Pools {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCard(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.FightCamp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.FightCamp))
	}
	return i, nil
}

func (m *CardDatas) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CardDatas) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Cards) > 0 {
		for _, msg := range m.Cards {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCard(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DiyCards) > 0 {
		for _, msg := range m.DiyCards {
			dAtA[i] = 0x12
			i++
			i = encodeVarintCard(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PoolAddCard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolAddCard) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Card != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.Card))
	}
	if m.Idx != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.Idx))
	}
	if m.PoolId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.PoolId))
	}
	return i, nil
}

func (m *PoolUpdateCard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PoolUpdateCard) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PoolId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.PoolId))
	}
	if len(m.Cards) > 0 {
		dAtA4 := make([]byte, len(m.Cards)*10)
		var j3 int
		for _, num := range m.Cards {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintCard(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	return i, nil
}

func (m *FightPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightPool) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PoolId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.PoolId))
	}
	if m.Camp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.Camp))
	}
	return i, nil
}

func (m *UpdateCardPools) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateCardPools) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Pools) > 0 {
		for _, msg := range m.Pools {
			dAtA[i] = 0xa
			i++
			i = encodeVarintCard(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.FightCamp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.FightCamp))
	}
	return i, nil
}

func (m *TargetCard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TargetCard) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CardId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.CardId))
	}
	return i, nil
}

func (m *DiyCardArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiyCardArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCard(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.DiySkillId1 != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.DiySkillId1))
	}
	if m.DiySkillId2 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.DiySkillId2))
	}
	if len(m.Weapon) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintCard(dAtA, i, uint64(len(m.Weapon)))
		i += copy(dAtA[i:], m.Weapon)
	}
	if len(m.Img) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintCard(dAtA, i, uint64(len(m.Img)))
		i += copy(dAtA[i:], m.Img)
	}
	return i, nil
}

func (m *DiyCardReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiyCardReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CardId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.CardId))
	}
	if m.MinUp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.MinUp))
	}
	if m.MaxUp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.MaxUp))
	}
	if m.MinDown != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.MinDown))
	}
	if m.MaxDown != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.MaxDown))
	}
	if m.MinLeft != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.MinLeft))
	}
	if m.MaxLeft != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.MaxLeft))
	}
	if m.MinRight != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.MinRight))
	}
	if m.MaxRight != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.MaxRight))
	}
	return i, nil
}

func (m *DiyCardData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiyCardData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CardId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.CardId))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCard(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.DiySkillId1 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.DiySkillId1))
	}
	if m.DiySkillId2 != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.DiySkillId2))
	}
	if m.MinUp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.MinUp))
	}
	if m.MaxUp != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.MaxUp))
	}
	if m.MinDown != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.MinDown))
	}
	if m.MaxDown != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.MaxDown))
	}
	if m.MinLeft != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.MinLeft))
	}
	if m.MaxLeft != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.MaxLeft))
	}
	if m.MinRight != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.MinRight))
	}
	if m.MaxRight != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.MaxRight))
	}
	if len(m.Weapon) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintCard(dAtA, i, uint64(len(m.Weapon)))
		i += copy(dAtA[i:], m.Weapon)
	}
	return i, nil
}

func (m *DiyCardImg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiyCardImg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Img) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCard(dAtA, i, uint64(len(m.Img)))
		i += copy(dAtA[i:], m.Img)
	}
	return i, nil
}

func (m *AddCardSkinArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddCardSkinArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Skin) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintCard(dAtA, i, uint64(len(m.Skin)))
		i += copy(dAtA[i:], m.Skin)
	}
	return i, nil
}

func (m *SkinGCard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SkinGCard) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GCardID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.GCardID))
	}
	if len(m.Skin) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCard(dAtA, i, uint64(len(m.Skin)))
		i += copy(dAtA[i:], m.Skin)
	}
	if len(m.Equip) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCard(dAtA, i, uint64(len(m.Equip)))
		i += copy(dAtA[i:], m.Equip)
	}
	return i, nil
}

func (m *SkinCard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SkinCard) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CardID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.CardID))
	}
	if len(m.Skin) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintCard(dAtA, i, uint64(len(m.Skin)))
		i += copy(dAtA[i:], m.Skin)
	}
	if len(m.Equip) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintCard(dAtA, i, uint64(len(m.Equip)))
		i += copy(dAtA[i:], m.Equip)
	}
	return i, nil
}

func (m *UpLevelCardArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpLevelCardArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CardId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.CardId))
	}
	if m.IsConsumeJade {
		dAtA[i] = 0x10
		i++
		if m.IsConsumeJade {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsNeedJade {
		dAtA[i] = 0x18
		i++
		if m.IsNeedJade {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *UnlockCardLevelArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnlockCardLevelArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CardID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.CardID))
	}
	if m.Level != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.Level))
	}
	return i, nil
}

func (m *BackCardUnlockArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackCardUnlockArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CardID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.CardID))
	}
	if m.Level != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.Level))
	}
	return i, nil
}

func (m *BackCardUnlockReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BackCardUnlockReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CardId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.CardId))
	}
	if m.CardAmount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintCard(dAtA, i, uint64(m.CardAmount))
	}
	if len(m.Resources) > 0 {
		for _, msg := range m.Resources {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintCard(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func encodeVarintCard(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *CardPool) Size() (n int) {
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovCard(uint64(m.PoolId))
	}
	if len(m.Cards) > 0 {
		l = 0
		for _, e := range m.Cards {
			l += sovCard(uint64(e))
		}
		n += 1 + sovCard(uint64(l)) + l
	}
	if m.Camp != 0 {
		n += 1 + sovCard(uint64(m.Camp))
	}
	if m.IsFight {
		n += 2
	}
	return n
}

func (m *CardInfo) Size() (n int) {
	var l int
	_ = l
	if m.CardId != 0 {
		n += 1 + sovCard(uint64(m.CardId))
	}
	if m.Level != 0 {
		n += 1 + sovCard(uint64(m.Level))
	}
	if m.Amount != 0 {
		n += 1 + sovCard(uint64(m.Amount))
	}
	if m.Energy != 0 {
		n += 5
	}
	l = len(m.Skin)
	if l > 0 {
		n += 1 + l + sovCard(uint64(l))
	}
	l = len(m.Equip)
	if l > 0 {
		n += 1 + l + sovCard(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovCard(uint64(m.State))
	}
	if m.MaxUnlockLevel != 0 {
		n += 1 + sovCard(uint64(m.MaxUnlockLevel))
	}
	return n
}

func (m *CardPools) Size() (n int) {
	var l int
	_ = l
	if len(m.Pools) > 0 {
		for _, e := range m.Pools {
			l = e.Size()
			n += 1 + l + sovCard(uint64(l))
		}
	}
	if m.FightCamp != 0 {
		n += 1 + sovCard(uint64(m.FightCamp))
	}
	return n
}

func (m *CardDatas) Size() (n int) {
	var l int
	_ = l
	if len(m.Cards) > 0 {
		for _, e := range m.Cards {
			l = e.Size()
			n += 1 + l + sovCard(uint64(l))
		}
	}
	if len(m.DiyCards) > 0 {
		for _, e := range m.DiyCards {
			l = e.Size()
			n += 1 + l + sovCard(uint64(l))
		}
	}
	return n
}

func (m *PoolAddCard) Size() (n int) {
	var l int
	_ = l
	if m.Card != 0 {
		n += 1 + sovCard(uint64(m.Card))
	}
	if m.Idx != 0 {
		n += 1 + sovCard(uint64(m.Idx))
	}
	if m.PoolId != 0 {
		n += 1 + sovCard(uint64(m.PoolId))
	}
	return n
}

func (m *PoolUpdateCard) Size() (n int) {
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovCard(uint64(m.PoolId))
	}
	if len(m.Cards) > 0 {
		l = 0
		for _, e := range m.Cards {
			l += sovCard(uint64(e))
		}
		n += 1 + sovCard(uint64(l)) + l
	}
	return n
}

func (m *FightPool) Size() (n int) {
	var l int
	_ = l
	if m.PoolId != 0 {
		n += 1 + sovCard(uint64(m.PoolId))
	}
	if m.Camp != 0 {
		n += 1 + sovCard(uint64(m.Camp))
	}
	return n
}

func (m *UpdateCardPools) Size() (n int) {
	var l int
	_ = l
	if len(m.Pools) > 0 {
		for _, e := range m.Pools {
			l = e.Size()
			n += 1 + l + sovCard(uint64(l))
		}
	}
	if m.FightCamp != 0 {
		n += 1 + sovCard(uint64(m.FightCamp))
	}
	return n
}

func (m *TargetCard) Size() (n int) {
	var l int
	_ = l
	if m.CardId != 0 {
		n += 1 + sovCard(uint64(m.CardId))
	}
	return n
}

func (m *DiyCardArg) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCard(uint64(l))
	}
	if m.DiySkillId1 != 0 {
		n += 1 + sovCard(uint64(m.DiySkillId1))
	}
	if m.DiySkillId2 != 0 {
		n += 1 + sovCard(uint64(m.DiySkillId2))
	}
	l = len(m.Weapon)
	if l > 0 {
		n += 1 + l + sovCard(uint64(l))
	}
	l = len(m.Img)
	if l > 0 {
		n += 1 + l + sovCard(uint64(l))
	}
	return n
}

func (m *DiyCardReply) Size() (n int) {
	var l int
	_ = l
	if m.CardId != 0 {
		n += 1 + sovCard(uint64(m.CardId))
	}
	if m.MinUp != 0 {
		n += 1 + sovCard(uint64(m.MinUp))
	}
	if m.MaxUp != 0 {
		n += 1 + sovCard(uint64(m.MaxUp))
	}
	if m.MinDown != 0 {
		n += 1 + sovCard(uint64(m.MinDown))
	}
	if m.MaxDown != 0 {
		n += 1 + sovCard(uint64(m.MaxDown))
	}
	if m.MinLeft != 0 {
		n += 1 + sovCard(uint64(m.MinLeft))
	}
	if m.MaxLeft != 0 {
		n += 1 + sovCard(uint64(m.MaxLeft))
	}
	if m.MinRight != 0 {
		n += 1 + sovCard(uint64(m.MinRight))
	}
	if m.MaxRight != 0 {
		n += 1 + sovCard(uint64(m.MaxRight))
	}
	return n
}

func (m *DiyCardData) Size() (n int) {
	var l int
	_ = l
	if m.CardId != 0 {
		n += 1 + sovCard(uint64(m.CardId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCard(uint64(l))
	}
	if m.DiySkillId1 != 0 {
		n += 1 + sovCard(uint64(m.DiySkillId1))
	}
	if m.DiySkillId2 != 0 {
		n += 1 + sovCard(uint64(m.DiySkillId2))
	}
	if m.MinUp != 0 {
		n += 1 + sovCard(uint64(m.MinUp))
	}
	if m.MaxUp != 0 {
		n += 1 + sovCard(uint64(m.MaxUp))
	}
	if m.MinDown != 0 {
		n += 1 + sovCard(uint64(m.MinDown))
	}
	if m.MaxDown != 0 {
		n += 1 + sovCard(uint64(m.MaxDown))
	}
	if m.MinLeft != 0 {
		n += 1 + sovCard(uint64(m.MinLeft))
	}
	if m.MaxLeft != 0 {
		n += 1 + sovCard(uint64(m.MaxLeft))
	}
	if m.MinRight != 0 {
		n += 1 + sovCard(uint64(m.MinRight))
	}
	if m.MaxRight != 0 {
		n += 1 + sovCard(uint64(m.MaxRight))
	}
	l = len(m.Weapon)
	if l > 0 {
		n += 1 + l + sovCard(uint64(l))
	}
	return n
}

func (m *DiyCardImg) Size() (n int) {
	var l int
	_ = l
	l = len(m.Img)
	if l > 0 {
		n += 1 + l + sovCard(uint64(l))
	}
	return n
}

func (m *AddCardSkinArg) Size() (n int) {
	var l int
	_ = l
	l = len(m.Skin)
	if l > 0 {
		n += 1 + l + sovCard(uint64(l))
	}
	return n
}

func (m *SkinGCard) Size() (n int) {
	var l int
	_ = l
	if m.GCardID != 0 {
		n += 1 + sovCard(uint64(m.GCardID))
	}
	l = len(m.Skin)
	if l > 0 {
		n += 1 + l + sovCard(uint64(l))
	}
	l = len(m.Equip)
	if l > 0 {
		n += 1 + l + sovCard(uint64(l))
	}
	return n
}

func (m *SkinCard) Size() (n int) {
	var l int
	_ = l
	if m.CardID != 0 {
		n += 1 + sovCard(uint64(m.CardID))
	}
	l = len(m.Skin)
	if l > 0 {
		n += 1 + l + sovCard(uint64(l))
	}
	l = len(m.Equip)
	if l > 0 {
		n += 1 + l + sovCard(uint64(l))
	}
	return n
}

func (m *UpLevelCardArg) Size() (n int) {
	var l int
	_ = l
	if m.CardId != 0 {
		n += 1 + sovCard(uint64(m.CardId))
	}
	if m.IsConsumeJade {
		n += 2
	}
	if m.IsNeedJade {
		n += 2
	}
	return n
}

func (m *UnlockCardLevelArg) Size() (n int) {
	var l int
	_ = l
	if m.CardID != 0 {
		n += 1 + sovCard(uint64(m.CardID))
	}
	if m.Level != 0 {
		n += 1 + sovCard(uint64(m.Level))
	}
	return n
}

func (m *BackCardUnlockArg) Size() (n int) {
	var l int
	_ = l
	if m.CardID != 0 {
		n += 1 + sovCard(uint64(m.CardID))
	}
	if m.Level != 0 {
		n += 1 + sovCard(uint64(m.Level))
	}
	return n
}

func (m *BackCardUnlockReply) Size() (n int) {
	var l int
	_ = l
	if m.CardId != 0 {
		n += 1 + sovCard(uint64(m.CardId))
	}
	if m.CardAmount != 0 {
		n += 1 + sovCard(uint64(m.CardAmount))
	}
	if len(m.Resources) > 0 {
		for _, e := range m.Resources {
			l = e.Size()
			n += 1 + l + sovCard(uint64(l))
		}
	}
	return n
}

func sovCard(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozCard(x uint64) (n int) {
	return sovCard(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CardPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cards = append(m.Cards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCard
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cards = append(m.Cards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Camp", wireType)
			}
			m.Camp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Camp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFight", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFight = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardId", wireType)
			}
			m.CardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			m.Amount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Amount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Energy", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Energy = float32(math.Float32frombits(v))
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCard
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Skin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Equip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCard
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Equip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (CardState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUnlockLevel", wireType)
			}
			m.MaxUnlockLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxUnlockLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardPools) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardPools: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardPools: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCard
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pools = append(m.Pools, &CardPool{})
			if err := m.Pools[len(m.Pools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightCamp", wireType)
			}
			m.FightCamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightCamp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CardDatas) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CardDatas: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CardDatas: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCard
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cards = append(m.Cards, &CardInfo{})
			if err := m.Cards[len(m.Cards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiyCards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCard
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DiyCards = append(m.DiyCards, &DiyCardData{})
			if err := m.DiyCards[len(m.DiyCards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoolAddCard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolAddCard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolAddCard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Card", wireType)
			}
			m.Card = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Card |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idx", wireType)
			}
			m.Idx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Idx |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PoolUpdateCard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PoolUpdateCard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PoolUpdateCard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cards = append(m.Cards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCard
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCard
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCard
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cards = append(m.Cards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolId", wireType)
			}
			m.PoolId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Camp", wireType)
			}
			m.Camp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Camp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateCardPools) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateCardPools: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateCardPools: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCard
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pools = append(m.Pools, &FightPool{})
			if err := m.Pools[len(m.Pools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FightCamp", wireType)
			}
			m.FightCamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FightCamp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TargetCard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TargetCard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TargetCard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardId", wireType)
			}
			m.CardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiyCardArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiyCardArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiyCardArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCard
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiySkillId1", wireType)
			}
			m.DiySkillId1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiySkillId1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiySkillId2", wireType)
			}
			m.DiySkillId2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiySkillId2 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weapon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCard
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Weapon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Img", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCard
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Img = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiyCardReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiyCardReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiyCardReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardId", wireType)
			}
			m.CardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinUp", wireType)
			}
			m.MinUp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinUp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUp", wireType)
			}
			m.MaxUp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxUp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDown", wireType)
			}
			m.MinDown = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinDown |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDown", wireType)
			}
			m.MaxDown = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDown |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLeft", wireType)
			}
			m.MinLeft = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinLeft |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLeft", wireType)
			}
			m.MaxLeft = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLeft |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinRight", wireType)
			}
			m.MinRight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinRight |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRight", wireType)
			}
			m.MaxRight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRight |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiyCardData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiyCardData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiyCardData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardId", wireType)
			}
			m.CardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCard
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiySkillId1", wireType)
			}
			m.DiySkillId1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiySkillId1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiySkillId2", wireType)
			}
			m.DiySkillId2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiySkillId2 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinUp", wireType)
			}
			m.MinUp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinUp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxUp", wireType)
			}
			m.MaxUp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxUp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDown", wireType)
			}
			m.MinDown = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinDown |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDown", wireType)
			}
			m.MaxDown = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDown |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinLeft", wireType)
			}
			m.MinLeft = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinLeft |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLeft", wireType)
			}
			m.MaxLeft = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLeft |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinRight", wireType)
			}
			m.MinRight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinRight |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRight", wireType)
			}
			m.MaxRight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRight |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weapon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCard
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Weapon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiyCardImg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiyCardImg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiyCardImg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Img", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCard
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Img = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddCardSkinArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddCardSkinArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddCardSkinArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCard
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Skin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SkinGCard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SkinGCard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SkinGCard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GCardID", wireType)
			}
			m.GCardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GCardID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCard
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Skin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Equip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCard
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Equip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SkinCard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SkinCard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SkinCard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardID", wireType)
			}
			m.CardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCard
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Skin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Equip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCard
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Equip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpLevelCardArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpLevelCardArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpLevelCardArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardId", wireType)
			}
			m.CardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsConsumeJade", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsConsumeJade = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsNeedJade", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsNeedJade = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnlockCardLevelArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnlockCardLevelArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnlockCardLevelArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardID", wireType)
			}
			m.CardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackCardUnlockArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackCardUnlockArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackCardUnlockArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardID", wireType)
			}
			m.CardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BackCardUnlockReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCard
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BackCardUnlockReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BackCardUnlockReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardId", wireType)
			}
			m.CardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardAmount", wireType)
			}
			m.CardAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCard
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCard
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, &Resource{})
			if err := m.Resources[len(m.Resources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCard(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCard
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCard(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCard
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCard
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCard
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthCard
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCard
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCard(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCard = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCard   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("card.proto", fileDescriptorCard) }

var fileDescriptorCard = []byte{
	// 870 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0x5f, 0x6f, 0xe3, 0x44,
	0x10, 0x3f, 0xdb, 0x4d, 0x13, 0x4f, 0xfe, 0x34, 0x2c, 0x08, 0x59, 0x27, 0x14, 0x45, 0x7b, 0x15,
	0x8a, 0x0e, 0xa9, 0x12, 0xe5, 0x81, 0x37, 0x44, 0xdb, 0x1c, 0xc8, 0xd0, 0x94, 0xd3, 0xf6, 0x22,
	0x5e, 0x78, 0xd9, 0xd6, 0xdb, 0x60, 0x35, 0x5e, 0x1b, 0xdb, 0x3d, 0x92, 0x2f, 0xc1, 0x33, 0x1f,
	0x89, 0x47, 0xbe, 0x01, 0x50, 0xbe, 0x01, 0x9f, 0x00, 0xed, 0xec, 0x6e, 0xec, 0x94, 0x3a, 0x5c,
	0x9f, 0x32, 0xbf, 0x99, 0xd9, 0x99, 0xf5, 0x6f, 0xfe, 0x6c, 0x00, 0xae, 0x79, 0x1e, 0x1d, 0x65,
	0x79, 0x5a, 0xa6, 0xc4, 0xcd, 0xae, 0x9e, 0xf7, 0xae, 0xd3, 0x24, 0x49, 0xa5, 0xd6, 0xd0, 0x1b,
	0xe8, 0x9c, 0xf1, 0x3c, 0x7a, 0x9d, 0xa6, 0x4b, 0xf2, 0x21, 0xec, 0xab, 0xdf, 0x30, 0x0a, 0x9c,
	0xb1, 0x33, 0x69, 0x31, 0x83, 0xc8, 0x07, 0xd0, 0x52, 0x3e, 0x45, 0xe0, 0x8e, 0xbd, 0x49, 0x9f,
	0x69, 0x40, 0x08, 0xec, 0x9d, 0xf1, 0x24, 0x0b, 0x3c, 0xf4, 0x45, 0x99, 0x04, 0xd0, 0x0e, 0x8b,
	0xaf, 0xe2, 0xc5, 0x8f, 0x65, 0xb0, 0x37, 0x76, 0x26, 0x1d, 0x66, 0x21, 0xfd, 0xc3, 0xd1, 0x89,
	0x42, 0x79, 0x93, 0xaa, 0x44, 0x28, 0xeb, 0x44, 0x7d, 0x66, 0x90, 0x4a, 0x74, 0x2e, 0xde, 0x8a,
	0x65, 0xe0, 0x62, 0x4c, 0x0d, 0x94, 0xf7, 0x49, 0x92, 0xde, 0xc9, 0xd2, 0xa4, 0x32, 0x48, 0xe9,
	0x5f, 0x49, 0x91, 0x2f, 0xd6, 0x98, 0xcb, 0x65, 0x06, 0xa9, 0x8b, 0x5d, 0xde, 0xc6, 0x32, 0x68,
	0x8d, 0x9d, 0x89, 0xcf, 0x50, 0x56, 0x91, 0x5f, 0xfd, 0x74, 0x17, 0x67, 0xc1, 0x3e, 0x2a, 0x35,
	0x20, 0x2f, 0xa0, 0x75, 0x59, 0xf2, 0x52, 0x04, 0xed, 0xb1, 0x33, 0x19, 0x1c, 0xf7, 0x8f, 0xb2,
	0xab, 0x23, 0x75, 0x15, 0x54, 0x32, 0x6d, 0x23, 0x1f, 0xc3, 0x60, 0xc6, 0x57, 0x73, 0xb9, 0x4c,
	0xaf, 0x6f, 0xf5, 0xed, 0x3a, 0x78, 0x8d, 0x07, 0x5a, 0x3a, 0x03, 0xdf, 0x32, 0x59, 0x10, 0x0a,
	0x2d, 0x14, 0x02, 0x67, 0xec, 0x4d, 0xba, 0xc7, 0x3d, 0x1b, 0x59, 0x29, 0x99, 0x36, 0x91, 0x8f,
	0xc0, 0x47, 0x6e, 0x90, 0x45, 0xfd, 0xc5, 0x95, 0x82, 0xfe, 0xa0, 0xc3, 0x4d, 0x79, 0xc9, 0x31,
	0x9c, 0xae, 0xc0, 0x83, 0x70, 0x8a, 0x4d, 0x5b, 0x8f, 0x4f, 0xa0, 0x33, 0x8d, 0xd7, 0x55, 0xa1,
	0xba, 0xc7, 0x07, 0xca, 0xcd, 0xe8, 0x54, 0x1c, 0xb6, 0x71, 0xa0, 0xdf, 0x42, 0x57, 0x5d, 0xe2,
	0x24, 0x8a, 0x14, 0xd6, 0xb5, 0xcc, 0x6d, 0x39, 0x50, 0x26, 0x43, 0xf0, 0xc2, 0x68, 0x65, 0x2e,
	0xa6, 0xc4, 0x5a, 0x7f, 0x78, 0xf5, 0xfe, 0xa0, 0x5f, 0xc0, 0x40, 0x49, 0xf3, 0x2c, 0xe2, 0xa5,
	0xc0, 0xb3, 0x4f, 0xea, 0x24, 0xfa, 0xb9, 0x21, 0x62, 0x67, 0x13, 0xda, 0x76, 0x73, 0xab, 0x76,
	0xa3, 0x6f, 0xe0, 0xa0, 0x4a, 0xaa, 0x49, 0x7d, 0xb1, 0x4d, 0x3c, 0x96, 0x74, 0x13, 0xfc, 0xdd,
	0x98, 0x3f, 0x04, 0x78, 0xc3, 0xf3, 0x85, 0x28, 0xed, 0xa7, 0x3c, 0xd6, 0xab, 0xf4, 0x17, 0x07,
	0xc0, 0xd0, 0x79, 0x92, 0x2f, 0xd4, 0xf5, 0x2e, 0x78, 0x22, 0xd0, 0xc9, 0x67, 0x28, 0x93, 0x31,
	0x74, 0xa7, 0xf1, 0xfa, 0xf2, 0x36, 0x5e, 0x2e, 0xc3, 0xe8, 0x53, 0x93, 0xa8, 0xae, 0xda, 0xf6,
	0x38, 0x36, 0xb4, 0xd6, 0x55, 0x2a, 0xfd, 0xf7, 0x82, 0x67, 0xa9, 0xc4, 0x26, 0xf7, 0x99, 0x41,
	0x58, 0x9d, 0x64, 0x61, 0x7a, 0x5c, 0x89, 0xf4, 0x1f, 0x07, 0x7a, 0xe6, 0x42, 0x4c, 0x64, 0xcb,
	0xf5, 0xae, 0x29, 0x9b, 0xc5, 0x72, 0x6e, 0xbf, 0x5c, 0x03, 0xd4, 0xf2, 0xd5, 0xdc, 0xce, 0xb3,
	0x06, 0x6a, 0xa0, 0x67, 0xb1, 0x9c, 0xa6, 0x3f, 0xeb, 0xfc, 0x2d, 0x66, 0x21, 0x5a, 0xf8, 0x0a,
	0x2d, 0x2d, 0x63, 0xd1, 0xd0, 0x9c, 0x39, 0x17, 0x37, 0x25, 0x4e, 0x9b, 0x3e, 0xa3, 0xa0, 0x39,
	0x83, 0x96, 0xf6, 0xe6, 0x0c, 0x5a, 0x9e, 0x43, 0x67, 0x16, 0x4b, 0x86, 0x9b, 0x43, 0x8f, 0xd7,
	0x06, 0xa3, 0x8d, 0xaf, 0xb4, 0xcd, 0x37, 0x36, 0x83, 0xe9, 0x5f, 0x2e, 0x32, 0x68, 0x3b, 0xbc,
	0xf1, 0x9b, 0x6d, 0x79, 0xdc, 0xe6, 0xf2, 0x78, 0xff, 0x5b, 0x9e, 0xbd, 0xff, 0x96, 0x67, 0xc3,
	0x65, 0xeb, 0x51, 0x2e, 0xf7, 0x1b, 0xb8, 0x6c, 0x37, 0x72, 0xd9, 0x69, 0xe4, 0xd2, 0x6f, 0xe4,
	0x12, 0x9a, 0xb9, 0xec, 0xee, 0xe0, 0xb2, 0xb7, 0xcd, 0x65, 0xad, 0xd5, 0xfa, 0xf5, 0x56, 0xa3,
	0xa3, 0x4d, 0xa3, 0x87, 0xc9, 0xc2, 0x36, 0x9e, 0x53, 0x35, 0xde, 0x21, 0x0c, 0xcc, 0x1e, 0x51,
	0xab, 0xd6, 0x0c, 0x03, 0x6e, 0x60, 0xa7, 0xda, 0xc0, 0xf4, 0x3b, 0xf0, 0xd5, 0xef, 0xd7, 0x38,
	0x54, 0x01, 0xb4, 0x51, 0x08, 0xa7, 0xa6, 0x4e, 0x16, 0x6e, 0x8e, 0xba, 0x8f, 0x2d, 0x6f, 0xaf,
	0xb6, 0xbc, 0xe9, 0x39, 0x74, 0x94, 0x75, 0x6b, 0x48, 0xa7, 0x5b, 0x65, 0x7f, 0x4a, 0x34, 0x09,
	0x83, 0x79, 0x86, 0x8b, 0xdc, 0x4e, 0x74, 0x53, 0x2b, 0x1d, 0x42, 0x3f, 0x2c, 0xce, 0x52, 0x59,
	0xdc, 0x25, 0xe2, 0x1b, 0x1e, 0xe9, 0x9e, 0xea, 0xb0, 0x6d, 0x25, 0x19, 0x01, 0x84, 0xc5, 0x85,
	0x10, 0x11, 0xba, 0x78, 0xe8, 0x52, 0xd3, 0xd0, 0x53, 0x20, 0xfa, 0xf1, 0x50, 0x51, 0x31, 0x6f,
	0x3d, 0xe7, 0xc3, 0xef, 0x78, 0xf4, 0x61, 0xa4, 0x27, 0xf0, 0xde, 0x29, 0xd7, 0x11, 0x74, 0xac,
	0xa7, 0x87, 0x58, 0xc3, 0xfb, 0xdb, 0x21, 0x76, 0xaf, 0x8e, 0x11, 0x00, 0xd2, 0xa3, 0x9f, 0x63,
	0x1d, 0xa9, 0xa6, 0x21, 0x2f, 0xc1, 0x67, 0xa2, 0x48, 0xef, 0xf2, 0x6b, 0x51, 0x04, 0x5e, 0xf5,
	0x56, 0x59, 0x25, 0xab, 0xcc, 0x2f, 0xbf, 0xd4, 0x0f, 0x9c, 0x7e, 0x64, 0x87, 0xd0, 0xbb, 0x48,
	0xf3, 0x84, 0x2f, 0xcf, 0x10, 0x0f, 0x9f, 0x29, 0x4d, 0x28, 0xd5, 0x3e, 0xe6, 0xf1, 0x42, 0xce,
	0x8a, 0xa1, 0x43, 0x0e, 0xa0, 0x1b, 0xca, 0x4b, 0xc1, 0x8b, 0x54, 0xbe, 0x7e, 0x9b, 0x0d, 0xdd,
	0xd3, 0xe1, 0x6f, 0xf7, 0x23, 0xe7, 0xf7, 0xfb, 0x91, 0xf3, 0xe7, 0xfd, 0xc8, 0xf9, 0xf5, 0xef,
	0xd1, 0xb3, 0xab, 0x7d, 0xfc, 0x53, 0xf3, 0xd9, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0xe4, 0xc9,
	0x37, 0x72, 0xf4, 0x08, 0x00, 0x00,
}
