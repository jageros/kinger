// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pvp.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type MatchArg_MatchType int32

const (
	MatchArg_Ladder   MatchArg_MatchType = 0
	MatchArg_Training MatchArg_MatchType = 1
)

var MatchArg_MatchType_name = map[int32]string{
	0: "Ladder",
	1: "Training",
}
var MatchArg_MatchType_value = map[string]int32{
	"Ladder":   0,
	"Training": 1,
}

func (x MatchArg_MatchType) String() string {
	return proto.EnumName(MatchArg_MatchType_name, int32(x))
}
func (MatchArg_MatchType) EnumDescriptor() ([]byte, []int) { return fileDescriptorPvp, []int{1, 0} }

type FetchSeasonHandCardReply_ChangeTypeEnum int32

const (
	FetchSeasonHandCardReply_Unknow FetchSeasonHandCardReply_ChangeTypeEnum = 0
	FetchSeasonHandCardReply_Fight  FetchSeasonHandCardReply_ChangeTypeEnum = 1
	FetchSeasonHandCardReply_Win    FetchSeasonHandCardReply_ChangeTypeEnum = 2
	FetchSeasonHandCardReply_Lose   FetchSeasonHandCardReply_ChangeTypeEnum = 3
)

var FetchSeasonHandCardReply_ChangeTypeEnum_name = map[int32]string{
	0: "Unknow",
	1: "Fight",
	2: "Win",
	3: "Lose",
}
var FetchSeasonHandCardReply_ChangeTypeEnum_value = map[string]int32{
	"Unknow": 0,
	"Fight":  1,
	"Win":    2,
	"Lose":   3,
}

func (x FetchSeasonHandCardReply_ChangeTypeEnum) String() string {
	return proto.EnumName(FetchSeasonHandCardReply_ChangeTypeEnum_name, int32(x))
}
func (FetchSeasonHandCardReply_ChangeTypeEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorPvp, []int{13, 0}
}

type MatchPlayer struct {
	Uid  uint64 `protobuf:"varint,1,opt,name=Uid,proto3" json:"Uid,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	Camp int32  `protobuf:"varint,3,opt,name=Camp,proto3" json:"Camp,omitempty"`
}

func (m *MatchPlayer) Reset()                    { *m = MatchPlayer{} }
func (m *MatchPlayer) String() string            { return proto.CompactTextString(m) }
func (*MatchPlayer) ProtoMessage()               {}
func (*MatchPlayer) Descriptor() ([]byte, []int) { return fileDescriptorPvp, []int{0} }

func (m *MatchPlayer) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *MatchPlayer) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MatchPlayer) GetCamp() int32 {
	if m != nil {
		return m.Camp
	}
	return 0
}

type MatchArg struct {
	Camp int32              `protobuf:"varint,1,opt,name=Camp,proto3" json:"Camp,omitempty"`
	Type MatchArg_MatchType `protobuf:"varint,2,opt,name=Type,proto3,enum=pb.MatchArg_MatchType" json:"Type,omitempty"`
}

func (m *MatchArg) Reset()                    { *m = MatchArg{} }
func (m *MatchArg) String() string            { return proto.CompactTextString(m) }
func (*MatchArg) ProtoMessage()               {}
func (*MatchArg) Descriptor() ([]byte, []int) { return fileDescriptorPvp, []int{1} }

func (m *MatchArg) GetCamp() int32 {
	if m != nil {
		return m.Camp
	}
	return 0
}

func (m *MatchArg) GetType() MatchArg_MatchType {
	if m != nil {
		return m.Type
	}
	return MatchArg_Ladder
}

type MatchReply struct {
	NeedChooseCamp bool                     `protobuf:"varint,1,opt,name=NeedChooseCamp,proto3" json:"NeedChooseCamp,omitempty"`
	LastCamp       int32                    `protobuf:"varint,2,opt,name=LastCamp,proto3" json:"LastCamp,omitempty"`
	ChooseCardData *SeasonPvpChooseCardData `protobuf:"bytes,3,opt,name=ChooseCardData" json:"ChooseCardData,omitempty"`
}

func (m *MatchReply) Reset()                    { *m = MatchReply{} }
func (m *MatchReply) String() string            { return proto.CompactTextString(m) }
func (*MatchReply) ProtoMessage()               {}
func (*MatchReply) Descriptor() ([]byte, []int) { return fileDescriptorPvp, []int{2} }

func (m *MatchReply) GetNeedChooseCamp() bool {
	if m != nil {
		return m.NeedChooseCamp
	}
	return false
}

func (m *MatchReply) GetLastCamp() int32 {
	if m != nil {
		return m.LastCamp
	}
	return 0
}

func (m *MatchReply) GetChooseCardData() *SeasonPvpChooseCardData {
	if m != nil {
		return m.ChooseCardData
	}
	return nil
}

type MatchInfo struct {
	RoomId  int32        `protobuf:"varint,1,opt,name=RoomId,proto3" json:"RoomId,omitempty"`
	Player1 *MatchPlayer `protobuf:"bytes,2,opt,name=Player1" json:"Player1,omitempty"`
	Player2 *MatchPlayer `protobuf:"bytes,3,opt,name=Player2" json:"Player2,omitempty"`
}

func (m *MatchInfo) Reset()                    { *m = MatchInfo{} }
func (m *MatchInfo) String() string            { return proto.CompactTextString(m) }
func (*MatchInfo) ProtoMessage()               {}
func (*MatchInfo) Descriptor() ([]byte, []int) { return fileDescriptorPvp, []int{3} }

func (m *MatchInfo) GetRoomId() int32 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

func (m *MatchInfo) GetPlayer1() *MatchPlayer {
	if m != nil {
		return m.Player1
	}
	return nil
}

func (m *MatchInfo) GetPlayer2() *MatchPlayer {
	if m != nil {
		return m.Player2
	}
	return nil
}

type MatchDoneArg struct {
	RoomId int32 `protobuf:"varint,1,opt,name=RoomId,proto3" json:"RoomId,omitempty"`
}

func (m *MatchDoneArg) Reset()                    { *m = MatchDoneArg{} }
func (m *MatchDoneArg) String() string            { return proto.CompactTextString(m) }
func (*MatchDoneArg) ProtoMessage()               {}
func (*MatchDoneArg) Descriptor() ([]byte, []int) { return fileDescriptorPvp, []int{4} }

func (m *MatchDoneArg) GetRoomId() int32 {
	if m != nil {
		return m.RoomId
	}
	return 0
}

type BeginMatchArg struct {
	Name               string       `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Camp               int32        `protobuf:"varint,2,opt,name=Camp,proto3" json:"Camp,omitempty"`
	PvpScore           int32        `protobuf:"varint,3,opt,name=PvpScore,proto3" json:"PvpScore,omitempty"`
	Mmr                int32        `protobuf:"varint,4,opt,name=Mmr,proto3" json:"Mmr,omitempty"`
	StreakLoseCnt      int32        `protobuf:"varint,5,opt,name=StreakLoseCnt,proto3" json:"StreakLoseCnt,omitempty"`
	HandCards          []*SkinGCard `protobuf:"bytes,6,rep,name=HandCards" json:"HandCards,omitempty"`
	DrawCards          []*SkinGCard `protobuf:"bytes,7,rep,name=DrawCards" json:"DrawCards,omitempty"`
	CardStrength       int32        `protobuf:"varint,8,opt,name=CardStrength,proto3" json:"CardStrength,omitempty"`
	HeadImgUrl         string       `protobuf:"bytes,9,opt,name=HeadImgUrl,proto3" json:"HeadImgUrl,omitempty"`
	HeadFrame          string       `protobuf:"bytes,10,opt,name=HeadFrame,proto3" json:"HeadFrame,omitempty"`
	SeasonDataID       int32        `protobuf:"varint,11,opt,name=SeasonDataID,proto3" json:"SeasonDataID,omitempty"`
	RebornCnt          int32        `protobuf:"varint,12,opt,name=RebornCnt,proto3" json:"RebornCnt,omitempty"`
	WinRate            int32        `protobuf:"varint,13,opt,name=WinRate,proto3" json:"WinRate,omitempty"`
	Area               int32        `protobuf:"varint,14,opt,name=Area,proto3" json:"Area,omitempty"`
	StreakWinCnt       int32        `protobuf:"varint,15,opt,name=StreakWinCnt,proto3" json:"StreakWinCnt,omitempty"`
	LastOppUid         uint64       `protobuf:"varint,16,opt,name=LastOppUid,proto3" json:"LastOppUid,omitempty"`
	RechargeMatchIndex int32        `protobuf:"varint,17,opt,name=RechargeMatchIndex,proto3" json:"RechargeMatchIndex,omitempty"`
	CountryFlag        string       `protobuf:"bytes,18,opt,name=CountryFlag,proto3" json:"CountryFlag,omitempty"`
	MatchScore         int32        `protobuf:"varint,19,opt,name=MatchScore,proto3" json:"MatchScore,omitempty"`
}

func (m *BeginMatchArg) Reset()                    { *m = BeginMatchArg{} }
func (m *BeginMatchArg) String() string            { return proto.CompactTextString(m) }
func (*BeginMatchArg) ProtoMessage()               {}
func (*BeginMatchArg) Descriptor() ([]byte, []int) { return fileDescriptorPvp, []int{5} }

func (m *BeginMatchArg) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BeginMatchArg) GetCamp() int32 {
	if m != nil {
		return m.Camp
	}
	return 0
}

func (m *BeginMatchArg) GetPvpScore() int32 {
	if m != nil {
		return m.PvpScore
	}
	return 0
}

func (m *BeginMatchArg) GetMmr() int32 {
	if m != nil {
		return m.Mmr
	}
	return 0
}

func (m *BeginMatchArg) GetStreakLoseCnt() int32 {
	if m != nil {
		return m.StreakLoseCnt
	}
	return 0
}

func (m *BeginMatchArg) GetHandCards() []*SkinGCard {
	if m != nil {
		return m.HandCards
	}
	return nil
}

func (m *BeginMatchArg) GetDrawCards() []*SkinGCard {
	if m != nil {
		return m.DrawCards
	}
	return nil
}

func (m *BeginMatchArg) GetCardStrength() int32 {
	if m != nil {
		return m.CardStrength
	}
	return 0
}

func (m *BeginMatchArg) GetHeadImgUrl() string {
	if m != nil {
		return m.HeadImgUrl
	}
	return ""
}

func (m *BeginMatchArg) GetHeadFrame() string {
	if m != nil {
		return m.HeadFrame
	}
	return ""
}

func (m *BeginMatchArg) GetSeasonDataID() int32 {
	if m != nil {
		return m.SeasonDataID
	}
	return 0
}

func (m *BeginMatchArg) GetRebornCnt() int32 {
	if m != nil {
		return m.RebornCnt
	}
	return 0
}

func (m *BeginMatchArg) GetWinRate() int32 {
	if m != nil {
		return m.WinRate
	}
	return 0
}

func (m *BeginMatchArg) GetArea() int32 {
	if m != nil {
		return m.Area
	}
	return 0
}

func (m *BeginMatchArg) GetStreakWinCnt() int32 {
	if m != nil {
		return m.StreakWinCnt
	}
	return 0
}

func (m *BeginMatchArg) GetLastOppUid() uint64 {
	if m != nil {
		return m.LastOppUid
	}
	return 0
}

func (m *BeginMatchArg) GetRechargeMatchIndex() int32 {
	if m != nil {
		return m.RechargeMatchIndex
	}
	return 0
}

func (m *BeginMatchArg) GetCountryFlag() string {
	if m != nil {
		return m.CountryFlag
	}
	return ""
}

func (m *BeginMatchArg) GetMatchScore() int32 {
	if m != nil {
		return m.MatchScore
	}
	return 0
}

type BeginNewbiePvpMatchArg struct {
	Name          string       `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Camp          int32        `protobuf:"varint,2,opt,name=Camp,proto3" json:"Camp,omitempty"`
	PvpScore      int32        `protobuf:"varint,3,opt,name=PvpScore,proto3" json:"PvpScore,omitempty"`
	Mmr           int32        `protobuf:"varint,4,opt,name=Mmr,proto3" json:"Mmr,omitempty"`
	EnemyCamp     int32        `protobuf:"varint,5,opt,name=EnemyCamp,proto3" json:"EnemyCamp,omitempty"`
	HandCards     []*SkinGCard `protobuf:"bytes,6,rep,name=HandCards" json:"HandCards,omitempty"`
	DrawCards     []*SkinGCard `protobuf:"bytes,7,rep,name=DrawCards" json:"DrawCards,omitempty"`
	IsFirstBattle bool         `protobuf:"varint,8,opt,name=IsFirstBattle,proto3" json:"IsFirstBattle,omitempty"`
	HeadImgUrl    string       `protobuf:"bytes,9,opt,name=HeadImgUrl,proto3" json:"HeadImgUrl,omitempty"`
	HeadFrame     string       `protobuf:"bytes,10,opt,name=HeadFrame,proto3" json:"HeadFrame,omitempty"`
	WinRate       int32        `protobuf:"varint,11,opt,name=WinRate,proto3" json:"WinRate,omitempty"`
	Area          int32        `protobuf:"varint,12,opt,name=Area,proto3" json:"Area,omitempty"`
	CountryFlag   string       `protobuf:"bytes,13,opt,name=CountryFlag,proto3" json:"CountryFlag,omitempty"`
}

func (m *BeginNewbiePvpMatchArg) Reset()                    { *m = BeginNewbiePvpMatchArg{} }
func (m *BeginNewbiePvpMatchArg) String() string            { return proto.CompactTextString(m) }
func (*BeginNewbiePvpMatchArg) ProtoMessage()               {}
func (*BeginNewbiePvpMatchArg) Descriptor() ([]byte, []int) { return fileDescriptorPvp, []int{6} }

func (m *BeginNewbiePvpMatchArg) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BeginNewbiePvpMatchArg) GetCamp() int32 {
	if m != nil {
		return m.Camp
	}
	return 0
}

func (m *BeginNewbiePvpMatchArg) GetPvpScore() int32 {
	if m != nil {
		return m.PvpScore
	}
	return 0
}

func (m *BeginNewbiePvpMatchArg) GetMmr() int32 {
	if m != nil {
		return m.Mmr
	}
	return 0
}

func (m *BeginNewbiePvpMatchArg) GetEnemyCamp() int32 {
	if m != nil {
		return m.EnemyCamp
	}
	return 0
}

func (m *BeginNewbiePvpMatchArg) GetHandCards() []*SkinGCard {
	if m != nil {
		return m.HandCards
	}
	return nil
}

func (m *BeginNewbiePvpMatchArg) GetDrawCards() []*SkinGCard {
	if m != nil {
		return m.DrawCards
	}
	return nil
}

func (m *BeginNewbiePvpMatchArg) GetIsFirstBattle() bool {
	if m != nil {
		return m.IsFirstBattle
	}
	return false
}

func (m *BeginNewbiePvpMatchArg) GetHeadImgUrl() string {
	if m != nil {
		return m.HeadImgUrl
	}
	return ""
}

func (m *BeginNewbiePvpMatchArg) GetHeadFrame() string {
	if m != nil {
		return m.HeadFrame
	}
	return ""
}

func (m *BeginNewbiePvpMatchArg) GetWinRate() int32 {
	if m != nil {
		return m.WinRate
	}
	return 0
}

func (m *BeginNewbiePvpMatchArg) GetArea() int32 {
	if m != nil {
		return m.Area
	}
	return 0
}

func (m *BeginNewbiePvpMatchArg) GetCountryFlag() string {
	if m != nil {
		return m.CountryFlag
	}
	return ""
}

type SeasonPvpLimitTime struct {
	LimitTime int32 `protobuf:"varint,1,opt,name=LimitTime,proto3" json:"LimitTime,omitempty"`
}

func (m *SeasonPvpLimitTime) Reset()                    { *m = SeasonPvpLimitTime{} }
func (m *SeasonPvpLimitTime) String() string            { return proto.CompactTextString(m) }
func (*SeasonPvpLimitTime) ProtoMessage()               {}
func (*SeasonPvpLimitTime) Descriptor() ([]byte, []int) { return fileDescriptorPvp, []int{7} }

func (m *SeasonPvpLimitTime) GetLimitTime() int32 {
	if m != nil {
		return m.LimitTime
	}
	return 0
}

type SeasonPvpInfo struct {
	LimitTime          int32 `protobuf:"varint,1,opt,name=LimitTime,proto3" json:"LimitTime,omitempty"`
	FirstHandAmount    int32 `protobuf:"varint,2,opt,name=FirstHandAmount,proto3" json:"FirstHandAmount,omitempty"`
	BackHandAmount     int32 `protobuf:"varint,3,opt,name=BackHandAmount,proto3" json:"BackHandAmount,omitempty"`
	FirstHandWinAmount int32 `protobuf:"varint,4,opt,name=FirstHandWinAmount,proto3" json:"FirstHandWinAmount,omitempty"`
	BackHandWinAmount  int32 `protobuf:"varint,5,opt,name=BackHandWinAmount,proto3" json:"BackHandWinAmount,omitempty"`
}

func (m *SeasonPvpInfo) Reset()                    { *m = SeasonPvpInfo{} }
func (m *SeasonPvpInfo) String() string            { return proto.CompactTextString(m) }
func (*SeasonPvpInfo) ProtoMessage()               {}
func (*SeasonPvpInfo) Descriptor() ([]byte, []int) { return fileDescriptorPvp, []int{8} }

func (m *SeasonPvpInfo) GetLimitTime() int32 {
	if m != nil {
		return m.LimitTime
	}
	return 0
}

func (m *SeasonPvpInfo) GetFirstHandAmount() int32 {
	if m != nil {
		return m.FirstHandAmount
	}
	return 0
}

func (m *SeasonPvpInfo) GetBackHandAmount() int32 {
	if m != nil {
		return m.BackHandAmount
	}
	return 0
}

func (m *SeasonPvpInfo) GetFirstHandWinAmount() int32 {
	if m != nil {
		return m.FirstHandWinAmount
	}
	return 0
}

func (m *SeasonPvpInfo) GetBackHandWinAmount() int32 {
	if m != nil {
		return m.BackHandWinAmount
	}
	return 0
}

type SeasonPvpChooseCampArg struct {
	Camp int32 `protobuf:"varint,1,opt,name=Camp,proto3" json:"Camp,omitempty"`
}

func (m *SeasonPvpChooseCampArg) Reset()                    { *m = SeasonPvpChooseCampArg{} }
func (m *SeasonPvpChooseCampArg) String() string            { return proto.CompactTextString(m) }
func (*SeasonPvpChooseCampArg) ProtoMessage()               {}
func (*SeasonPvpChooseCampArg) Descriptor() ([]byte, []int) { return fileDescriptorPvp, []int{9} }

func (m *SeasonPvpChooseCampArg) GetCamp() int32 {
	if m != nil {
		return m.Camp
	}
	return 0
}

type SeasonPvpChooseCardData struct {
	CardIDs          []uint32 `protobuf:"varint,1,rep,packed,name=CardIDs" json:"CardIDs,omitempty"`
	NeedChooseAmount int32    `protobuf:"varint,2,opt,name=NeedChooseAmount,proto3" json:"NeedChooseAmount,omitempty"`
	FreeRefreshCnt   int32    `protobuf:"varint,3,opt,name=FreeRefreshCnt,proto3" json:"FreeRefreshCnt,omitempty"`
	JadeRefreshCnt   int32    `protobuf:"varint,4,opt,name=JadeRefreshCnt,proto3" json:"JadeRefreshCnt,omitempty"`
}

func (m *SeasonPvpChooseCardData) Reset()                    { *m = SeasonPvpChooseCardData{} }
func (m *SeasonPvpChooseCardData) String() string            { return proto.CompactTextString(m) }
func (*SeasonPvpChooseCardData) ProtoMessage()               {}
func (*SeasonPvpChooseCardData) Descriptor() ([]byte, []int) { return fileDescriptorPvp, []int{10} }

func (m *SeasonPvpChooseCardData) GetCardIDs() []uint32 {
	if m != nil {
		return m.CardIDs
	}
	return nil
}

func (m *SeasonPvpChooseCardData) GetNeedChooseAmount() int32 {
	if m != nil {
		return m.NeedChooseAmount
	}
	return 0
}

func (m *SeasonPvpChooseCardData) GetFreeRefreshCnt() int32 {
	if m != nil {
		return m.FreeRefreshCnt
	}
	return 0
}

func (m *SeasonPvpChooseCardData) GetJadeRefreshCnt() int32 {
	if m != nil {
		return m.JadeRefreshCnt
	}
	return 0
}

type SeasonPvpChooseCardArg struct {
	CardIDs []uint32 `protobuf:"varint,1,rep,packed,name=CardIDs" json:"CardIDs,omitempty"`
}

func (m *SeasonPvpChooseCardArg) Reset()                    { *m = SeasonPvpChooseCardArg{} }
func (m *SeasonPvpChooseCardArg) String() string            { return proto.CompactTextString(m) }
func (*SeasonPvpChooseCardArg) ProtoMessage()               {}
func (*SeasonPvpChooseCardArg) Descriptor() ([]byte, []int) { return fileDescriptorPvp, []int{11} }

func (m *SeasonPvpChooseCardArg) GetCardIDs() []uint32 {
	if m != nil {
		return m.CardIDs
	}
	return nil
}

type SeasonPvpChooseCardReply struct {
	CardIDs []uint32 `protobuf:"varint,1,rep,packed,name=CardIDs" json:"CardIDs,omitempty"`
}

func (m *SeasonPvpChooseCardReply) Reset()                    { *m = SeasonPvpChooseCardReply{} }
func (m *SeasonPvpChooseCardReply) String() string            { return proto.CompactTextString(m) }
func (*SeasonPvpChooseCardReply) ProtoMessage()               {}
func (*SeasonPvpChooseCardReply) Descriptor() ([]byte, []int) { return fileDescriptorPvp, []int{12} }

func (m *SeasonPvpChooseCardReply) GetCardIDs() []uint32 {
	if m != nil {
		return m.CardIDs
	}
	return nil
}

type FetchSeasonHandCardReply struct {
	CardIDs      []uint32                                `protobuf:"varint,1,rep,packed,name=CardIDs" json:"CardIDs,omitempty"`
	ChangeType   FetchSeasonHandCardReply_ChangeTypeEnum `protobuf:"varint,2,opt,name=ChangeType,proto3,enum=pb.FetchSeasonHandCardReply_ChangeTypeEnum" json:"ChangeType,omitempty"`
	ChangeMaxPro int32                                   `protobuf:"varint,3,opt,name=ChangeMaxPro,proto3" json:"ChangeMaxPro,omitempty"`
	ChangeCurPro int32                                   `protobuf:"varint,4,opt,name=ChangeCurPro,proto3" json:"ChangeCurPro,omitempty"`
	WinCnt       int32                                   `protobuf:"varint,5,opt,name=WinCnt,proto3" json:"WinCnt,omitempty"`
}

func (m *FetchSeasonHandCardReply) Reset()                    { *m = FetchSeasonHandCardReply{} }
func (m *FetchSeasonHandCardReply) String() string            { return proto.CompactTextString(m) }
func (*FetchSeasonHandCardReply) ProtoMessage()               {}
func (*FetchSeasonHandCardReply) Descriptor() ([]byte, []int) { return fileDescriptorPvp, []int{13} }

func (m *FetchSeasonHandCardReply) GetCardIDs() []uint32 {
	if m != nil {
		return m.CardIDs
	}
	return nil
}

func (m *FetchSeasonHandCardReply) GetChangeType() FetchSeasonHandCardReply_ChangeTypeEnum {
	if m != nil {
		return m.ChangeType
	}
	return FetchSeasonHandCardReply_Unknow
}

func (m *FetchSeasonHandCardReply) GetChangeMaxPro() int32 {
	if m != nil {
		return m.ChangeMaxPro
	}
	return 0
}

func (m *FetchSeasonHandCardReply) GetChangeCurPro() int32 {
	if m != nil {
		return m.ChangeCurPro
	}
	return 0
}

func (m *FetchSeasonHandCardReply) GetWinCnt() int32 {
	if m != nil {
		return m.WinCnt
	}
	return 0
}

type GetFighterDataArg struct {
	CardIDs []uint32 `protobuf:"varint,1,rep,packed,name=CardIDs" json:"CardIDs,omitempty"`
}

func (m *GetFighterDataArg) Reset()                    { *m = GetFighterDataArg{} }
func (m *GetFighterDataArg) String() string            { return proto.CompactTextString(m) }
func (*GetFighterDataArg) ProtoMessage()               {}
func (*GetFighterDataArg) Descriptor() ([]byte, []int) { return fileDescriptorPvp, []int{14} }

func (m *GetFighterDataArg) GetCardIDs() []uint32 {
	if m != nil {
		return m.CardIDs
	}
	return nil
}

type LeagueRewardInfo struct {
	RemainTime int64          `protobuf:"varint,1,opt,name=RemainTime,proto3" json:"RemainTime,omitempty"`
	HasReceive map[int32]bool `protobuf:"bytes,2,rep,name=HasReceive" json:"HasReceive,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *LeagueRewardInfo) Reset()                    { *m = LeagueRewardInfo{} }
func (m *LeagueRewardInfo) String() string            { return proto.CompactTextString(m) }
func (*LeagueRewardInfo) ProtoMessage()               {}
func (*LeagueRewardInfo) Descriptor() ([]byte, []int) { return fileDescriptorPvp, []int{15} }

func (m *LeagueRewardInfo) GetRemainTime() int64 {
	if m != nil {
		return m.RemainTime
	}
	return 0
}

func (m *LeagueRewardInfo) GetHasReceive() map[int32]bool {
	if m != nil {
		return m.HasReceive
	}
	return nil
}

type LeagueRewardId struct {
	RewardId int32 `protobuf:"varint,1,opt,name=rewardId,proto3" json:"rewardId,omitempty"`
}

func (m *LeagueRewardId) Reset()                    { *m = LeagueRewardId{} }
func (m *LeagueRewardId) String() string            { return proto.CompactTextString(m) }
func (*LeagueRewardId) ProtoMessage()               {}
func (*LeagueRewardId) Descriptor() ([]byte, []int) { return fileDescriptorPvp, []int{16} }

func (m *LeagueRewardId) GetRewardId() int32 {
	if m != nil {
		return m.RewardId
	}
	return 0
}

type LeagueRewards struct {
	LeagueReward *RewardList `protobuf:"bytes,1,opt,name=LeagueReward" json:"LeagueReward,omitempty"`
}

func (m *LeagueRewards) Reset()                    { *m = LeagueRewards{} }
func (m *LeagueRewards) String() string            { return proto.CompactTextString(m) }
func (*LeagueRewards) ProtoMessage()               {}
func (*LeagueRewards) Descriptor() ([]byte, []int) { return fileDescriptorPvp, []int{17} }

func (m *LeagueRewards) GetLeagueReward() *RewardList {
	if m != nil {
		return m.LeagueReward
	}
	return nil
}

type ReloadLeagueAttrArg struct {
	Area          int32  `protobuf:"varint,1,opt,name=Area,proto3" json:"Area,omitempty"`
	AppID         uint32 `protobuf:"varint,2,opt,name=AppID,proto3" json:"AppID,omitempty"`
	IsCrossSeason bool   `protobuf:"varint,3,opt,name=IsCrossSeason,proto3" json:"IsCrossSeason,omitempty"`
}

func (m *ReloadLeagueAttrArg) Reset()                    { *m = ReloadLeagueAttrArg{} }
func (m *ReloadLeagueAttrArg) String() string            { return proto.CompactTextString(m) }
func (*ReloadLeagueAttrArg) ProtoMessage()               {}
func (*ReloadLeagueAttrArg) Descriptor() ([]byte, []int) { return fileDescriptorPvp, []int{18} }

func (m *ReloadLeagueAttrArg) GetArea() int32 {
	if m != nil {
		return m.Area
	}
	return 0
}

func (m *ReloadLeagueAttrArg) GetAppID() uint32 {
	if m != nil {
		return m.AppID
	}
	return 0
}

func (m *ReloadLeagueAttrArg) GetIsCrossSeason() bool {
	if m != nil {
		return m.IsCrossSeason
	}
	return false
}

type GLeagueSeasonEndArg struct {
	Area int32 `protobuf:"varint,1,opt,name=Area,proto3" json:"Area,omitempty"`
}

func (m *GLeagueSeasonEndArg) Reset()                    { *m = GLeagueSeasonEndArg{} }
func (m *GLeagueSeasonEndArg) String() string            { return proto.CompactTextString(m) }
func (*GLeagueSeasonEndArg) ProtoMessage()               {}
func (*GLeagueSeasonEndArg) Descriptor() ([]byte, []int) { return fileDescriptorPvp, []int{19} }

func (m *GLeagueSeasonEndArg) GetArea() int32 {
	if m != nil {
		return m.Area
	}
	return 0
}

func init() {
	proto.RegisterType((*MatchPlayer)(nil), "pb.MatchPlayer")
	proto.RegisterType((*MatchArg)(nil), "pb.MatchArg")
	proto.RegisterType((*MatchReply)(nil), "pb.MatchReply")
	proto.RegisterType((*MatchInfo)(nil), "pb.MatchInfo")
	proto.RegisterType((*MatchDoneArg)(nil), "pb.MatchDoneArg")
	proto.RegisterType((*BeginMatchArg)(nil), "pb.BeginMatchArg")
	proto.RegisterType((*BeginNewbiePvpMatchArg)(nil), "pb.BeginNewbiePvpMatchArg")
	proto.RegisterType((*SeasonPvpLimitTime)(nil), "pb.SeasonPvpLimitTime")
	proto.RegisterType((*SeasonPvpInfo)(nil), "pb.SeasonPvpInfo")
	proto.RegisterType((*SeasonPvpChooseCampArg)(nil), "pb.SeasonPvpChooseCampArg")
	proto.RegisterType((*SeasonPvpChooseCardData)(nil), "pb.SeasonPvpChooseCardData")
	proto.RegisterType((*SeasonPvpChooseCardArg)(nil), "pb.SeasonPvpChooseCardArg")
	proto.RegisterType((*SeasonPvpChooseCardReply)(nil), "pb.SeasonPvpChooseCardReply")
	proto.RegisterType((*FetchSeasonHandCardReply)(nil), "pb.FetchSeasonHandCardReply")
	proto.RegisterType((*GetFighterDataArg)(nil), "pb.GetFighterDataArg")
	proto.RegisterType((*LeagueRewardInfo)(nil), "pb.LeagueRewardInfo")
	proto.RegisterType((*LeagueRewardId)(nil), "pb.LeagueRewardId")
	proto.RegisterType((*LeagueRewards)(nil), "pb.LeagueRewards")
	proto.RegisterType((*ReloadLeagueAttrArg)(nil), "pb.ReloadLeagueAttrArg")
	proto.RegisterType((*GLeagueSeasonEndArg)(nil), "pb.GLeagueSeasonEndArg")
	proto.RegisterEnum("pb.MatchArg_MatchType", MatchArg_MatchType_name, MatchArg_MatchType_value)
	proto.RegisterEnum("pb.FetchSeasonHandCardReply_ChangeTypeEnum", FetchSeasonHandCardReply_ChangeTypeEnum_name, FetchSeasonHandCardReply_ChangeTypeEnum_value)
}
func (m *MatchPlayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchPlayer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.Uid))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPvp(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Camp != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.Camp))
	}
	return i, nil
}

func (m *MatchArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Camp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.Camp))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.Type))
	}
	return i, nil
}

func (m *MatchReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NeedChooseCamp {
		dAtA[i] = 0x8
		i++
		if m.NeedChooseCamp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.LastCamp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.LastCamp))
	}
	if m.ChooseCardData != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.ChooseCardData.Size()))
		n1, err := m.ChooseCardData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *MatchInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RoomId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.RoomId))
	}
	if m.Player1 != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.Player1.Size()))
		n2, err := m.Player1.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Player2 != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.Player2.Size()))
		n3, err := m.Player2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *MatchDoneArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MatchDoneArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RoomId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.RoomId))
	}
	return i, nil
}

func (m *BeginMatchArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BeginMatchArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPvp(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Camp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.Camp))
	}
	if m.PvpScore != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.PvpScore))
	}
	if m.Mmr != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.Mmr))
	}
	if m.StreakLoseCnt != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.StreakLoseCnt))
	}
	if len(m.HandCards) > 0 {
		for _, msg := range m.HandCards {
			dAtA[i] = 0x32
			i++
			i = encodeVarintPvp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DrawCards) > 0 {
		for _, msg := range m.DrawCards {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintPvp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CardStrength != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.CardStrength))
	}
	if len(m.HeadImgUrl) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPvp(dAtA, i, uint64(len(m.HeadImgUrl)))
		i += copy(dAtA[i:], m.HeadImgUrl)
	}
	if len(m.HeadFrame) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintPvp(dAtA, i, uint64(len(m.HeadFrame)))
		i += copy(dAtA[i:], m.HeadFrame)
	}
	if m.SeasonDataID != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.SeasonDataID))
	}
	if m.RebornCnt != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.RebornCnt))
	}
	if m.WinRate != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.WinRate))
	}
	if m.Area != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.Area))
	}
	if m.StreakWinCnt != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.StreakWinCnt))
	}
	if m.LastOppUid != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.LastOppUid))
	}
	if m.RechargeMatchIndex != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.RechargeMatchIndex))
	}
	if len(m.CountryFlag) > 0 {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPvp(dAtA, i, uint64(len(m.CountryFlag)))
		i += copy(dAtA[i:], m.CountryFlag)
	}
	if m.MatchScore != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.MatchScore))
	}
	return i, nil
}

func (m *BeginNewbiePvpMatchArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BeginNewbiePvpMatchArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPvp(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Camp != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.Camp))
	}
	if m.PvpScore != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.PvpScore))
	}
	if m.Mmr != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.Mmr))
	}
	if m.EnemyCamp != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.EnemyCamp))
	}
	if len(m.HandCards) > 0 {
		for _, msg := range m.HandCards {
			dAtA[i] = 0x32
			i++
			i = encodeVarintPvp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DrawCards) > 0 {
		for _, msg := range m.DrawCards {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintPvp(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.IsFirstBattle {
		dAtA[i] = 0x40
		i++
		if m.IsFirstBattle {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.HeadImgUrl) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintPvp(dAtA, i, uint64(len(m.HeadImgUrl)))
		i += copy(dAtA[i:], m.HeadImgUrl)
	}
	if len(m.HeadFrame) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintPvp(dAtA, i, uint64(len(m.HeadFrame)))
		i += copy(dAtA[i:], m.HeadFrame)
	}
	if m.WinRate != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.WinRate))
	}
	if m.Area != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.Area))
	}
	if len(m.CountryFlag) > 0 {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintPvp(dAtA, i, uint64(len(m.CountryFlag)))
		i += copy(dAtA[i:], m.CountryFlag)
	}
	return i, nil
}

func (m *SeasonPvpLimitTime) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeasonPvpLimitTime) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LimitTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.LimitTime))
	}
	return i, nil
}

func (m *SeasonPvpInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeasonPvpInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LimitTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.LimitTime))
	}
	if m.FirstHandAmount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.FirstHandAmount))
	}
	if m.BackHandAmount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.BackHandAmount))
	}
	if m.FirstHandWinAmount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.FirstHandWinAmount))
	}
	if m.BackHandWinAmount != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.BackHandWinAmount))
	}
	return i, nil
}

func (m *SeasonPvpChooseCampArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeasonPvpChooseCampArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Camp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.Camp))
	}
	return i, nil
}

func (m *SeasonPvpChooseCardData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeasonPvpChooseCardData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CardIDs) > 0 {
		dAtA5 := make([]byte, len(m.CardIDs)*10)
		var j4 int
		for _, num := range m.CardIDs {
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintPvp(dAtA, i, uint64(j4))
		i += copy(dAtA[i:], dAtA5[:j4])
	}
	if m.NeedChooseAmount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.NeedChooseAmount))
	}
	if m.FreeRefreshCnt != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.FreeRefreshCnt))
	}
	if m.JadeRefreshCnt != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.JadeRefreshCnt))
	}
	return i, nil
}

func (m *SeasonPvpChooseCardArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeasonPvpChooseCardArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CardIDs) > 0 {
		dAtA7 := make([]byte, len(m.CardIDs)*10)
		var j6 int
		for _, num := range m.CardIDs {
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintPvp(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	return i, nil
}

func (m *SeasonPvpChooseCardReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeasonPvpChooseCardReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CardIDs) > 0 {
		dAtA9 := make([]byte, len(m.CardIDs)*10)
		var j8 int
		for _, num := range m.CardIDs {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintPvp(dAtA, i, uint64(j8))
		i += copy(dAtA[i:], dAtA9[:j8])
	}
	return i, nil
}

func (m *FetchSeasonHandCardReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FetchSeasonHandCardReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CardIDs) > 0 {
		dAtA11 := make([]byte, len(m.CardIDs)*10)
		var j10 int
		for _, num := range m.CardIDs {
			for num >= 1<<7 {
				dAtA11[j10] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j10++
			}
			dAtA11[j10] = uint8(num)
			j10++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintPvp(dAtA, i, uint64(j10))
		i += copy(dAtA[i:], dAtA11[:j10])
	}
	if m.ChangeType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.ChangeType))
	}
	if m.ChangeMaxPro != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.ChangeMaxPro))
	}
	if m.ChangeCurPro != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.ChangeCurPro))
	}
	if m.WinCnt != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.WinCnt))
	}
	return i, nil
}

func (m *GetFighterDataArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetFighterDataArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CardIDs) > 0 {
		dAtA13 := make([]byte, len(m.CardIDs)*10)
		var j12 int
		for _, num := range m.CardIDs {
			for num >= 1<<7 {
				dAtA13[j12] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j12++
			}
			dAtA13[j12] = uint8(num)
			j12++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintPvp(dAtA, i, uint64(j12))
		i += copy(dAtA[i:], dAtA13[:j12])
	}
	return i, nil
}

func (m *LeagueRewardInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeagueRewardInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RemainTime != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.RemainTime))
	}
	if len(m.HasReceive) > 0 {
		for k, _ := range m.HasReceive {
			dAtA[i] = 0x12
			i++
			v := m.HasReceive[k]
			mapSize := 1 + sovPvp(uint64(k)) + 1 + 1
			i = encodeVarintPvp(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintPvp(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	return i, nil
}

func (m *LeagueRewardId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeagueRewardId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RewardId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.RewardId))
	}
	return i, nil
}

func (m *LeagueRewards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeagueRewards) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LeagueReward != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.LeagueReward.Size()))
		n14, err := m.LeagueReward.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *ReloadLeagueAttrArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReloadLeagueAttrArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Area != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.Area))
	}
	if m.AppID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.AppID))
	}
	if m.IsCrossSeason {
		dAtA[i] = 0x18
		i++
		if m.IsCrossSeason {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *GLeagueSeasonEndArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GLeagueSeasonEndArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Area != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPvp(dAtA, i, uint64(m.Area))
	}
	return i, nil
}

func encodeVarintPvp(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *MatchPlayer) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovPvp(uint64(m.Uid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPvp(uint64(l))
	}
	if m.Camp != 0 {
		n += 1 + sovPvp(uint64(m.Camp))
	}
	return n
}

func (m *MatchArg) Size() (n int) {
	var l int
	_ = l
	if m.Camp != 0 {
		n += 1 + sovPvp(uint64(m.Camp))
	}
	if m.Type != 0 {
		n += 1 + sovPvp(uint64(m.Type))
	}
	return n
}

func (m *MatchReply) Size() (n int) {
	var l int
	_ = l
	if m.NeedChooseCamp {
		n += 2
	}
	if m.LastCamp != 0 {
		n += 1 + sovPvp(uint64(m.LastCamp))
	}
	if m.ChooseCardData != nil {
		l = m.ChooseCardData.Size()
		n += 1 + l + sovPvp(uint64(l))
	}
	return n
}

func (m *MatchInfo) Size() (n int) {
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovPvp(uint64(m.RoomId))
	}
	if m.Player1 != nil {
		l = m.Player1.Size()
		n += 1 + l + sovPvp(uint64(l))
	}
	if m.Player2 != nil {
		l = m.Player2.Size()
		n += 1 + l + sovPvp(uint64(l))
	}
	return n
}

func (m *MatchDoneArg) Size() (n int) {
	var l int
	_ = l
	if m.RoomId != 0 {
		n += 1 + sovPvp(uint64(m.RoomId))
	}
	return n
}

func (m *BeginMatchArg) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPvp(uint64(l))
	}
	if m.Camp != 0 {
		n += 1 + sovPvp(uint64(m.Camp))
	}
	if m.PvpScore != 0 {
		n += 1 + sovPvp(uint64(m.PvpScore))
	}
	if m.Mmr != 0 {
		n += 1 + sovPvp(uint64(m.Mmr))
	}
	if m.StreakLoseCnt != 0 {
		n += 1 + sovPvp(uint64(m.StreakLoseCnt))
	}
	if len(m.HandCards) > 0 {
		for _, e := range m.HandCards {
			l = e.Size()
			n += 1 + l + sovPvp(uint64(l))
		}
	}
	if len(m.DrawCards) > 0 {
		for _, e := range m.DrawCards {
			l = e.Size()
			n += 1 + l + sovPvp(uint64(l))
		}
	}
	if m.CardStrength != 0 {
		n += 1 + sovPvp(uint64(m.CardStrength))
	}
	l = len(m.HeadImgUrl)
	if l > 0 {
		n += 1 + l + sovPvp(uint64(l))
	}
	l = len(m.HeadFrame)
	if l > 0 {
		n += 1 + l + sovPvp(uint64(l))
	}
	if m.SeasonDataID != 0 {
		n += 1 + sovPvp(uint64(m.SeasonDataID))
	}
	if m.RebornCnt != 0 {
		n += 1 + sovPvp(uint64(m.RebornCnt))
	}
	if m.WinRate != 0 {
		n += 1 + sovPvp(uint64(m.WinRate))
	}
	if m.Area != 0 {
		n += 1 + sovPvp(uint64(m.Area))
	}
	if m.StreakWinCnt != 0 {
		n += 1 + sovPvp(uint64(m.StreakWinCnt))
	}
	if m.LastOppUid != 0 {
		n += 2 + sovPvp(uint64(m.LastOppUid))
	}
	if m.RechargeMatchIndex != 0 {
		n += 2 + sovPvp(uint64(m.RechargeMatchIndex))
	}
	l = len(m.CountryFlag)
	if l > 0 {
		n += 2 + l + sovPvp(uint64(l))
	}
	if m.MatchScore != 0 {
		n += 2 + sovPvp(uint64(m.MatchScore))
	}
	return n
}

func (m *BeginNewbiePvpMatchArg) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPvp(uint64(l))
	}
	if m.Camp != 0 {
		n += 1 + sovPvp(uint64(m.Camp))
	}
	if m.PvpScore != 0 {
		n += 1 + sovPvp(uint64(m.PvpScore))
	}
	if m.Mmr != 0 {
		n += 1 + sovPvp(uint64(m.Mmr))
	}
	if m.EnemyCamp != 0 {
		n += 1 + sovPvp(uint64(m.EnemyCamp))
	}
	if len(m.HandCards) > 0 {
		for _, e := range m.HandCards {
			l = e.Size()
			n += 1 + l + sovPvp(uint64(l))
		}
	}
	if len(m.DrawCards) > 0 {
		for _, e := range m.DrawCards {
			l = e.Size()
			n += 1 + l + sovPvp(uint64(l))
		}
	}
	if m.IsFirstBattle {
		n += 2
	}
	l = len(m.HeadImgUrl)
	if l > 0 {
		n += 1 + l + sovPvp(uint64(l))
	}
	l = len(m.HeadFrame)
	if l > 0 {
		n += 1 + l + sovPvp(uint64(l))
	}
	if m.WinRate != 0 {
		n += 1 + sovPvp(uint64(m.WinRate))
	}
	if m.Area != 0 {
		n += 1 + sovPvp(uint64(m.Area))
	}
	l = len(m.CountryFlag)
	if l > 0 {
		n += 1 + l + sovPvp(uint64(l))
	}
	return n
}

func (m *SeasonPvpLimitTime) Size() (n int) {
	var l int
	_ = l
	if m.LimitTime != 0 {
		n += 1 + sovPvp(uint64(m.LimitTime))
	}
	return n
}

func (m *SeasonPvpInfo) Size() (n int) {
	var l int
	_ = l
	if m.LimitTime != 0 {
		n += 1 + sovPvp(uint64(m.LimitTime))
	}
	if m.FirstHandAmount != 0 {
		n += 1 + sovPvp(uint64(m.FirstHandAmount))
	}
	if m.BackHandAmount != 0 {
		n += 1 + sovPvp(uint64(m.BackHandAmount))
	}
	if m.FirstHandWinAmount != 0 {
		n += 1 + sovPvp(uint64(m.FirstHandWinAmount))
	}
	if m.BackHandWinAmount != 0 {
		n += 1 + sovPvp(uint64(m.BackHandWinAmount))
	}
	return n
}

func (m *SeasonPvpChooseCampArg) Size() (n int) {
	var l int
	_ = l
	if m.Camp != 0 {
		n += 1 + sovPvp(uint64(m.Camp))
	}
	return n
}

func (m *SeasonPvpChooseCardData) Size() (n int) {
	var l int
	_ = l
	if len(m.CardIDs) > 0 {
		l = 0
		for _, e := range m.CardIDs {
			l += sovPvp(uint64(e))
		}
		n += 1 + sovPvp(uint64(l)) + l
	}
	if m.NeedChooseAmount != 0 {
		n += 1 + sovPvp(uint64(m.NeedChooseAmount))
	}
	if m.FreeRefreshCnt != 0 {
		n += 1 + sovPvp(uint64(m.FreeRefreshCnt))
	}
	if m.JadeRefreshCnt != 0 {
		n += 1 + sovPvp(uint64(m.JadeRefreshCnt))
	}
	return n
}

func (m *SeasonPvpChooseCardArg) Size() (n int) {
	var l int
	_ = l
	if len(m.CardIDs) > 0 {
		l = 0
		for _, e := range m.CardIDs {
			l += sovPvp(uint64(e))
		}
		n += 1 + sovPvp(uint64(l)) + l
	}
	return n
}

func (m *SeasonPvpChooseCardReply) Size() (n int) {
	var l int
	_ = l
	if len(m.CardIDs) > 0 {
		l = 0
		for _, e := range m.CardIDs {
			l += sovPvp(uint64(e))
		}
		n += 1 + sovPvp(uint64(l)) + l
	}
	return n
}

func (m *FetchSeasonHandCardReply) Size() (n int) {
	var l int
	_ = l
	if len(m.CardIDs) > 0 {
		l = 0
		for _, e := range m.CardIDs {
			l += sovPvp(uint64(e))
		}
		n += 1 + sovPvp(uint64(l)) + l
	}
	if m.ChangeType != 0 {
		n += 1 + sovPvp(uint64(m.ChangeType))
	}
	if m.ChangeMaxPro != 0 {
		n += 1 + sovPvp(uint64(m.ChangeMaxPro))
	}
	if m.ChangeCurPro != 0 {
		n += 1 + sovPvp(uint64(m.ChangeCurPro))
	}
	if m.WinCnt != 0 {
		n += 1 + sovPvp(uint64(m.WinCnt))
	}
	return n
}

func (m *GetFighterDataArg) Size() (n int) {
	var l int
	_ = l
	if len(m.CardIDs) > 0 {
		l = 0
		for _, e := range m.CardIDs {
			l += sovPvp(uint64(e))
		}
		n += 1 + sovPvp(uint64(l)) + l
	}
	return n
}

func (m *LeagueRewardInfo) Size() (n int) {
	var l int
	_ = l
	if m.RemainTime != 0 {
		n += 1 + sovPvp(uint64(m.RemainTime))
	}
	if len(m.HasReceive) > 0 {
		for k, v := range m.HasReceive {
			_ = k
			_ = v
			mapEntrySize := 1 + sovPvp(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovPvp(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *LeagueRewardId) Size() (n int) {
	var l int
	_ = l
	if m.RewardId != 0 {
		n += 1 + sovPvp(uint64(m.RewardId))
	}
	return n
}

func (m *LeagueRewards) Size() (n int) {
	var l int
	_ = l
	if m.LeagueReward != nil {
		l = m.LeagueReward.Size()
		n += 1 + l + sovPvp(uint64(l))
	}
	return n
}

func (m *ReloadLeagueAttrArg) Size() (n int) {
	var l int
	_ = l
	if m.Area != 0 {
		n += 1 + sovPvp(uint64(m.Area))
	}
	if m.AppID != 0 {
		n += 1 + sovPvp(uint64(m.AppID))
	}
	if m.IsCrossSeason {
		n += 2
	}
	return n
}

func (m *GLeagueSeasonEndArg) Size() (n int) {
	var l int
	_ = l
	if m.Area != 0 {
		n += 1 + sovPvp(uint64(m.Area))
	}
	return n
}

func sovPvp(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPvp(x uint64) (n int) {
	return sovPvp(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MatchPlayer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchPlayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchPlayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Camp", wireType)
			}
			m.Camp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Camp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Camp", wireType)
			}
			m.Camp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Camp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (MatchArg_MatchType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedChooseCamp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedChooseCamp = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCamp", wireType)
			}
			m.LastCamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastCamp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChooseCardData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChooseCardData == nil {
				m.ChooseCardData = &SeasonPvpChooseCardData{}
			}
			if err := m.ChooseCardData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Player1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Player1 == nil {
				m.Player1 = &MatchPlayer{}
			}
			if err := m.Player1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Player2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Player2 == nil {
				m.Player2 = &MatchPlayer{}
			}
			if err := m.Player2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MatchDoneArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MatchDoneArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MatchDoneArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RoomId", wireType)
			}
			m.RoomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RoomId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BeginMatchArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BeginMatchArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BeginMatchArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Camp", wireType)
			}
			m.Camp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Camp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PvpScore", wireType)
			}
			m.PvpScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PvpScore |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mmr", wireType)
			}
			m.Mmr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mmr |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreakLoseCnt", wireType)
			}
			m.StreakLoseCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreakLoseCnt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HandCards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HandCards = append(m.HandCards, &SkinGCard{})
			if err := m.HandCards[len(m.HandCards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrawCards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DrawCards = append(m.DrawCards, &SkinGCard{})
			if err := m.DrawCards[len(m.DrawCards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardStrength", wireType)
			}
			m.CardStrength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardStrength |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadImgUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeadImgUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadFrame", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeadFrame = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonDataID", wireType)
			}
			m.SeasonDataID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeasonDataID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RebornCnt", wireType)
			}
			m.RebornCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RebornCnt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinRate", wireType)
			}
			m.WinRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WinRate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Area", wireType)
			}
			m.Area = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Area |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StreakWinCnt", wireType)
			}
			m.StreakWinCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StreakWinCnt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastOppUid", wireType)
			}
			m.LastOppUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastOppUid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RechargeMatchIndex", wireType)
			}
			m.RechargeMatchIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RechargeMatchIndex |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryFlag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CountryFlag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchScore", wireType)
			}
			m.MatchScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchScore |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BeginNewbiePvpMatchArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BeginNewbiePvpMatchArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BeginNewbiePvpMatchArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Camp", wireType)
			}
			m.Camp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Camp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PvpScore", wireType)
			}
			m.PvpScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PvpScore |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mmr", wireType)
			}
			m.Mmr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mmr |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnemyCamp", wireType)
			}
			m.EnemyCamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnemyCamp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HandCards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HandCards = append(m.HandCards, &SkinGCard{})
			if err := m.HandCards[len(m.HandCards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrawCards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DrawCards = append(m.DrawCards, &SkinGCard{})
			if err := m.DrawCards[len(m.DrawCards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFirstBattle", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFirstBattle = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadImgUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeadImgUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadFrame", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeadFrame = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinRate", wireType)
			}
			m.WinRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WinRate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Area", wireType)
			}
			m.Area = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Area |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryFlag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPvp
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CountryFlag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeasonPvpLimitTime) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeasonPvpLimitTime: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeasonPvpLimitTime: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitTime", wireType)
			}
			m.LimitTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeasonPvpInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeasonPvpInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeasonPvpInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitTime", wireType)
			}
			m.LimitTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstHandAmount", wireType)
			}
			m.FirstHandAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FirstHandAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackHandAmount", wireType)
			}
			m.BackHandAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BackHandAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstHandWinAmount", wireType)
			}
			m.FirstHandWinAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FirstHandWinAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BackHandWinAmount", wireType)
			}
			m.BackHandWinAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BackHandWinAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeasonPvpChooseCampArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeasonPvpChooseCampArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeasonPvpChooseCampArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Camp", wireType)
			}
			m.Camp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Camp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeasonPvpChooseCardData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeasonPvpChooseCardData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeasonPvpChooseCardData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPvp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CardIDs = append(m.CardIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPvp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPvp
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPvp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CardIDs = append(m.CardIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CardIDs", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedChooseAmount", wireType)
			}
			m.NeedChooseAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NeedChooseAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FreeRefreshCnt", wireType)
			}
			m.FreeRefreshCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FreeRefreshCnt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JadeRefreshCnt", wireType)
			}
			m.JadeRefreshCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JadeRefreshCnt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeasonPvpChooseCardArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeasonPvpChooseCardArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeasonPvpChooseCardArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPvp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CardIDs = append(m.CardIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPvp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPvp
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPvp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CardIDs = append(m.CardIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CardIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeasonPvpChooseCardReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeasonPvpChooseCardReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeasonPvpChooseCardReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPvp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CardIDs = append(m.CardIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPvp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPvp
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPvp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CardIDs = append(m.CardIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CardIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FetchSeasonHandCardReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FetchSeasonHandCardReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FetchSeasonHandCardReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPvp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CardIDs = append(m.CardIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPvp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPvp
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPvp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CardIDs = append(m.CardIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CardIDs", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeType", wireType)
			}
			m.ChangeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeType |= (FetchSeasonHandCardReply_ChangeTypeEnum(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeMaxPro", wireType)
			}
			m.ChangeMaxPro = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeMaxPro |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeCurPro", wireType)
			}
			m.ChangeCurPro = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeCurPro |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinCnt", wireType)
			}
			m.WinCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WinCnt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFighterDataArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetFighterDataArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetFighterDataArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPvp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CardIDs = append(m.CardIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPvp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPvp
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPvp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CardIDs = append(m.CardIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CardIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeagueRewardInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeagueRewardInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeagueRewardInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainTime", wireType)
			}
			m.RemainTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemainTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasReceive", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HasReceive == nil {
				m.HasReceive = make(map[int32]bool)
			}
			var mapkey int32
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPvp
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPvp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPvp
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPvp(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPvp
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.HasReceive[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeagueRewardId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeagueRewardId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeagueRewardId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardId", wireType)
			}
			m.RewardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeagueRewards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeagueRewards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeagueRewards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeagueReward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPvp
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeagueReward == nil {
				m.LeagueReward = &RewardList{}
			}
			if err := m.LeagueReward.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReloadLeagueAttrArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReloadLeagueAttrArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReloadLeagueAttrArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Area", wireType)
			}
			m.Area = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Area |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			m.AppID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCrossSeason", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCrossSeason = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GLeagueSeasonEndArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPvp
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GLeagueSeasonEndArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GLeagueSeasonEndArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Area", wireType)
			}
			m.Area = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Area |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPvp(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPvp
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPvp(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPvp
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPvp
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthPvp
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPvp
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPvp(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPvp = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPvp   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("pvp.proto", fileDescriptorPvp) }

var fileDescriptorPvp = []byte{
	// 1165 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xcd, 0x6e, 0xe3, 0x36,
	0x10, 0x5e, 0xd9, 0x4e, 0x62, 0x8f, 0x7f, 0xa2, 0xe5, 0x2e, 0x52, 0x21, 0x5d, 0x18, 0x86, 0xb0,
	0x5d, 0x78, 0x7f, 0x6a, 0xa0, 0x6e, 0x0f, 0xc5, 0x02, 0x3d, 0x24, 0x76, 0x9c, 0xb8, 0x75, 0xd2,
	0x80, 0x49, 0x90, 0x33, 0x63, 0x71, 0x6d, 0xc1, 0x16, 0xa5, 0x52, 0x8a, 0xb3, 0x7e, 0x90, 0x02,
	0x45, 0x81, 0x3e, 0x43, 0x8f, 0x7d, 0x85, 0x1e, 0xfb, 0x02, 0x05, 0x8a, 0xf4, 0xdc, 0x77, 0x28,
	0x86, 0x94, 0x25, 0xd9, 0xb1, 0xb7, 0x87, 0x62, 0x6f, 0x33, 0xdf, 0x7c, 0x9c, 0x21, 0x67, 0x86,
	0x43, 0x42, 0x29, 0x98, 0x05, 0xad, 0x40, 0xfa, 0x91, 0x4f, 0x72, 0xc1, 0xcd, 0x3e, 0x0c, 0x99,
	0x74, 0xb4, 0xbe, 0x6f, 0x4a, 0x7e, 0xc7, 0xa4, 0x33, 0x75, 0xc3, 0x28, 0x46, 0x40, 0x32, 0x31,
	0xd1, 0xb2, 0x7d, 0x0c, 0xe5, 0x53, 0x16, 0x0d, 0xc7, 0xe7, 0x53, 0x36, 0xe7, 0x92, 0x98, 0x90,
	0xbf, 0x72, 0x1d, 0xcb, 0x68, 0x18, 0xcd, 0x02, 0x45, 0x91, 0x10, 0x28, 0x9c, 0x31, 0x8f, 0x5b,
	0xb9, 0x86, 0xd1, 0x2c, 0x51, 0x25, 0x23, 0xd6, 0x61, 0x5e, 0x60, 0xe5, 0x1b, 0x46, 0x73, 0x8b,
	0x2a, 0xd9, 0xfe, 0x01, 0x8a, 0xca, 0xd1, 0x81, 0x1c, 0x25, 0x76, 0x23, 0xb5, 0x93, 0x57, 0x50,
	0xb8, 0x9c, 0x07, 0xda, 0x4f, 0xad, 0xbd, 0xd7, 0x0a, 0x6e, 0x5a, 0x0b, 0xbe, 0x16, 0xd0, 0x4a,
	0x15, 0xc7, 0xfe, 0x0c, 0x4a, 0x09, 0x44, 0x00, 0xb6, 0x07, 0xcc, 0x71, 0xb8, 0x34, 0x1f, 0x91,
	0x0a, 0x14, 0x2f, 0x25, 0x73, 0x85, 0x2b, 0x46, 0xa6, 0x61, 0xff, 0x68, 0x00, 0x28, 0x1e, 0xe5,
	0xc1, 0x74, 0x4e, 0x5e, 0x40, 0xed, 0x8c, 0x73, 0xa7, 0x33, 0xf6, 0xfd, 0x90, 0x27, 0xf1, 0x8b,
	0x74, 0x05, 0x25, 0xfb, 0x50, 0x1c, 0xb0, 0x30, 0x52, 0x8c, 0x9c, 0xda, 0x61, 0xa2, 0x93, 0x0e,
	0xd4, 0x16, 0x4c, 0xe9, 0x74, 0x59, 0xc4, 0xd4, 0x19, 0xcb, 0xed, 0x4f, 0x71, 0xbf, 0x17, 0x9c,
	0x85, 0xbe, 0x38, 0x9f, 0x05, 0xcb, 0x14, 0xba, 0xb2, 0xc4, 0x9e, 0xc7, 0xdb, 0xef, 0x8b, 0x77,
	0x3e, 0xd9, 0x83, 0x6d, 0xea, 0xfb, 0x5e, 0xdf, 0x89, 0xb3, 0x11, 0x6b, 0xe4, 0x25, 0xec, 0xe8,
	0x9c, 0x7f, 0xa1, 0x36, 0x51, 0x6e, 0xef, 0x26, 0x29, 0xd1, 0x38, 0x5d, 0xd8, 0x53, 0x6a, 0x3b,
	0xde, 0xcd, 0x26, 0x6a, 0xdb, 0x7e, 0x01, 0x15, 0x85, 0x77, 0x7d, 0xc1, 0xb1, 0x12, 0x1b, 0xa2,
	0xdb, 0xff, 0x14, 0xa0, 0x7a, 0xc8, 0x47, 0xae, 0xc8, 0xd6, 0x4c, 0xd5, 0xd9, 0x58, 0x53, 0xe7,
	0x5c, 0xa6, 0x8e, 0xfb, 0x50, 0x3c, 0x9f, 0x05, 0x17, 0x43, 0x5f, 0xf2, 0xb8, 0xfe, 0x89, 0x8e,
	0xdd, 0x73, 0xea, 0x49, 0xab, 0xa0, 0x60, 0x14, 0xc9, 0x73, 0xa8, 0x5e, 0x44, 0x92, 0xb3, 0xc9,
	0x00, 0x13, 0x24, 0x22, 0x6b, 0x4b, 0xd9, 0x96, 0x41, 0xf2, 0x1a, 0x4a, 0x27, 0x4c, 0x38, 0x98,
	0xc0, 0xd0, 0xda, 0x6e, 0xe4, 0x9b, 0xe5, 0x76, 0x55, 0x25, 0x7c, 0xe2, 0x8a, 0x63, 0x44, 0x69,
	0x6a, 0x47, 0x72, 0x57, 0xb2, 0x3b, 0x4d, 0xde, 0x59, 0x4b, 0x4e, 0xec, 0xc4, 0x86, 0x0a, 0x0a,
	0x18, 0x4e, 0x8c, 0xa2, 0xb1, 0x55, 0x54, 0xe1, 0x97, 0x30, 0x52, 0x07, 0x38, 0xe1, 0xcc, 0xe9,
	0x7b, 0xa3, 0x2b, 0x39, 0xb5, 0x4a, 0xea, 0xfc, 0x19, 0x84, 0x3c, 0x83, 0x12, 0x6a, 0x3d, 0x89,
	0xe9, 0x01, 0x65, 0x4e, 0x01, 0x8c, 0xa0, 0xfb, 0x02, 0x4b, 0xdf, 0xef, 0x5a, 0x65, 0x1d, 0x21,
	0x8b, 0xa1, 0x07, 0xca, 0x6f, 0x7c, 0x29, 0x30, 0x03, 0x15, 0x45, 0x48, 0x01, 0x62, 0xc1, 0xce,
	0xb5, 0x2b, 0x28, 0x8b, 0xb8, 0x55, 0x55, 0xb6, 0x85, 0x8a, 0xf9, 0x3f, 0x90, 0x9c, 0x59, 0x35,
	0x9d, 0x7f, 0x94, 0x55, 0x3c, 0x95, 0xbc, 0x6b, 0x57, 0xb9, 0xdb, 0x8d, 0xe3, 0x65, 0x30, 0x3c,
	0x11, 0x76, 0xf4, 0xf7, 0x41, 0x80, 0x97, 0xd9, 0x54, 0x97, 0x39, 0x83, 0x90, 0x16, 0x10, 0xca,
	0x87, 0x63, 0x26, 0x47, 0x3c, 0x6e, 0x54, 0x87, 0xbf, 0xb7, 0x1e, 0x2b, 0x4f, 0x6b, 0x2c, 0xa4,
	0x01, 0xe5, 0x8e, 0x7f, 0x2b, 0x22, 0x39, 0xef, 0x4d, 0xd9, 0xc8, 0x22, 0x2a, 0x07, 0x59, 0x08,
	0x23, 0x2a, 0xbe, 0xee, 0x8b, 0x27, 0xca, 0x53, 0x06, 0xb1, 0x7f, 0xce, 0xc3, 0x9e, 0xea, 0xb7,
	0x33, 0x7e, 0x77, 0xe3, 0xf2, 0xf3, 0x59, 0xf0, 0x91, 0x1b, 0xef, 0x19, 0x94, 0x8e, 0x04, 0xf7,
	0xe6, 0xca, 0x8d, 0x6e, 0xba, 0x14, 0xf8, 0x88, 0x0d, 0xf7, 0x1c, 0xaa, 0xfd, 0xb0, 0xe7, 0xca,
	0x30, 0x3a, 0x64, 0x51, 0x34, 0xe5, 0xaa, 0xe3, 0x8a, 0x74, 0x19, 0xfc, 0x9f, 0x2d, 0x97, 0x69,
	0x98, 0xf2, 0xfa, 0x86, 0xa9, 0x64, 0x1a, 0x66, 0xa5, 0x78, 0xd5, 0x07, 0xc5, 0xb3, 0xdb, 0x40,
	0x92, 0xd1, 0x36, 0x70, 0x3d, 0x37, 0xba, 0x74, 0x3d, 0x8e, 0x7b, 0x48, 0x94, 0x78, 0x7a, 0xa4,
	0x80, 0xfd, 0xa7, 0x01, 0xd5, 0x64, 0x91, 0x1a, 0x74, 0x1f, 0xe4, 0x93, 0x26, 0xec, 0xaa, 0x04,
	0x60, 0x5a, 0x0f, 0x3c, 0x0c, 0x1e, 0x17, 0x77, 0x15, 0xc6, 0x31, 0x7e, 0xc8, 0x86, 0x93, 0x0c,
	0x51, 0x57, 0x7b, 0x05, 0xc5, 0x26, 0x4e, 0x96, 0x5e, 0xbb, 0x22, 0xe6, 0xea, 0x16, 0x58, 0x63,
	0x21, 0x6f, 0xe0, 0xf1, 0xc2, 0x43, 0x4a, 0xd7, 0x9d, 0xf1, 0xd0, 0x60, 0xbf, 0x81, 0xbd, 0x07,
	0xe3, 0xde, 0x0b, 0x36, 0x3c, 0x6e, 0xf6, 0xaf, 0x06, 0x7c, 0xb2, 0xe1, 0x75, 0xc0, 0x6a, 0xa1,
	0xdc, 0xef, 0x86, 0x96, 0xd1, 0xc8, 0x37, 0xab, 0x74, 0xa1, 0x92, 0x57, 0x60, 0xa6, 0x4f, 0xd3,
	0x52, 0x52, 0x1e, 0xe0, 0x98, 0x95, 0x9e, 0xe4, 0x9c, 0xf2, 0x77, 0x92, 0x87, 0xe3, 0x4e, 0x9a,
	0x95, 0x65, 0x14, 0x79, 0xdf, 0x32, 0x27, 0xcb, 0xd3, 0x19, 0x59, 0x41, 0xed, 0xf6, 0x9a, 0xf3,
	0x49, 0x07, 0xcf, 0xb7, 0x71, 0xbf, 0xf6, 0x57, 0x60, 0xad, 0x59, 0xa3, 0x1f, 0xdf, 0xcd, 0xab,
	0x7e, 0xc9, 0x81, 0xd5, 0xe3, 0x38, 0x09, 0xd4, 0xda, 0xc5, 0xbd, 0xfa, 0x8f, 0x65, 0xe4, 0x3b,
	0x80, 0xce, 0x98, 0x89, 0x11, 0xcf, 0xfc, 0x1a, 0x5e, 0xe3, 0xb5, 0xdb, 0xe4, 0xab, 0x95, 0xd2,
	0x8f, 0xc4, 0xad, 0x47, 0x33, 0xcb, 0xd5, 0x33, 0xa0, 0xb4, 0x53, 0xf6, 0xfe, 0x5c, 0xfa, 0x71,
	0xee, 0x96, 0xb0, 0x94, 0xd3, 0xb9, 0x95, 0xc8, 0x29, 0x64, 0x39, 0x1a, 0xc3, 0xe7, 0x34, 0x1e,
	0xbb, 0xba, 0x71, 0x62, 0xcd, 0x7e, 0x8b, 0xdf, 0x86, 0x6c, 0x74, 0xfc, 0xb5, 0x5c, 0x89, 0x89,
	0xf0, 0xef, 0xcc, 0x47, 0xa4, 0x04, 0x5b, 0x3d, 0x77, 0x34, 0x8e, 0x4c, 0x83, 0xec, 0x40, 0xfe,
	0xda, 0x15, 0x66, 0x8e, 0x14, 0xa1, 0x80, 0xaf, 0x9f, 0x99, 0xb7, 0x3f, 0x87, 0xc7, 0xc7, 0x3c,
	0x52, 0x04, 0x2e, 0xb1, 0x63, 0x3e, 0x5c, 0x84, 0xdf, 0x0c, 0x30, 0x07, 0x9c, 0x8d, 0x6e, 0x39,
	0x55, 0xff, 0x3a, 0x75, 0xf7, 0xea, 0x00, 0x94, 0x7b, 0xcc, 0x15, 0xc9, 0xe5, 0xcb, 0xd3, 0x0c,
	0x42, 0xba, 0x00, 0x27, 0x2c, 0xa4, 0x7c, 0xc8, 0xdd, 0x19, 0x26, 0x13, 0x67, 0xd8, 0x73, 0x4c,
	0xe6, 0xaa, 0xa7, 0x56, 0x4a, 0x3b, 0xc2, 0xf9, 0x40, 0x33, 0xeb, 0xf6, 0xbf, 0x81, 0xdd, 0x15,
	0x33, 0x0e, 0xde, 0x09, 0x9f, 0xc7, 0x77, 0x01, 0x45, 0xf2, 0x14, 0xb6, 0x66, 0x6c, 0x7a, 0xab,
	0x4b, 0x56, 0xa4, 0x5a, 0x79, 0x9b, 0xfb, 0xda, 0xb0, 0xdf, 0x40, 0x6d, 0x29, 0x9c, 0x83, 0x23,
	0x5d, 0xc6, 0x72, 0xec, 0x22, 0xd1, 0xed, 0x0e, 0x54, 0xb3, 0xec, 0x90, 0xb4, 0xa1, 0x92, 0x05,
	0xd4, 0x82, 0x72, 0xbb, 0x86, 0xa7, 0xd0, 0xc8, 0xc0, 0x0d, 0x23, 0xba, 0xc4, 0xb1, 0x39, 0x3c,
	0xa1, 0x7c, 0xea, 0x33, 0x47, 0xa3, 0x07, 0x51, 0x24, 0xe3, 0x2b, 0xac, 0xc6, 0xa4, 0x91, 0x19,
	0x93, 0x4f, 0x61, 0xeb, 0x20, 0x08, 0xfa, 0x5d, 0xb5, 0xef, 0x2a, 0xd5, 0x8a, 0x1e, 0xe7, 0x1d,
	0xe9, 0x87, 0xa1, 0xee, 0x38, 0xd5, 0x39, 0x6a, 0x9c, 0x67, 0x40, 0xfb, 0x25, 0x3c, 0x39, 0xd6,
	0x11, 0x34, 0x70, 0x24, 0x9c, 0x0d, 0x61, 0x0e, 0xcd, 0xdf, 0xef, 0xeb, 0xc6, 0x1f, 0xf7, 0x75,
	0xe3, 0xaf, 0xfb, 0xba, 0xf1, 0xd3, 0xdf, 0xf5, 0x47, 0x37, 0xdb, 0xea, 0x23, 0xfe, 0xe5, 0xbf,
	0x01, 0x00, 0x00, 0xff, 0xff, 0x6b, 0x8e, 0xc5, 0x45, 0xc3, 0x0b, 0x00, 0x00,
}
