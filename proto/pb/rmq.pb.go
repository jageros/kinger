// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: rmq.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type RmqType int32

const (
	RmqType_Unknow_RmqType         RmqType = 0
	RmqType_BattleBegin            RmqType = 1
	RmqType_BattleEnd              RmqType = 2
	RmqType_Bonus                  RmqType = 3
	RmqType_AddFriendApply         RmqType = 4
	RmqType_ReplyFriendApply       RmqType = 5
	RmqType_BeDelFriend            RmqType = 6
	RmqType_PrivateChat            RmqType = 7
	RmqType_HelpLevel              RmqType = 8
	RmqType_WxInviteFriendTp       RmqType = 9
	RmqType_ForbidLogin            RmqType = 10
	RmqType_ForbidChat             RmqType = 11
	RmqType_SendMail               RmqType = 12
	RmqType_WxShareBeHelp          RmqType = 13
	RmqType_SdkRecharge            RmqType = 14
	RmqType_CampaignMissionDone    RmqType = 15
	RmqType_CampaignAcceptMission  RmqType = 16
	RmqType_UnifiedReward          RmqType = 17
	RmqType_ReturnDailyShareReward RmqType = 18
	RmqType_MonitorAccount         RmqType = 19
	RmqType_CompensateRecharge     RmqType = 20
)

var RmqType_name = map[int32]string{
	0:  "Unknow_RmqType",
	1:  "BattleBegin",
	2:  "BattleEnd",
	3:  "Bonus",
	4:  "AddFriendApply",
	5:  "ReplyFriendApply",
	6:  "BeDelFriend",
	7:  "PrivateChat",
	8:  "HelpLevel",
	9:  "WxInviteFriendTp",
	10: "ForbidLogin",
	11: "ForbidChat",
	12: "SendMail",
	13: "WxShareBeHelp",
	14: "SdkRecharge",
	15: "CampaignMissionDone",
	16: "CampaignAcceptMission",
	17: "UnifiedReward",
	18: "ReturnDailyShareReward",
	19: "MonitorAccount",
	20: "CompensateRecharge",
}
var RmqType_value = map[string]int32{
	"Unknow_RmqType":         0,
	"BattleBegin":            1,
	"BattleEnd":              2,
	"Bonus":                  3,
	"AddFriendApply":         4,
	"ReplyFriendApply":       5,
	"BeDelFriend":            6,
	"PrivateChat":            7,
	"HelpLevel":              8,
	"WxInviteFriendTp":       9,
	"ForbidLogin":            10,
	"ForbidChat":             11,
	"SendMail":               12,
	"WxShareBeHelp":          13,
	"SdkRecharge":            14,
	"CampaignMissionDone":    15,
	"CampaignAcceptMission":  16,
	"UnifiedReward":          17,
	"ReturnDailyShareReward": 18,
	"MonitorAccount":         19,
	"CompensateRecharge":     20,
}

func (x RmqType) String() string {
	return proto.EnumName(RmqType_name, int32(x))
}
func (RmqType) EnumDescriptor() ([]byte, []int) { return fileDescriptorRmq, []int{0} }

type RmqMessage struct {
	Type    RmqType `protobuf:"varint,1,opt,name=Type,proto3,enum=pb.RmqType" json:"Type,omitempty"`
	Payload []byte  `protobuf:"bytes,2,opt,name=Payload,proto3" json:"Payload,omitempty"`
}

func (m *RmqMessage) Reset()                    { *m = RmqMessage{} }
func (m *RmqMessage) String() string            { return proto.CompactTextString(m) }
func (*RmqMessage) ProtoMessage()               {}
func (*RmqMessage) Descriptor() ([]byte, []int) { return fileDescriptorRmq, []int{0} }

func (m *RmqMessage) GetType() RmqType {
	if m != nil {
		return m.Type
	}
	return RmqType_Unknow_RmqType
}

func (m *RmqMessage) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type RmqBattleBegin struct {
	BattleID   uint64 `protobuf:"varint,1,opt,name=BattleID,proto3" json:"BattleID,omitempty"`
	AppID      uint32 `protobuf:"varint,2,opt,name=AppID,proto3" json:"AppID,omitempty"`
	BattleType int32  `protobuf:"varint,3,opt,name=BattleType,proto3" json:"BattleType,omitempty"`
}

func (m *RmqBattleBegin) Reset()                    { *m = RmqBattleBegin{} }
func (m *RmqBattleBegin) String() string            { return proto.CompactTextString(m) }
func (*RmqBattleBegin) ProtoMessage()               {}
func (*RmqBattleBegin) Descriptor() ([]byte, []int) { return fileDescriptorRmq, []int{1} }

func (m *RmqBattleBegin) GetBattleID() uint64 {
	if m != nil {
		return m.BattleID
	}
	return 0
}

func (m *RmqBattleBegin) GetAppID() uint32 {
	if m != nil {
		return m.AppID
	}
	return 0
}

func (m *RmqBattleBegin) GetBattleType() int32 {
	if m != nil {
		return m.BattleType
	}
	return 0
}

type RmqBonus struct {
	ChangeRes []*Resource `protobuf:"bytes,1,rep,name=ChangeRes" json:"ChangeRes,omitempty"`
}

func (m *RmqBonus) Reset()                    { *m = RmqBonus{} }
func (m *RmqBonus) String() string            { return proto.CompactTextString(m) }
func (*RmqBonus) ProtoMessage()               {}
func (*RmqBonus) Descriptor() ([]byte, []int) { return fileDescriptorRmq, []int{2} }

func (m *RmqBonus) GetChangeRes() []*Resource {
	if m != nil {
		return m.ChangeRes
	}
	return nil
}

type EndFighterData struct {
	Uid           uint64       `protobuf:"varint,1,opt,name=Uid,proto3" json:"Uid,omitempty"`
	IsRobot       bool         `protobuf:"varint,2,opt,name=IsRobot,proto3" json:"IsRobot,omitempty"`
	IsSurrender   bool         `protobuf:"varint,3,opt,name=IsSurrender,proto3" json:"IsSurrender,omitempty"`
	Camp          int32        `protobuf:"varint,4,opt,name=Camp,proto3" json:"Camp,omitempty"`
	InitHandCards []*SkinGCard `protobuf:"bytes,5,rep,name=InitHandCards" json:"InitHandCards,omitempty"`
	IsFighter1    bool         `protobuf:"varint,6,opt,name=IsFighter1,proto3" json:"IsFighter1,omitempty"`
	IsFirstHand   bool         `protobuf:"varint,7,opt,name=IsFirstHand,proto3" json:"IsFirstHand,omitempty"`
	Mmr           int32        `protobuf:"varint,8,opt,name=Mmr,proto3" json:"Mmr,omitempty"`
	UseCards      []uint32     `protobuf:"varint,9,rep,packed,name=UseCards" json:"UseCards,omitempty"`
	Area          int32        `protobuf:"varint,10,opt,name=Area,proto3" json:"Area,omitempty"`
	IndexDiff     int32        `protobuf:"varint,11,opt,name=IndexDiff,proto3" json:"IndexDiff,omitempty"`
}

func (m *EndFighterData) Reset()                    { *m = EndFighterData{} }
func (m *EndFighterData) String() string            { return proto.CompactTextString(m) }
func (*EndFighterData) ProtoMessage()               {}
func (*EndFighterData) Descriptor() ([]byte, []int) { return fileDescriptorRmq, []int{3} }

func (m *EndFighterData) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *EndFighterData) GetIsRobot() bool {
	if m != nil {
		return m.IsRobot
	}
	return false
}

func (m *EndFighterData) GetIsSurrender() bool {
	if m != nil {
		return m.IsSurrender
	}
	return false
}

func (m *EndFighterData) GetCamp() int32 {
	if m != nil {
		return m.Camp
	}
	return 0
}

func (m *EndFighterData) GetInitHandCards() []*SkinGCard {
	if m != nil {
		return m.InitHandCards
	}
	return nil
}

func (m *EndFighterData) GetIsFighter1() bool {
	if m != nil {
		return m.IsFighter1
	}
	return false
}

func (m *EndFighterData) GetIsFirstHand() bool {
	if m != nil {
		return m.IsFirstHand
	}
	return false
}

func (m *EndFighterData) GetMmr() int32 {
	if m != nil {
		return m.Mmr
	}
	return 0
}

func (m *EndFighterData) GetUseCards() []uint32 {
	if m != nil {
		return m.UseCards
	}
	return nil
}

func (m *EndFighterData) GetArea() int32 {
	if m != nil {
		return m.Area
	}
	return 0
}

func (m *EndFighterData) GetIndexDiff() int32 {
	if m != nil {
		return m.IndexDiff
	}
	return 0
}

type RmqBattleEnd struct {
	BattleID    uint64          `protobuf:"varint,1,opt,name=BattleID,proto3" json:"BattleID,omitempty"`
	BattleType  int32           `protobuf:"varint,2,opt,name=BattleType,proto3" json:"BattleType,omitempty"`
	LevelID     int32           `protobuf:"varint,3,opt,name=LevelID,proto3" json:"LevelID,omitempty"`
	IsWonderful bool            `protobuf:"varint,4,opt,name=IsWonderful,proto3" json:"IsWonderful,omitempty"`
	Winner      *EndFighterData `protobuf:"bytes,5,opt,name=Winner" json:"Winner,omitempty"`
	Loser       *EndFighterData `protobuf:"bytes,6,opt,name=Loser" json:"Loser,omitempty"`
}

func (m *RmqBattleEnd) Reset()                    { *m = RmqBattleEnd{} }
func (m *RmqBattleEnd) String() string            { return proto.CompactTextString(m) }
func (*RmqBattleEnd) ProtoMessage()               {}
func (*RmqBattleEnd) Descriptor() ([]byte, []int) { return fileDescriptorRmq, []int{4} }

func (m *RmqBattleEnd) GetBattleID() uint64 {
	if m != nil {
		return m.BattleID
	}
	return 0
}

func (m *RmqBattleEnd) GetBattleType() int32 {
	if m != nil {
		return m.BattleType
	}
	return 0
}

func (m *RmqBattleEnd) GetLevelID() int32 {
	if m != nil {
		return m.LevelID
	}
	return 0
}

func (m *RmqBattleEnd) GetIsWonderful() bool {
	if m != nil {
		return m.IsWonderful
	}
	return false
}

func (m *RmqBattleEnd) GetWinner() *EndFighterData {
	if m != nil {
		return m.Winner
	}
	return nil
}

func (m *RmqBattleEnd) GetLoser() *EndFighterData {
	if m != nil {
		return m.Loser
	}
	return nil
}

type RmqAddFriendApply struct {
	FromUid  uint64 `protobuf:"varint,1,opt,name=FromUid,proto3" json:"FromUid,omitempty"`
	FromName string `protobuf:"bytes,2,opt,name=FromName,proto3" json:"FromName,omitempty"`
	IsInvite bool   `protobuf:"varint,3,opt,name=IsInvite,proto3" json:"IsInvite,omitempty"`
}

func (m *RmqAddFriendApply) Reset()                    { *m = RmqAddFriendApply{} }
func (m *RmqAddFriendApply) String() string            { return proto.CompactTextString(m) }
func (*RmqAddFriendApply) ProtoMessage()               {}
func (*RmqAddFriendApply) Descriptor() ([]byte, []int) { return fileDescriptorRmq, []int{5} }

func (m *RmqAddFriendApply) GetFromUid() uint64 {
	if m != nil {
		return m.FromUid
	}
	return 0
}

func (m *RmqAddFriendApply) GetFromName() string {
	if m != nil {
		return m.FromName
	}
	return ""
}

func (m *RmqAddFriendApply) GetIsInvite() bool {
	if m != nil {
		return m.IsInvite
	}
	return false
}

type RmqReplyFriendApply struct {
	FromUid  uint64 `protobuf:"varint,1,opt,name=FromUid,proto3" json:"FromUid,omitempty"`
	IsAgree  bool   `protobuf:"varint,2,opt,name=IsAgree,proto3" json:"IsAgree,omitempty"`
	FromName string `protobuf:"bytes,3,opt,name=FromName,proto3" json:"FromName,omitempty"`
}

func (m *RmqReplyFriendApply) Reset()                    { *m = RmqReplyFriendApply{} }
func (m *RmqReplyFriendApply) String() string            { return proto.CompactTextString(m) }
func (*RmqReplyFriendApply) ProtoMessage()               {}
func (*RmqReplyFriendApply) Descriptor() ([]byte, []int) { return fileDescriptorRmq, []int{6} }

func (m *RmqReplyFriendApply) GetFromUid() uint64 {
	if m != nil {
		return m.FromUid
	}
	return 0
}

func (m *RmqReplyFriendApply) GetIsAgree() bool {
	if m != nil {
		return m.IsAgree
	}
	return false
}

func (m *RmqReplyFriendApply) GetFromName() string {
	if m != nil {
		return m.FromName
	}
	return ""
}

type RmqBeDelFriend struct {
	FromUid uint64 `protobuf:"varint,1,opt,name=FromUid,proto3" json:"FromUid,omitempty"`
}

func (m *RmqBeDelFriend) Reset()                    { *m = RmqBeDelFriend{} }
func (m *RmqBeDelFriend) String() string            { return proto.CompactTextString(m) }
func (*RmqBeDelFriend) ProtoMessage()               {}
func (*RmqBeDelFriend) Descriptor() ([]byte, []int) { return fileDescriptorRmq, []int{7} }

func (m *RmqBeDelFriend) GetFromUid() uint64 {
	if m != nil {
		return m.FromUid
	}
	return 0
}

type RmqPrivateChat struct {
	FromUid         uint64 `protobuf:"varint,1,opt,name=FromUid,proto3" json:"FromUid,omitempty"`
	FromName        string `protobuf:"bytes,2,opt,name=FromName,proto3" json:"FromName,omitempty"`
	FromHeadImgUrl  string `protobuf:"bytes,3,opt,name=FromHeadImgUrl,proto3" json:"FromHeadImgUrl,omitempty"`
	Msg             string `protobuf:"bytes,4,opt,name=Msg,proto3" json:"Msg,omitempty"`
	Time            int32  `protobuf:"varint,5,opt,name=Time,proto3" json:"Time,omitempty"`
	FromPvpLevel    int32  `protobuf:"varint,6,opt,name=FromPvpLevel,proto3" json:"FromPvpLevel,omitempty"`
	FromCountry     string `protobuf:"bytes,7,opt,name=FromCountry,proto3" json:"FromCountry,omitempty"`
	FromHeadFrame   string `protobuf:"bytes,8,opt,name=FromHeadFrame,proto3" json:"FromHeadFrame,omitempty"`
	ChatPop         string `protobuf:"bytes,9,opt,name=ChatPop,proto3" json:"ChatPop,omitempty"`
	FromCountryFlag string `protobuf:"bytes,10,opt,name=FromCountryFlag,proto3" json:"FromCountryFlag,omitempty"`
}

func (m *RmqPrivateChat) Reset()                    { *m = RmqPrivateChat{} }
func (m *RmqPrivateChat) String() string            { return proto.CompactTextString(m) }
func (*RmqPrivateChat) ProtoMessage()               {}
func (*RmqPrivateChat) Descriptor() ([]byte, []int) { return fileDescriptorRmq, []int{8} }

func (m *RmqPrivateChat) GetFromUid() uint64 {
	if m != nil {
		return m.FromUid
	}
	return 0
}

func (m *RmqPrivateChat) GetFromName() string {
	if m != nil {
		return m.FromName
	}
	return ""
}

func (m *RmqPrivateChat) GetFromHeadImgUrl() string {
	if m != nil {
		return m.FromHeadImgUrl
	}
	return ""
}

func (m *RmqPrivateChat) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *RmqPrivateChat) GetTime() int32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *RmqPrivateChat) GetFromPvpLevel() int32 {
	if m != nil {
		return m.FromPvpLevel
	}
	return 0
}

func (m *RmqPrivateChat) GetFromCountry() string {
	if m != nil {
		return m.FromCountry
	}
	return ""
}

func (m *RmqPrivateChat) GetFromHeadFrame() string {
	if m != nil {
		return m.FromHeadFrame
	}
	return ""
}

func (m *RmqPrivateChat) GetChatPop() string {
	if m != nil {
		return m.ChatPop
	}
	return ""
}

func (m *RmqPrivateChat) GetFromCountryFlag() string {
	if m != nil {
		return m.FromCountryFlag
	}
	return ""
}

type RmqHelpLevel struct {
	HelperUid  uint64 `protobuf:"varint,1,opt,name=HelperUid,proto3" json:"HelperUid,omitempty"`
	HelperName string `protobuf:"bytes,2,opt,name=HelperName,proto3" json:"HelperName,omitempty"`
	LevelID    int32  `protobuf:"varint,3,opt,name=LevelID,proto3" json:"LevelID,omitempty"`
	BattleID   uint64 `protobuf:"varint,4,opt,name=BattleID,proto3" json:"BattleID,omitempty"`
}

func (m *RmqHelpLevel) Reset()                    { *m = RmqHelpLevel{} }
func (m *RmqHelpLevel) String() string            { return proto.CompactTextString(m) }
func (*RmqHelpLevel) ProtoMessage()               {}
func (*RmqHelpLevel) Descriptor() ([]byte, []int) { return fileDescriptorRmq, []int{9} }

func (m *RmqHelpLevel) GetHelperUid() uint64 {
	if m != nil {
		return m.HelperUid
	}
	return 0
}

func (m *RmqHelpLevel) GetHelperName() string {
	if m != nil {
		return m.HelperName
	}
	return ""
}

func (m *RmqHelpLevel) GetLevelID() int32 {
	if m != nil {
		return m.LevelID
	}
	return 0
}

func (m *RmqHelpLevel) GetBattleID() uint64 {
	if m != nil {
		return m.BattleID
	}
	return 0
}

type RmqWxInviteFriend struct {
	Uid         uint64 `protobuf:"varint,1,opt,name=Uid,proto3" json:"Uid,omitempty"`
	HeadImgUrl  string `protobuf:"bytes,2,opt,name=HeadImgUrl,proto3" json:"HeadImgUrl,omitempty"`
	MaxPvpLevel int32  `protobuf:"varint,3,opt,name=MaxPvpLevel,proto3" json:"MaxPvpLevel,omitempty"`
}

func (m *RmqWxInviteFriend) Reset()                    { *m = RmqWxInviteFriend{} }
func (m *RmqWxInviteFriend) String() string            { return proto.CompactTextString(m) }
func (*RmqWxInviteFriend) ProtoMessage()               {}
func (*RmqWxInviteFriend) Descriptor() ([]byte, []int) { return fileDescriptorRmq, []int{10} }

func (m *RmqWxInviteFriend) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *RmqWxInviteFriend) GetHeadImgUrl() string {
	if m != nil {
		return m.HeadImgUrl
	}
	return ""
}

func (m *RmqWxInviteFriend) GetMaxPvpLevel() int32 {
	if m != nil {
		return m.MaxPvpLevel
	}
	return 0
}

type RmqForbidLogin struct {
	IsForbid bool  `protobuf:"varint,1,opt,name=IsForbid,proto3" json:"IsForbid,omitempty"`
	OverTime int64 `protobuf:"varint,2,opt,name=OverTime,proto3" json:"OverTime,omitempty"`
}

func (m *RmqForbidLogin) Reset()                    { *m = RmqForbidLogin{} }
func (m *RmqForbidLogin) String() string            { return proto.CompactTextString(m) }
func (*RmqForbidLogin) ProtoMessage()               {}
func (*RmqForbidLogin) Descriptor() ([]byte, []int) { return fileDescriptorRmq, []int{11} }

func (m *RmqForbidLogin) GetIsForbid() bool {
	if m != nil {
		return m.IsForbid
	}
	return false
}

func (m *RmqForbidLogin) GetOverTime() int64 {
	if m != nil {
		return m.OverTime
	}
	return 0
}

type RmqForbidChat struct {
	IsForbid bool  `protobuf:"varint,1,opt,name=IsForbid,proto3" json:"IsForbid,omitempty"`
	OverTime int64 `protobuf:"varint,2,opt,name=OverTime,proto3" json:"OverTime,omitempty"`
}

func (m *RmqForbidChat) Reset()                    { *m = RmqForbidChat{} }
func (m *RmqForbidChat) String() string            { return proto.CompactTextString(m) }
func (*RmqForbidChat) ProtoMessage()               {}
func (*RmqForbidChat) Descriptor() ([]byte, []int) { return fileDescriptorRmq, []int{12} }

func (m *RmqForbidChat) GetIsForbid() bool {
	if m != nil {
		return m.IsForbid
	}
	return false
}

func (m *RmqForbidChat) GetOverTime() int64 {
	if m != nil {
		return m.OverTime
	}
	return 0
}

type RmqMonitorAccount struct {
	IsForbid bool  `protobuf:"varint,1,opt,name=IsForbid,proto3" json:"IsForbid,omitempty"`
	OverTime int64 `protobuf:"varint,2,opt,name=OverTime,proto3" json:"OverTime,omitempty"`
	OpTime   int64 `protobuf:"varint,3,opt,name=OpTime,proto3" json:"OpTime,omitempty"`
}

func (m *RmqMonitorAccount) Reset()                    { *m = RmqMonitorAccount{} }
func (m *RmqMonitorAccount) String() string            { return proto.CompactTextString(m) }
func (*RmqMonitorAccount) ProtoMessage()               {}
func (*RmqMonitorAccount) Descriptor() ([]byte, []int) { return fileDescriptorRmq, []int{13} }

func (m *RmqMonitorAccount) GetIsForbid() bool {
	if m != nil {
		return m.IsForbid
	}
	return false
}

func (m *RmqMonitorAccount) GetOverTime() int64 {
	if m != nil {
		return m.OverTime
	}
	return 0
}

func (m *RmqMonitorAccount) GetOpTime() int64 {
	if m != nil {
		return m.OpTime
	}
	return 0
}

type RmqWxShareBeHelp struct {
	ShareType int32  `protobuf:"varint,1,opt,name=ShareType,proto3" json:"ShareType,omitempty"`
	ShareTime int64  `protobuf:"varint,2,opt,name=ShareTime,proto3" json:"ShareTime,omitempty"`
	Data      []byte `protobuf:"bytes,3,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *RmqWxShareBeHelp) Reset()                    { *m = RmqWxShareBeHelp{} }
func (m *RmqWxShareBeHelp) String() string            { return proto.CompactTextString(m) }
func (*RmqWxShareBeHelp) ProtoMessage()               {}
func (*RmqWxShareBeHelp) Descriptor() ([]byte, []int) { return fileDescriptorRmq, []int{14} }

func (m *RmqWxShareBeHelp) GetShareType() int32 {
	if m != nil {
		return m.ShareType
	}
	return 0
}

func (m *RmqWxShareBeHelp) GetShareTime() int64 {
	if m != nil {
		return m.ShareTime
	}
	return 0
}

func (m *RmqWxShareBeHelp) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type RmqSdkRecharge struct {
	ChannelUid     string `protobuf:"bytes,1,opt,name=ChannelUid,proto3" json:"ChannelUid,omitempty"`
	CpOrderID      string `protobuf:"bytes,2,opt,name=CpOrderID,proto3" json:"CpOrderID,omitempty"`
	ChannelOrderID string `protobuf:"bytes,3,opt,name=ChannelOrderID,proto3" json:"ChannelOrderID,omitempty"`
	PaymentAmount  int32  `protobuf:"varint,4,opt,name=PaymentAmount,proto3" json:"PaymentAmount,omitempty"`
	NeedCheckMoney bool   `protobuf:"varint,5,opt,name=NeedCheckMoney,proto3" json:"NeedCheckMoney,omitempty"`
}

func (m *RmqSdkRecharge) Reset()                    { *m = RmqSdkRecharge{} }
func (m *RmqSdkRecharge) String() string            { return proto.CompactTextString(m) }
func (*RmqSdkRecharge) ProtoMessage()               {}
func (*RmqSdkRecharge) Descriptor() ([]byte, []int) { return fileDescriptorRmq, []int{15} }

func (m *RmqSdkRecharge) GetChannelUid() string {
	if m != nil {
		return m.ChannelUid
	}
	return ""
}

func (m *RmqSdkRecharge) GetCpOrderID() string {
	if m != nil {
		return m.CpOrderID
	}
	return ""
}

func (m *RmqSdkRecharge) GetChannelOrderID() string {
	if m != nil {
		return m.ChannelOrderID
	}
	return ""
}

func (m *RmqSdkRecharge) GetPaymentAmount() int32 {
	if m != nil {
		return m.PaymentAmount
	}
	return 0
}

func (m *RmqSdkRecharge) GetNeedCheckMoney() bool {
	if m != nil {
		return m.NeedCheckMoney
	}
	return false
}

type RmqCampaignMissionDone struct {
	Cards []uint32 `protobuf:"varint,1,rep,packed,name=Cards" json:"Cards,omitempty"`
}

func (m *RmqCampaignMissionDone) Reset()                    { *m = RmqCampaignMissionDone{} }
func (m *RmqCampaignMissionDone) String() string            { return proto.CompactTextString(m) }
func (*RmqCampaignMissionDone) ProtoMessage()               {}
func (*RmqCampaignMissionDone) Descriptor() ([]byte, []int) { return fileDescriptorRmq, []int{16} }

func (m *RmqCampaignMissionDone) GetCards() []uint32 {
	if m != nil {
		return m.Cards
	}
	return nil
}

type RmqCampaignAcceptMission struct {
	Cards []uint32 `protobuf:"varint,1,rep,packed,name=Cards" json:"Cards,omitempty"`
}

func (m *RmqCampaignAcceptMission) Reset()                    { *m = RmqCampaignAcceptMission{} }
func (m *RmqCampaignAcceptMission) String() string            { return proto.CompactTextString(m) }
func (*RmqCampaignAcceptMission) ProtoMessage()               {}
func (*RmqCampaignAcceptMission) Descriptor() ([]byte, []int) { return fileDescriptorRmq, []int{17} }

func (m *RmqCampaignAcceptMission) GetCards() []uint32 {
	if m != nil {
		return m.Cards
	}
	return nil
}

type RmqUnifiedReward struct {
	Rank            int32  `protobuf:"varint,1,opt,name=Rank,proto3" json:"Rank,omitempty"`
	Contribution    int32  `protobuf:"varint,2,opt,name=Contribution,proto3" json:"Contribution,omitempty"`
	YourMajestyName string `protobuf:"bytes,3,opt,name=YourMajestyName,proto3" json:"YourMajestyName,omitempty"`
	CountryName     string `protobuf:"bytes,4,opt,name=CountryName,proto3" json:"CountryName,omitempty"`
}

func (m *RmqUnifiedReward) Reset()                    { *m = RmqUnifiedReward{} }
func (m *RmqUnifiedReward) String() string            { return proto.CompactTextString(m) }
func (*RmqUnifiedReward) ProtoMessage()               {}
func (*RmqUnifiedReward) Descriptor() ([]byte, []int) { return fileDescriptorRmq, []int{18} }

func (m *RmqUnifiedReward) GetRank() int32 {
	if m != nil {
		return m.Rank
	}
	return 0
}

func (m *RmqUnifiedReward) GetContribution() int32 {
	if m != nil {
		return m.Contribution
	}
	return 0
}

func (m *RmqUnifiedReward) GetYourMajestyName() string {
	if m != nil {
		return m.YourMajestyName
	}
	return ""
}

func (m *RmqUnifiedReward) GetCountryName() string {
	if m != nil {
		return m.CountryName
	}
	return ""
}

type RmqCompensateRecharge struct {
	CpOrderID      string `protobuf:"bytes,1,opt,name=CpOrderID,proto3" json:"CpOrderID,omitempty"`
	ChannelOrderID string `protobuf:"bytes,2,opt,name=ChannelOrderID,proto3" json:"ChannelOrderID,omitempty"`
	GoodsID        string `protobuf:"bytes,3,opt,name=GoodsID,proto3" json:"GoodsID,omitempty"`
}

func (m *RmqCompensateRecharge) Reset()                    { *m = RmqCompensateRecharge{} }
func (m *RmqCompensateRecharge) String() string            { return proto.CompactTextString(m) }
func (*RmqCompensateRecharge) ProtoMessage()               {}
func (*RmqCompensateRecharge) Descriptor() ([]byte, []int) { return fileDescriptorRmq, []int{19} }

func (m *RmqCompensateRecharge) GetCpOrderID() string {
	if m != nil {
		return m.CpOrderID
	}
	return ""
}

func (m *RmqCompensateRecharge) GetChannelOrderID() string {
	if m != nil {
		return m.ChannelOrderID
	}
	return ""
}

func (m *RmqCompensateRecharge) GetGoodsID() string {
	if m != nil {
		return m.GoodsID
	}
	return ""
}

func init() {
	proto.RegisterType((*RmqMessage)(nil), "pb.RmqMessage")
	proto.RegisterType((*RmqBattleBegin)(nil), "pb.RmqBattleBegin")
	proto.RegisterType((*RmqBonus)(nil), "pb.RmqBonus")
	proto.RegisterType((*EndFighterData)(nil), "pb.EndFighterData")
	proto.RegisterType((*RmqBattleEnd)(nil), "pb.RmqBattleEnd")
	proto.RegisterType((*RmqAddFriendApply)(nil), "pb.RmqAddFriendApply")
	proto.RegisterType((*RmqReplyFriendApply)(nil), "pb.RmqReplyFriendApply")
	proto.RegisterType((*RmqBeDelFriend)(nil), "pb.RmqBeDelFriend")
	proto.RegisterType((*RmqPrivateChat)(nil), "pb.RmqPrivateChat")
	proto.RegisterType((*RmqHelpLevel)(nil), "pb.RmqHelpLevel")
	proto.RegisterType((*RmqWxInviteFriend)(nil), "pb.RmqWxInviteFriend")
	proto.RegisterType((*RmqForbidLogin)(nil), "pb.RmqForbidLogin")
	proto.RegisterType((*RmqForbidChat)(nil), "pb.RmqForbidChat")
	proto.RegisterType((*RmqMonitorAccount)(nil), "pb.RmqMonitorAccount")
	proto.RegisterType((*RmqWxShareBeHelp)(nil), "pb.RmqWxShareBeHelp")
	proto.RegisterType((*RmqSdkRecharge)(nil), "pb.RmqSdkRecharge")
	proto.RegisterType((*RmqCampaignMissionDone)(nil), "pb.RmqCampaignMissionDone")
	proto.RegisterType((*RmqCampaignAcceptMission)(nil), "pb.RmqCampaignAcceptMission")
	proto.RegisterType((*RmqUnifiedReward)(nil), "pb.RmqUnifiedReward")
	proto.RegisterType((*RmqCompensateRecharge)(nil), "pb.RmqCompensateRecharge")
	proto.RegisterEnum("pb.RmqType", RmqType_name, RmqType_value)
}
func (m *RmqMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RmqMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.Type))
	}
	if len(m.Payload) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRmq(dAtA, i, uint64(len(m.Payload)))
		i += copy(dAtA[i:], m.Payload)
	}
	return i, nil
}

func (m *RmqBattleBegin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RmqBattleBegin) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BattleID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.BattleID))
	}
	if m.AppID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.AppID))
	}
	if m.BattleType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.BattleType))
	}
	return i, nil
}

func (m *RmqBonus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RmqBonus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChangeRes) > 0 {
		for _, msg := range m.ChangeRes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRmq(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EndFighterData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EndFighterData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.Uid))
	}
	if m.IsRobot {
		dAtA[i] = 0x10
		i++
		if m.IsRobot {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsSurrender {
		dAtA[i] = 0x18
		i++
		if m.IsSurrender {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Camp != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.Camp))
	}
	if len(m.InitHandCards) > 0 {
		for _, msg := range m.InitHandCards {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintRmq(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.IsFighter1 {
		dAtA[i] = 0x30
		i++
		if m.IsFighter1 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsFirstHand {
		dAtA[i] = 0x38
		i++
		if m.IsFirstHand {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Mmr != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.Mmr))
	}
	if len(m.UseCards) > 0 {
		dAtA2 := make([]byte, len(m.UseCards)*10)
		var j1 int
		for _, num := range m.UseCards {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0x4a
		i++
		i = encodeVarintRmq(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	if m.Area != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.Area))
	}
	if m.IndexDiff != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.IndexDiff))
	}
	return i, nil
}

func (m *RmqBattleEnd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RmqBattleEnd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BattleID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.BattleID))
	}
	if m.BattleType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.BattleType))
	}
	if m.LevelID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.LevelID))
	}
	if m.IsWonderful {
		dAtA[i] = 0x20
		i++
		if m.IsWonderful {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Winner != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.Winner.Size()))
		n3, err := m.Winner.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Loser != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.Loser.Size()))
		n4, err := m.Loser.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *RmqAddFriendApply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RmqAddFriendApply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FromUid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.FromUid))
	}
	if len(m.FromName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRmq(dAtA, i, uint64(len(m.FromName)))
		i += copy(dAtA[i:], m.FromName)
	}
	if m.IsInvite {
		dAtA[i] = 0x18
		i++
		if m.IsInvite {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RmqReplyFriendApply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RmqReplyFriendApply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FromUid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.FromUid))
	}
	if m.IsAgree {
		dAtA[i] = 0x10
		i++
		if m.IsAgree {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.FromName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRmq(dAtA, i, uint64(len(m.FromName)))
		i += copy(dAtA[i:], m.FromName)
	}
	return i, nil
}

func (m *RmqBeDelFriend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RmqBeDelFriend) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FromUid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.FromUid))
	}
	return i, nil
}

func (m *RmqPrivateChat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RmqPrivateChat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FromUid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.FromUid))
	}
	if len(m.FromName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRmq(dAtA, i, uint64(len(m.FromName)))
		i += copy(dAtA[i:], m.FromName)
	}
	if len(m.FromHeadImgUrl) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRmq(dAtA, i, uint64(len(m.FromHeadImgUrl)))
		i += copy(dAtA[i:], m.FromHeadImgUrl)
	}
	if len(m.Msg) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRmq(dAtA, i, uint64(len(m.Msg)))
		i += copy(dAtA[i:], m.Msg)
	}
	if m.Time != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.Time))
	}
	if m.FromPvpLevel != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.FromPvpLevel))
	}
	if len(m.FromCountry) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintRmq(dAtA, i, uint64(len(m.FromCountry)))
		i += copy(dAtA[i:], m.FromCountry)
	}
	if len(m.FromHeadFrame) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintRmq(dAtA, i, uint64(len(m.FromHeadFrame)))
		i += copy(dAtA[i:], m.FromHeadFrame)
	}
	if len(m.ChatPop) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintRmq(dAtA, i, uint64(len(m.ChatPop)))
		i += copy(dAtA[i:], m.ChatPop)
	}
	if len(m.FromCountryFlag) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintRmq(dAtA, i, uint64(len(m.FromCountryFlag)))
		i += copy(dAtA[i:], m.FromCountryFlag)
	}
	return i, nil
}

func (m *RmqHelpLevel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RmqHelpLevel) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.HelperUid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.HelperUid))
	}
	if len(m.HelperName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRmq(dAtA, i, uint64(len(m.HelperName)))
		i += copy(dAtA[i:], m.HelperName)
	}
	if m.LevelID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.LevelID))
	}
	if m.BattleID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.BattleID))
	}
	return i, nil
}

func (m *RmqWxInviteFriend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RmqWxInviteFriend) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.Uid))
	}
	if len(m.HeadImgUrl) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRmq(dAtA, i, uint64(len(m.HeadImgUrl)))
		i += copy(dAtA[i:], m.HeadImgUrl)
	}
	if m.MaxPvpLevel != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.MaxPvpLevel))
	}
	return i, nil
}

func (m *RmqForbidLogin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RmqForbidLogin) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsForbid {
		dAtA[i] = 0x8
		i++
		if m.IsForbid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OverTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.OverTime))
	}
	return i, nil
}

func (m *RmqForbidChat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RmqForbidChat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsForbid {
		dAtA[i] = 0x8
		i++
		if m.IsForbid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OverTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.OverTime))
	}
	return i, nil
}

func (m *RmqMonitorAccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RmqMonitorAccount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsForbid {
		dAtA[i] = 0x8
		i++
		if m.IsForbid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OverTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.OverTime))
	}
	if m.OpTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.OpTime))
	}
	return i, nil
}

func (m *RmqWxShareBeHelp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RmqWxShareBeHelp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ShareType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.ShareType))
	}
	if m.ShareTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.ShareTime))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRmq(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *RmqSdkRecharge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RmqSdkRecharge) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChannelUid) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRmq(dAtA, i, uint64(len(m.ChannelUid)))
		i += copy(dAtA[i:], m.ChannelUid)
	}
	if len(m.CpOrderID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRmq(dAtA, i, uint64(len(m.CpOrderID)))
		i += copy(dAtA[i:], m.CpOrderID)
	}
	if len(m.ChannelOrderID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRmq(dAtA, i, uint64(len(m.ChannelOrderID)))
		i += copy(dAtA[i:], m.ChannelOrderID)
	}
	if m.PaymentAmount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.PaymentAmount))
	}
	if m.NeedCheckMoney {
		dAtA[i] = 0x28
		i++
		if m.NeedCheckMoney {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *RmqCampaignMissionDone) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RmqCampaignMissionDone) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Cards) > 0 {
		dAtA6 := make([]byte, len(m.Cards)*10)
		var j5 int
		for _, num := range m.Cards {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintRmq(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	return i, nil
}

func (m *RmqCampaignAcceptMission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RmqCampaignAcceptMission) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Cards) > 0 {
		dAtA8 := make([]byte, len(m.Cards)*10)
		var j7 int
		for _, num := range m.Cards {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintRmq(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	return i, nil
}

func (m *RmqUnifiedReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RmqUnifiedReward) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Rank != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.Rank))
	}
	if m.Contribution != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRmq(dAtA, i, uint64(m.Contribution))
	}
	if len(m.YourMajestyName) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRmq(dAtA, i, uint64(len(m.YourMajestyName)))
		i += copy(dAtA[i:], m.YourMajestyName)
	}
	if len(m.CountryName) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRmq(dAtA, i, uint64(len(m.CountryName)))
		i += copy(dAtA[i:], m.CountryName)
	}
	return i, nil
}

func (m *RmqCompensateRecharge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RmqCompensateRecharge) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CpOrderID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRmq(dAtA, i, uint64(len(m.CpOrderID)))
		i += copy(dAtA[i:], m.CpOrderID)
	}
	if len(m.ChannelOrderID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRmq(dAtA, i, uint64(len(m.ChannelOrderID)))
		i += copy(dAtA[i:], m.ChannelOrderID)
	}
	if len(m.GoodsID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRmq(dAtA, i, uint64(len(m.GoodsID)))
		i += copy(dAtA[i:], m.GoodsID)
	}
	return i, nil
}

func encodeVarintRmq(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *RmqMessage) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovRmq(uint64(m.Type))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovRmq(uint64(l))
	}
	return n
}

func (m *RmqBattleBegin) Size() (n int) {
	var l int
	_ = l
	if m.BattleID != 0 {
		n += 1 + sovRmq(uint64(m.BattleID))
	}
	if m.AppID != 0 {
		n += 1 + sovRmq(uint64(m.AppID))
	}
	if m.BattleType != 0 {
		n += 1 + sovRmq(uint64(m.BattleType))
	}
	return n
}

func (m *RmqBonus) Size() (n int) {
	var l int
	_ = l
	if len(m.ChangeRes) > 0 {
		for _, e := range m.ChangeRes {
			l = e.Size()
			n += 1 + l + sovRmq(uint64(l))
		}
	}
	return n
}

func (m *EndFighterData) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovRmq(uint64(m.Uid))
	}
	if m.IsRobot {
		n += 2
	}
	if m.IsSurrender {
		n += 2
	}
	if m.Camp != 0 {
		n += 1 + sovRmq(uint64(m.Camp))
	}
	if len(m.InitHandCards) > 0 {
		for _, e := range m.InitHandCards {
			l = e.Size()
			n += 1 + l + sovRmq(uint64(l))
		}
	}
	if m.IsFighter1 {
		n += 2
	}
	if m.IsFirstHand {
		n += 2
	}
	if m.Mmr != 0 {
		n += 1 + sovRmq(uint64(m.Mmr))
	}
	if len(m.UseCards) > 0 {
		l = 0
		for _, e := range m.UseCards {
			l += sovRmq(uint64(e))
		}
		n += 1 + sovRmq(uint64(l)) + l
	}
	if m.Area != 0 {
		n += 1 + sovRmq(uint64(m.Area))
	}
	if m.IndexDiff != 0 {
		n += 1 + sovRmq(uint64(m.IndexDiff))
	}
	return n
}

func (m *RmqBattleEnd) Size() (n int) {
	var l int
	_ = l
	if m.BattleID != 0 {
		n += 1 + sovRmq(uint64(m.BattleID))
	}
	if m.BattleType != 0 {
		n += 1 + sovRmq(uint64(m.BattleType))
	}
	if m.LevelID != 0 {
		n += 1 + sovRmq(uint64(m.LevelID))
	}
	if m.IsWonderful {
		n += 2
	}
	if m.Winner != nil {
		l = m.Winner.Size()
		n += 1 + l + sovRmq(uint64(l))
	}
	if m.Loser != nil {
		l = m.Loser.Size()
		n += 1 + l + sovRmq(uint64(l))
	}
	return n
}

func (m *RmqAddFriendApply) Size() (n int) {
	var l int
	_ = l
	if m.FromUid != 0 {
		n += 1 + sovRmq(uint64(m.FromUid))
	}
	l = len(m.FromName)
	if l > 0 {
		n += 1 + l + sovRmq(uint64(l))
	}
	if m.IsInvite {
		n += 2
	}
	return n
}

func (m *RmqReplyFriendApply) Size() (n int) {
	var l int
	_ = l
	if m.FromUid != 0 {
		n += 1 + sovRmq(uint64(m.FromUid))
	}
	if m.IsAgree {
		n += 2
	}
	l = len(m.FromName)
	if l > 0 {
		n += 1 + l + sovRmq(uint64(l))
	}
	return n
}

func (m *RmqBeDelFriend) Size() (n int) {
	var l int
	_ = l
	if m.FromUid != 0 {
		n += 1 + sovRmq(uint64(m.FromUid))
	}
	return n
}

func (m *RmqPrivateChat) Size() (n int) {
	var l int
	_ = l
	if m.FromUid != 0 {
		n += 1 + sovRmq(uint64(m.FromUid))
	}
	l = len(m.FromName)
	if l > 0 {
		n += 1 + l + sovRmq(uint64(l))
	}
	l = len(m.FromHeadImgUrl)
	if l > 0 {
		n += 1 + l + sovRmq(uint64(l))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovRmq(uint64(l))
	}
	if m.Time != 0 {
		n += 1 + sovRmq(uint64(m.Time))
	}
	if m.FromPvpLevel != 0 {
		n += 1 + sovRmq(uint64(m.FromPvpLevel))
	}
	l = len(m.FromCountry)
	if l > 0 {
		n += 1 + l + sovRmq(uint64(l))
	}
	l = len(m.FromHeadFrame)
	if l > 0 {
		n += 1 + l + sovRmq(uint64(l))
	}
	l = len(m.ChatPop)
	if l > 0 {
		n += 1 + l + sovRmq(uint64(l))
	}
	l = len(m.FromCountryFlag)
	if l > 0 {
		n += 1 + l + sovRmq(uint64(l))
	}
	return n
}

func (m *RmqHelpLevel) Size() (n int) {
	var l int
	_ = l
	if m.HelperUid != 0 {
		n += 1 + sovRmq(uint64(m.HelperUid))
	}
	l = len(m.HelperName)
	if l > 0 {
		n += 1 + l + sovRmq(uint64(l))
	}
	if m.LevelID != 0 {
		n += 1 + sovRmq(uint64(m.LevelID))
	}
	if m.BattleID != 0 {
		n += 1 + sovRmq(uint64(m.BattleID))
	}
	return n
}

func (m *RmqWxInviteFriend) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovRmq(uint64(m.Uid))
	}
	l = len(m.HeadImgUrl)
	if l > 0 {
		n += 1 + l + sovRmq(uint64(l))
	}
	if m.MaxPvpLevel != 0 {
		n += 1 + sovRmq(uint64(m.MaxPvpLevel))
	}
	return n
}

func (m *RmqForbidLogin) Size() (n int) {
	var l int
	_ = l
	if m.IsForbid {
		n += 2
	}
	if m.OverTime != 0 {
		n += 1 + sovRmq(uint64(m.OverTime))
	}
	return n
}

func (m *RmqForbidChat) Size() (n int) {
	var l int
	_ = l
	if m.IsForbid {
		n += 2
	}
	if m.OverTime != 0 {
		n += 1 + sovRmq(uint64(m.OverTime))
	}
	return n
}

func (m *RmqMonitorAccount) Size() (n int) {
	var l int
	_ = l
	if m.IsForbid {
		n += 2
	}
	if m.OverTime != 0 {
		n += 1 + sovRmq(uint64(m.OverTime))
	}
	if m.OpTime != 0 {
		n += 1 + sovRmq(uint64(m.OpTime))
	}
	return n
}

func (m *RmqWxShareBeHelp) Size() (n int) {
	var l int
	_ = l
	if m.ShareType != 0 {
		n += 1 + sovRmq(uint64(m.ShareType))
	}
	if m.ShareTime != 0 {
		n += 1 + sovRmq(uint64(m.ShareTime))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRmq(uint64(l))
	}
	return n
}

func (m *RmqSdkRecharge) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChannelUid)
	if l > 0 {
		n += 1 + l + sovRmq(uint64(l))
	}
	l = len(m.CpOrderID)
	if l > 0 {
		n += 1 + l + sovRmq(uint64(l))
	}
	l = len(m.ChannelOrderID)
	if l > 0 {
		n += 1 + l + sovRmq(uint64(l))
	}
	if m.PaymentAmount != 0 {
		n += 1 + sovRmq(uint64(m.PaymentAmount))
	}
	if m.NeedCheckMoney {
		n += 2
	}
	return n
}

func (m *RmqCampaignMissionDone) Size() (n int) {
	var l int
	_ = l
	if len(m.Cards) > 0 {
		l = 0
		for _, e := range m.Cards {
			l += sovRmq(uint64(e))
		}
		n += 1 + sovRmq(uint64(l)) + l
	}
	return n
}

func (m *RmqCampaignAcceptMission) Size() (n int) {
	var l int
	_ = l
	if len(m.Cards) > 0 {
		l = 0
		for _, e := range m.Cards {
			l += sovRmq(uint64(e))
		}
		n += 1 + sovRmq(uint64(l)) + l
	}
	return n
}

func (m *RmqUnifiedReward) Size() (n int) {
	var l int
	_ = l
	if m.Rank != 0 {
		n += 1 + sovRmq(uint64(m.Rank))
	}
	if m.Contribution != 0 {
		n += 1 + sovRmq(uint64(m.Contribution))
	}
	l = len(m.YourMajestyName)
	if l > 0 {
		n += 1 + l + sovRmq(uint64(l))
	}
	l = len(m.CountryName)
	if l > 0 {
		n += 1 + l + sovRmq(uint64(l))
	}
	return n
}

func (m *RmqCompensateRecharge) Size() (n int) {
	var l int
	_ = l
	l = len(m.CpOrderID)
	if l > 0 {
		n += 1 + l + sovRmq(uint64(l))
	}
	l = len(m.ChannelOrderID)
	if l > 0 {
		n += 1 + l + sovRmq(uint64(l))
	}
	l = len(m.GoodsID)
	if l > 0 {
		n += 1 + l + sovRmq(uint64(l))
	}
	return n
}

func sovRmq(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRmq(x uint64) (n int) {
	return sovRmq(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RmqMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRmq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RmqMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RmqMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (RmqType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRmq
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRmq(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRmq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RmqBattleBegin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRmq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RmqBattleBegin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RmqBattleBegin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BattleID", wireType)
			}
			m.BattleID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BattleID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			m.AppID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BattleType", wireType)
			}
			m.BattleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BattleType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRmq(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRmq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RmqBonus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRmq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RmqBonus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RmqBonus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeRes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRmq
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangeRes = append(m.ChangeRes, &Resource{})
			if err := m.ChangeRes[len(m.ChangeRes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRmq(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRmq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EndFighterData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRmq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EndFighterData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EndFighterData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRobot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRobot = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSurrender", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSurrender = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Camp", wireType)
			}
			m.Camp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Camp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitHandCards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRmq
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitHandCards = append(m.InitHandCards, &SkinGCard{})
			if err := m.InitHandCards[len(m.InitHandCards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFighter1", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFighter1 = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFirstHand", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFirstHand = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mmr", wireType)
			}
			m.Mmr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mmr |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRmq
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UseCards = append(m.UseCards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRmq
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRmq
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRmq
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UseCards = append(m.UseCards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UseCards", wireType)
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Area", wireType)
			}
			m.Area = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Area |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexDiff", wireType)
			}
			m.IndexDiff = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexDiff |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRmq(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRmq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RmqBattleEnd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRmq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RmqBattleEnd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RmqBattleEnd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BattleID", wireType)
			}
			m.BattleID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BattleID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BattleType", wireType)
			}
			m.BattleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BattleType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LevelID", wireType)
			}
			m.LevelID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LevelID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsWonderful", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsWonderful = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Winner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRmq
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Winner == nil {
				m.Winner = &EndFighterData{}
			}
			if err := m.Winner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Loser", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRmq
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Loser == nil {
				m.Loser = &EndFighterData{}
			}
			if err := m.Loser.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRmq(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRmq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RmqAddFriendApply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRmq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RmqAddFriendApply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RmqAddFriendApply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromUid", wireType)
			}
			m.FromUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromUid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRmq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsInvite", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsInvite = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRmq(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRmq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RmqReplyFriendApply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRmq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RmqReplyFriendApply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RmqReplyFriendApply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromUid", wireType)
			}
			m.FromUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromUid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAgree", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsAgree = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRmq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRmq(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRmq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RmqBeDelFriend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRmq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RmqBeDelFriend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RmqBeDelFriend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromUid", wireType)
			}
			m.FromUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromUid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRmq(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRmq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RmqPrivateChat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRmq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RmqPrivateChat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RmqPrivateChat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromUid", wireType)
			}
			m.FromUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromUid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRmq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromHeadImgUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRmq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromHeadImgUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRmq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromPvpLevel", wireType)
			}
			m.FromPvpLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromPvpLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromCountry", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRmq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromCountry = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromHeadFrame", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRmq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromHeadFrame = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatPop", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRmq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChatPop = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromCountryFlag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRmq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromCountryFlag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRmq(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRmq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RmqHelpLevel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRmq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RmqHelpLevel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RmqHelpLevel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HelperUid", wireType)
			}
			m.HelperUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HelperUid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HelperName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRmq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HelperName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LevelID", wireType)
			}
			m.LevelID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LevelID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BattleID", wireType)
			}
			m.BattleID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BattleID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRmq(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRmq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RmqWxInviteFriend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRmq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RmqWxInviteFriend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RmqWxInviteFriend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadImgUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRmq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeadImgUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPvpLevel", wireType)
			}
			m.MaxPvpLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPvpLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRmq(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRmq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RmqForbidLogin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRmq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RmqForbidLogin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RmqForbidLogin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsForbid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsForbid = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverTime", wireType)
			}
			m.OverTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRmq(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRmq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RmqForbidChat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRmq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RmqForbidChat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RmqForbidChat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsForbid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsForbid = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverTime", wireType)
			}
			m.OverTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRmq(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRmq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RmqMonitorAccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRmq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RmqMonitorAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RmqMonitorAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsForbid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsForbid = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverTime", wireType)
			}
			m.OverTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpTime", wireType)
			}
			m.OpTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRmq(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRmq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RmqWxShareBeHelp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRmq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RmqWxShareBeHelp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RmqWxShareBeHelp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShareType", wireType)
			}
			m.ShareType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShareType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShareTime", wireType)
			}
			m.ShareTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShareTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRmq
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRmq(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRmq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RmqSdkRecharge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRmq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RmqSdkRecharge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RmqSdkRecharge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRmq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpOrderID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRmq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpOrderID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelOrderID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRmq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelOrderID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentAmount", wireType)
			}
			m.PaymentAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PaymentAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedCheckMoney", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedCheckMoney = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRmq(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRmq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RmqCampaignMissionDone) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRmq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RmqCampaignMissionDone: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RmqCampaignMissionDone: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRmq
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cards = append(m.Cards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRmq
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRmq
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRmq
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cards = append(m.Cards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRmq(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRmq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RmqCampaignAcceptMission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRmq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RmqCampaignAcceptMission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RmqCampaignAcceptMission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRmq
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Cards = append(m.Cards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRmq
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRmq
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRmq
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Cards = append(m.Cards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRmq(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRmq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RmqUnifiedReward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRmq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RmqUnifiedReward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RmqUnifiedReward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contribution", wireType)
			}
			m.Contribution = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Contribution |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field YourMajestyName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRmq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.YourMajestyName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRmq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CountryName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRmq(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRmq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RmqCompensateRecharge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRmq
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RmqCompensateRecharge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RmqCompensateRecharge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpOrderID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRmq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpOrderID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelOrderID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRmq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelOrderID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GoodsID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRmq
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GoodsID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRmq(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRmq
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRmq(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRmq
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRmq
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRmq
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRmq
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRmq(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRmq = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRmq   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("rmq.proto", fileDescriptorRmq) }

var fileDescriptorRmq = []byte{
	// 1264 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x0e, 0x25, 0xcb, 0x16, 0x57, 0x3f, 0x61, 0x36, 0x89, 0xcb, 0x1a, 0x81, 0x2b, 0x10, 0x45,
	0x21, 0xf8, 0x60, 0xb4, 0x09, 0xd0, 0xbb, 0x2c, 0x45, 0xb6, 0x80, 0x28, 0x31, 0xd6, 0x31, 0x82,
	0x9e, 0x8a, 0x95, 0x38, 0x96, 0x59, 0x8b, 0xbb, 0xd4, 0x92, 0x72, 0xa2, 0x6b, 0x1f, 0xa2, 0x28,
	0xd0, 0xd7, 0xc9, 0xa1, 0xbd, 0xf5, 0x01, 0x7a, 0x28, 0xd2, 0x17, 0x29, 0x66, 0x48, 0x51, 0xa4,
	0xe3, 0xa4, 0x85, 0x6f, 0x3b, 0xdf, 0x2e, 0x77, 0xbe, 0x9d, 0x6f, 0x7e, 0xc8, 0x6c, 0x13, 0x2e,
	0x0e, 0x23, 0xa3, 0x13, 0xcd, 0x2b, 0xd1, 0x64, 0xaf, 0x39, 0xd5, 0x61, 0xa8, 0x55, 0x8a, 0xec,
	0xb1, 0xa9, 0x34, 0x7e, 0xba, 0xf6, 0x8e, 0x19, 0x13, 0xe1, 0x62, 0x0c, 0x71, 0x2c, 0x67, 0xc0,
	0xbf, 0x62, 0x5b, 0xaf, 0x57, 0x11, 0xb8, 0x56, 0xc7, 0xea, 0xb6, 0x9f, 0x36, 0x0e, 0xa3, 0xc9,
	0xa1, 0x08, 0x17, 0x08, 0x09, 0xda, 0xe0, 0x2e, 0xdb, 0x39, 0x95, 0xab, 0xb9, 0x96, 0xbe, 0x5b,
	0xe9, 0x58, 0xdd, 0xa6, 0x58, 0x9b, 0xde, 0x84, 0xb5, 0x45, 0xb8, 0x38, 0x92, 0x49, 0x32, 0x87,
	0x23, 0x98, 0x05, 0x8a, 0xef, 0xb1, 0x7a, 0x6a, 0x8e, 0x06, 0x74, 0xe1, 0x96, 0xc8, 0x6d, 0xfe,
	0x88, 0xd5, 0x7a, 0x51, 0x34, 0x1a, 0xd0, 0x2d, 0x2d, 0x91, 0x1a, 0x7c, 0x9f, 0xb1, 0xf4, 0x04,
	0x91, 0xa8, 0x76, 0xac, 0x6e, 0x4d, 0x14, 0x10, 0xef, 0x7b, 0x56, 0x47, 0x1f, 0x5a, 0x2d, 0x63,
	0x7e, 0xc0, 0xec, 0xfe, 0xa5, 0x54, 0x33, 0x10, 0x10, 0xbb, 0x56, 0xa7, 0xda, 0x6d, 0x3c, 0x6d,
	0x12, 0x5f, 0x88, 0xf5, 0xd2, 0x4c, 0x41, 0x6c, 0xb6, 0xbd, 0x3f, 0x2a, 0xac, 0xfd, 0x5c, 0xf9,
	0xc3, 0x60, 0x76, 0x99, 0x80, 0x19, 0xc8, 0x44, 0x72, 0x87, 0x55, 0xcf, 0x03, 0x3f, 0xe3, 0x85,
	0x4b, 0x7c, 0xda, 0x28, 0x16, 0x7a, 0xa2, 0x13, 0x22, 0x55, 0x17, 0x6b, 0x93, 0x77, 0x58, 0x63,
	0x14, 0x9f, 0x2d, 0x8d, 0x01, 0xe5, 0x83, 0x21, 0x5e, 0x75, 0x51, 0x84, 0x38, 0x67, 0x5b, 0x7d,
	0x19, 0x46, 0xee, 0x16, 0x51, 0xa6, 0x35, 0x7f, 0xc6, 0x5a, 0x23, 0x15, 0x24, 0x27, 0x52, 0xf9,
	0x7d, 0x69, 0xfc, 0xd8, 0xad, 0x11, 0xc9, 0x16, 0x92, 0x3c, 0xbb, 0x0a, 0xd4, 0x31, 0xa2, 0xa2,
	0x7c, 0x06, 0x23, 0x30, 0x8a, 0x33, 0x9e, 0xdf, 0xb9, 0xdb, 0xe4, 0xa9, 0x80, 0xa4, 0x54, 0x86,
	0x81, 0x89, 0xe9, 0x1b, 0x77, 0x67, 0x4d, 0x25, 0x87, 0xf0, 0x61, 0xe3, 0xd0, 0xb8, 0x75, 0x62,
	0x82, 0x4b, 0xd4, 0xe1, 0x3c, 0x86, 0x94, 0x83, 0xdd, 0xa9, 0x76, 0x5b, 0x22, 0xb7, 0x91, 0x78,
	0xcf, 0x80, 0x74, 0x59, 0x4a, 0x1c, 0xd7, 0xfc, 0x09, 0xb3, 0x47, 0xca, 0x87, 0x77, 0x83, 0xe0,
	0xe2, 0xc2, 0x6d, 0xd0, 0xc6, 0x06, 0xf0, 0xfe, 0xb2, 0x58, 0x33, 0x17, 0xfa, 0xb9, 0xf2, 0x3f,
	0x2b, 0x73, 0x59, 0xd0, 0xca, 0x4d, 0x41, 0x31, 0xe6, 0x2f, 0xe0, 0x1a, 0xe6, 0xa3, 0x41, 0xa6,
	0xf6, 0xda, 0x4c, 0x1f, 0xfa, 0x46, 0x63, 0x74, 0x2f, 0x96, 0x73, 0x0a, 0x2c, 0x3d, 0x34, 0x87,
	0xf8, 0x01, 0xdb, 0x7e, 0x13, 0x28, 0x05, 0xc6, 0xad, 0x75, 0xac, 0x6e, 0xe3, 0x29, 0xc7, 0xc0,
	0x96, 0x55, 0x16, 0xd9, 0x09, 0xde, 0x65, 0xb5, 0x17, 0x3a, 0x06, 0x43, 0x11, 0xbd, 0xfd, 0x68,
	0x7a, 0xc0, 0x03, 0xf6, 0x40, 0x84, 0x8b, 0x9e, 0xef, 0x0f, 0x4d, 0x00, 0xca, 0xef, 0x45, 0xd1,
	0x7c, 0x85, 0x34, 0x87, 0x46, 0x87, 0x9b, 0x84, 0x59, 0x9b, 0xf8, 0x78, 0x5c, 0xbe, 0x94, 0x61,
	0xfa, 0x3c, 0x5b, 0xe4, 0x36, 0xee, 0x8d, 0xe2, 0x91, 0xba, 0x0e, 0x12, 0xc8, 0x72, 0x26, 0xb7,
	0x3d, 0x60, 0x0f, 0x45, 0xb8, 0x10, 0x10, 0xcd, 0x57, 0xff, 0xcf, 0x11, 0x65, 0x67, 0x6f, 0x66,
	0x00, 0x36, 0xd9, 0x49, 0x66, 0x89, 0x42, 0xb5, 0x4c, 0xc1, 0x3b, 0x48, 0x8b, 0x12, 0x06, 0x30,
	0x4f, 0xdd, 0x7c, 0xda, 0x83, 0xf7, 0xbe, 0x42, 0x87, 0x4f, 0x4d, 0x70, 0x2d, 0x13, 0xe8, 0x5f,
	0xca, 0xe4, 0x8e, 0xef, 0xfe, 0x86, 0xb5, 0x71, 0x7d, 0x02, 0xd2, 0x1f, 0x85, 0xb3, 0x73, 0x33,
	0xcf, 0x68, 0xdd, 0x40, 0x29, 0x53, 0xe3, 0x19, 0x49, 0x6b, 0x0b, 0x5c, 0x62, 0x36, 0xbe, 0x0e,
	0x42, 0x20, 0x41, 0x6b, 0x82, 0xd6, 0xdc, 0x63, 0x4d, 0xfc, 0xee, 0xf4, 0x3a, 0xa2, 0xd4, 0x20,
	0x05, 0x6b, 0xa2, 0x84, 0x61, 0xb2, 0xa0, 0xdd, 0xd7, 0x4b, 0x95, 0x98, 0x15, 0x55, 0x85, 0x2d,
	0x8a, 0x10, 0xff, 0x9a, 0xb5, 0xd6, 0xde, 0x87, 0x06, 0x49, 0xd7, 0xe9, 0x4c, 0x19, 0xc4, 0xf7,
	0xe2, 0xbb, 0x4f, 0x75, 0xe4, 0xda, 0xb4, 0xbf, 0x36, 0x79, 0x97, 0xdd, 0x2f, 0x5c, 0x37, 0x9c,
	0xcb, 0x19, 0x95, 0x8c, 0x2d, 0x6e, 0xc2, 0xde, 0xcf, 0x69, 0x7d, 0x9c, 0xc0, 0x3c, 0x23, 0xf7,
	0x84, 0xd9, 0x68, 0x80, 0xd9, 0x84, 0x71, 0x03, 0x60, 0x85, 0xa4, 0x46, 0x21, 0x94, 0x05, 0xe4,
	0x33, 0x15, 0x52, 0xac, 0xbb, 0xad, 0x72, 0xdd, 0x79, 0x33, 0xca, 0xe2, 0x37, 0xef, 0xd2, 0x6c,
	0xcb, 0xa4, 0xff, 0xb8, 0xe5, 0x91, 0xf3, 0x5c, 0xa5, 0xdc, 0x79, 0xae, 0x50, 0x87, 0x35, 0xc6,
	0xf2, 0x5d, 0x1e, 0xfa, 0x94, 0x40, 0x11, 0xf2, 0x4e, 0x28, 0x67, 0x86, 0xda, 0x4c, 0x02, 0xff,
	0x85, 0xce, 0xba, 0xfe, 0x28, 0x4e, 0x01, 0x72, 0x45, 0x59, 0x9f, 0xda, 0xb8, 0xf7, 0xea, 0x1a,
	0x0c, 0x69, 0x8c, 0xde, 0xaa, 0x22, 0xb7, 0xbd, 0x63, 0xd6, 0xca, 0x6f, 0xa2, 0xe4, 0xbb, 0xeb,
	0x45, 0x53, 0x7a, 0xfb, 0x58, 0xab, 0x20, 0xd1, 0xa6, 0x37, 0x9d, 0xa2, 0x36, 0x77, 0xbd, 0x8c,
	0xef, 0xb2, 0xed, 0x57, 0x11, 0xed, 0x54, 0x69, 0x27, 0xb3, 0xbc, 0x09, 0x73, 0x28, 0xc0, 0x67,
	0x97, 0xd2, 0xc0, 0x11, 0xa0, 0x60, 0x28, 0x34, 0x99, 0xf9, 0x04, 0xad, 0x89, 0x0d, 0xb0, 0xd9,
	0xdd, 0xb8, 0xd9, 0x00, 0x98, 0xf9, 0xd8, 0x85, 0xc8, 0x4b, 0x53, 0xd0, 0xda, 0x7b, 0x6f, 0x51,
	0x70, 0xcf, 0xfc, 0x2b, 0x01, 0xd3, 0x4b, 0x69, 0x66, 0x80, 0x82, 0xe1, 0x54, 0x53, 0x30, 0x5f,
	0x2b, 0x69, 0x8b, 0x02, 0x82, 0x4e, 0xfa, 0xd1, 0x2b, 0xe3, 0x83, 0xc9, 0x46, 0xab, 0x2d, 0x36,
	0x00, 0x16, 0x66, 0x76, 0x76, 0x7d, 0x24, 0x2b, 0xcc, 0x32, 0x8a, 0xc5, 0x72, 0x2a, 0x57, 0x21,
	0xa8, 0xa4, 0x17, 0x62, 0xf4, 0xb2, 0xb1, 0x56, 0x06, 0xf1, 0xb6, 0x97, 0x00, 0x7e, 0xff, 0x12,
	0xa6, 0x57, 0x63, 0xad, 0x60, 0x45, 0x65, 0x5b, 0x17, 0x37, 0x50, 0xef, 0x90, 0xed, 0x8a, 0x70,
	0x81, 0x23, 0x51, 0x06, 0x33, 0x35, 0x0e, 0xe2, 0x38, 0xd0, 0x6a, 0xa0, 0x15, 0xe0, 0x4f, 0x40,
	0x3a, 0x95, 0x2c, 0x9a, 0x4a, 0xa9, 0xe1, 0x7d, 0xcb, 0xdc, 0xc2, 0xf9, 0xde, 0x74, 0x0a, 0x51,
	0x92, 0x7d, 0xf5, 0x89, 0x2f, 0x7e, 0xb1, 0x48, 0x8d, 0x73, 0x15, 0x5c, 0x04, 0xe0, 0x0b, 0x78,
	0x2b, 0x8d, 0x8f, 0x11, 0x15, 0x52, 0x5d, 0x65, 0x42, 0xd0, 0x1a, 0x7b, 0x49, 0x5f, 0xab, 0xc4,
	0x04, 0x93, 0x65, 0x12, 0x68, 0x95, 0x0d, 0xa4, 0x12, 0x86, 0x95, 0xfe, 0x83, 0x5e, 0x9a, 0xb1,
	0xfc, 0x09, 0xe2, 0x64, 0x55, 0xe8, 0xaa, 0x37, 0x61, 0xac, 0x8e, 0xac, 0xf0, 0xe9, 0x54, 0xda,
	0xc7, 0x8a, 0x90, 0xf7, 0x96, 0x3d, 0xc6, 0xa7, 0xe8, 0x30, 0x02, 0x15, 0xcb, 0x04, 0x72, 0x1d,
	0x4b, 0x3a, 0x59, 0xff, 0xad, 0x53, 0xe5, 0x56, 0x9d, 0x5c, 0xb6, 0x73, 0xac, 0xb5, 0x1f, 0xe7,
	0x42, 0xae, 0xcd, 0x83, 0xdf, 0xaa, 0x6c, 0x27, 0xfb, 0x71, 0xe3, 0x9c, 0xb5, 0xcf, 0xd5, 0x95,
	0xd2, 0x6f, 0x7f, 0xcc, 0x10, 0xe7, 0x1e, 0xbf, 0xcf, 0x1a, 0x85, 0x3f, 0x35, 0xc7, 0xe2, 0x2d,
	0x66, 0xe7, 0x13, 0xdd, 0xa9, 0x70, 0x9b, 0xd5, 0xe8, 0x2f, 0xcb, 0xa9, 0xe2, 0xe7, 0xe5, 0x69,
	0xe8, 0x6c, 0xf1, 0x47, 0xcc, 0xb9, 0x39, 0xba, 0x9c, 0x1a, 0x5d, 0xba, 0x99, 0x34, 0xce, 0x36,
	0x02, 0x85, 0x69, 0xe2, 0xec, 0xa0, 0x97, 0xbc, 0x2f, 0x3a, 0x75, 0xbc, 0xa6, 0xdc, 0xa2, 0x5e,
	0x47, 0x8e, 0x8d, 0x5f, 0x15, 0xfa, 0x89, 0xc3, 0x78, 0x9b, 0xb1, 0x4d, 0x5b, 0x70, 0x1a, 0xbc,
	0xc9, 0xea, 0x67, 0xa0, 0xfc, 0xb1, 0x0c, 0xe6, 0x4e, 0x93, 0x3f, 0x60, 0xad, 0x52, 0x19, 0x3a,
	0x2d, 0xbc, 0xa1, 0x50, 0x34, 0x4e, 0x9b, 0x7f, 0xc1, 0x1e, 0xde, 0x92, 0x7f, 0xce, 0x7d, 0xfe,
	0x25, 0x7b, 0x7c, 0x6b, 0xa2, 0x39, 0x0e, 0xde, 0x5b, 0x4a, 0x28, 0xe7, 0x01, 0xdf, 0x63, 0xbb,
	0x02, 0x92, 0xa5, 0x51, 0x03, 0x19, 0xcc, 0x57, 0xe4, 0x33, 0xdb, 0xe3, 0x18, 0xa6, 0x72, 0xcb,
	0x71, 0x1e, 0xf2, 0x5d, 0xc6, 0x3f, 0xd6, 0xde, 0x79, 0x74, 0xe4, 0xfc, 0xfe, 0x61, 0xdf, 0xfa,
	0xf3, 0xc3, 0xbe, 0xf5, 0xf7, 0x87, 0x7d, 0xeb, 0xd7, 0x7f, 0xf6, 0xef, 0x4d, 0xb6, 0xe9, 0x67,
	0xfc, 0xd9, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff, 0x59, 0xf4, 0x0e, 0xc0, 0xb7, 0x0b, 0x00, 0x00,
}
