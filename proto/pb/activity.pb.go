// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: activity.proto

/*
	Package pb is a generated protocol buffer package.

	It is generated from these files:
		activity.proto
		advertisement.proto
		battle.proto
		campaign.proto
		card.proto
		command.proto
		common.proto
		equip.proto
		gm.proto
		hint.proto
		huodong.proto
		level.proto
		mail.proto
		mission.proto
		msgid.proto
		outstatus.proto
		player.proto
		pvp.proto
		rank.proto
		reborn.proto
		rewardlist.proto
		rmq.proto
		shop.proto
		social.proto
		survey.proto
		televise.proto
		treasure.proto
		tutorial.proto
		video.proto
		wxgame.proto

	It has these top-level messages:
		ActivityLabelList
		Activity
		ActivityList
		ActivityData
		TargetActivity
		ActivityID
		Reward
		ActivityFinshChange
		ActivityReceiveChange
		ActivityStatusChange
		TreasureReadAdsArg
		TreasureReadAdsReply
		DailyTreasureReadAdsArg
		WatchUpTreasureRareAdsArg
		WatchTreasureAddCardAdsArg
		BattleLoseReadAdsReply
		ShopFreeAds
		WatchShopFreeAdsArg
		WatchShopFreeAdsReply
		WatchTreasureAddCardAdsReply
		SendEmojiArg
		MovieEffect
		DiyFightCardInfo
		Card
		BattleEquip
		Fighter
		Grid
		FightDesk
		SeasonBattle
		SeasonRandomHand
		SeasonBanHand
		SeasonSwitchHand
		SeasonBattleReady
		SeasonBattleBegin
		FightBoutBegin
		FightBoutCmd
		FightBoutResult
		ChangeCardInfo
		ChangeResInfo
		BattleResult
		LoadFightReq
		RestoredFightDesk
		VideoBattleData
		VideoAction
		InGridCard
		FighterData
		BeginBattleArg
		BeginLevelBattleArg
		LoadBattleArg
		C2SLoadFightArg
		CancelBattleArg
		LogBattleArg
		OnRobotBattleEndArg
		ClientAction
		AttackAct
		AttackWinAct
		MoveAct
		TurnOverAct
		SkillAct
		ModifyValueActItem
		ModifyValueAct
		SkillStatusMovieAct
		MovieAct
		TextMovieAct
		DrawCardItem
		DrawCardAct
		HandShowAct
		GuanxingAct
		ModifySkillAct
		DisCardActItem
		DisCardAct
		DestroyAct
		SummonAct
		ReturnAct
		SwitchPosAct
		BonusReward
		BonusAct
		CopyAct
		EnterFogAct
		LeaveFogAct
		GoldGobAct
		SwitchHandCardItem
		SwitchHandCardAct
		DelEquipAct
		CampaignState
		CaStateWarArg
		CaStateUnifiedArg
		CaStateWarEndArg
		UpdateCityStateArg
		CampaignPlayerState
		CpStateKickOutArg
		CpStateLoadingArg
		CpStateBeCaptiveArg
		CitySimpleData
		TeamData
		UpdateMyTeamStateArg
		MyTeamDisappear
		TeamRetreat
		MilitaryOrder
		PublishMilitaryOrderArg
		PublishMilitaryOrderReply
		CancelMilitaryOrderReply
		MilitaryOrderInfo
		TargetMilitaryOrder
		AcceptMilitaryOrderArg
		AcceptMilitaryOrderReply
		CountrySimpleData
		CampaignInfo
		CreateCountryArg
		TargetCity
		CountryCreatedArg
		CampaignPlayer
		CampaignPlayerList
		CityData
		FetchApplyCreateCountryPlayersArg
		ApplyCreateCountryPlayer
		ApplyCreateCountryPlayers
		ApplyCreateCountryData
		UpdateForageArg
		CampaignMission
		ExecutingCampaignMission
		CampaignMissionInfo
		CampaignPublishMissionArg
		CampaignPublishMissionReply
		AcceptCampaignMissionArg
		AcceptCampaignMissionReply
		FetchCityPlayersArg
		SetForagePriceArg
		FetchForagePriceReply
		NewCountryNtArg
		AppointJobNtArg
		RecallJobNtArg
		AutocephalyNtArg
		KickOutNtArg
		YourMajestyChangeNtArg
		ResignNtArg
		BeOccupyNtArg
		DestoryCountryNtArg
		UnifiedWordNtArg
		AutocephalyVoteNtArg
		CapitalInjectionNtArg
		ProductionNtArg
		SalaryNtArg
		TransportNtArg
		OccupyNtArg
		SurrenderNtArg
		BetrayNtArg
		EscapedNtArg
		EscapedReturnNtArg
		SurrenderCity1NtArg
		SurrenderCity2NtArg
		SurrenderCountry1NtArg
		AutocephalyNt2Arg
		AutocephalyNt3Arg
		CampaignNotice
		CampaignNoticeInfo
		CityPlayerAmount
		AllCityPlayerAmount
		FetchCountryPlayersArg
		CampaignNotifyRedDotArg
		AppointJobArg
		RecallJobArg
		CityDefense
		SyncCityDefenseArg
		CampaignUpdateJobArg
		PatrolCityReply
		CityCapitalInjectionArg
		CityCapitalInjectionReply
		UpdateMyCityArg
		CampaignTargetPlayer
		UpdateMyCountryArg
		AutocephalyInfo
		AutocephalyArg
		VoteAutocephalyArg
		AccDefCityLoseLoadingReply
		CountryModifyNameArg
		CountryModifyFlagArg
		UpdateCountryNameArg
		UpdateCountryFlagArg
		CancelPublishMissionArg
		CancelPublishMissionReply
		CampaignTeams
		CountryDestoryed
		CapitalInjectionRecord
		CityCapitalInjectionHistory
		UpdateContributionArg
		CityNotice
		FetchCityCapitalInjectionArg
		CampaignSimplePlayer
		SyncCityPlayerAmount
		CampaignSupportCard
		SurrenderCityArg
		UpdateCityCountryArg
		CitysDefPlayerAmount
		CampaignBuyGoodsArg
		ContributionReply
		GSettleCityArg
		GCancelCampaignMissionReply
		GGetCampaignMissionRewardReply
		GetMyCountryReply
		MoveCityArg
		MoveCityRelpy
		CampaignBattleEnd
		GCampaignPlayerInfo
		GCampaignInfo
		ModifyContributionArg
		GAcceptCampaignMissionReply
		CardPool
		CardInfo
		CardPools
		CardDatas
		PoolAddCard
		PoolUpdateCard
		FightPool
		UpdateCardPools
		TargetCard
		DiyCardArg
		DiyCardReply
		DiyCardData
		DiyCardImg
		AddCardSkinArg
		SkinGCard
		SkinCard
		UpLevelCardArg
		UnlockCardLevelArg
		BackCardUnlockArg
		BackCardUnlockReply
		GmCommand
		ExchangeCodeArg
		ExchangeCodeReward
		Resource
		DailyTreasureShareInfo
		TargetArea
		ServerStatus
		Equip
		EquipData
		TargetEquip
		EquipBackInfo
		ReturnResData
		AreaAccountTypeOnlineInfo
		OnlineInfo
		GetCardAmountLogArg
		CardAmountLog
		CardsAmountLog
		GetCardAmountLogReply
		GetCardLevelLogArg
		CardLevelLog
		CardsLevelLog
		GetCardLevelLogReply
		GetCardPoolLogArg
		CardPoolLog
		CardPoolsLog
		GetCardPoolLogReply
		GmLoginNotice
		Hint
		HuodongData
		TargetHuodong
		HuodongDetail
		SpringExchangeData
		SpringHuodong
		SpringSkinHuodong
		HuodongExchangeArg
		HuodongExchangeReply
		GetSpringSkinArg
		HuodongEvent
		LevelInfo
		LevelHelpRecordItem
		LevelHelpRecord
		OpenLevelTreasureArg
		BeginLevelBattle
		LevelFightResult
		LevelChooseCard
		LevelBattle
		ChapterUnlock
		LevelHelpArg
		LevelBeHelpArg
		TargetLevel
		WatchHelpVideoArg
		FetchLevelVideoIDArg
		FetchLevelVideoIDRely
		FetchMailListArg
		MailReward
		MailSeasonPvpBeginArg
		MailSeasonPvpEndArg
		MailRankHonorRewardArg
		MailCampaignUnifiedArg
		Mail
		MailList
		GetMailRewardArg
		ReadMailArg
		MailRewardCard
		MailRewardAmountArg
		MailRewardItemArg
		MailRewardReply
		WholeServerMail
		ReimburseBackMailPrivID
		LeagueSeasonEndArg
		Mission
		MissionTreasure
		MissionInfo
		TargetMission
		MissionReward
		OpenMissionTreasureReply
		UpdateMissionProcessArg
		OutStatus
		TargetOutStatus
		KickOut
		FinishGuide
		AllFinishGuide
		GuideGroup
		LoginArg
		LoginReply
		AccountLoginArg
		Archive
		GateHost
		AccountArchives
		RegisterAccount
		DelArchiveArg
		ResourceModify
		ModifyNameArg
		UpdateNameArg
		Version
		LoadPlayerArg
		SimplePlayerInfo
		SdkUserInfo
		UpdateHeadImgArg
		TouristRegisterAccountArg
		TouristRegisterAccountRelpy
		TouristBindAccountArg
		FetchHeadFrameReply
		UpdateHeadFrameArg
		HeadData
		EmojiData
		TellMe
		UnlockEmojiArg
		VipRemainTime
		MinVipRemainTime
		AccountCode
		AccountCodePlayerInfo
		FetchChatPopReply
		UpdateChatPopArg
		AdultCertificationArg
		UpdateSimplePlayerArg
		OnBindAccountArg
		LoginNoticeData
		LoginNotice
		OnLoginNoticeShowArg
		UpdateNationalFlagArg
		UpdateCountryFlagRemainTime
		Pong
		MatchPlayer
		MatchArg
		MatchReply
		MatchInfo
		MatchDoneArg
		BeginMatchArg
		BeginNewbiePvpMatchArg
		SeasonPvpLimitTime
		SeasonPvpInfo
		SeasonPvpChooseCampArg
		SeasonPvpChooseCardData
		SeasonPvpChooseCardArg
		SeasonPvpChooseCardReply
		FetchSeasonHandCardReply
		GetFighterDataArg
		LeagueRewardInfo
		LeagueRewardId
		LeagueRewards
		ReloadLeagueAttrArg
		GLeagueSeasonEndArg
		FetchRankArg
		RankItem
		RankInfo
		FetchRankUserArg
		RankUser
		UpdatePvpScoreArg
		G2RSeasonPvpEndReply
		GFetchRankUserArg
		GFetchRankArg
		RankHonorInfo
		UserRankingInfo
		Area2UserRanking
		MaxRankArg
		RefineCardArg
		RefineCardReply
		RebornReply
		BuyRebornGoodsArg
		RebornData
		RewardList
		RmqMessage
		RmqBattleBegin
		RmqBonus
		EndFighterData
		RmqBattleEnd
		RmqAddFriendApply
		RmqReplyFriendApply
		RmqBeDelFriend
		RmqPrivateChat
		RmqHelpLevel
		RmqWxInviteFriend
		RmqForbidLogin
		RmqForbidChat
		RmqMonitorAccount
		RmqWxShareBeHelp
		RmqSdkRecharge
		RmqCampaignMissionDone
		RmqCampaignAcceptMission
		RmqUnifiedReward
		RmqCompensateRecharge
		UpdateLimitGiftArg
		UpdateJadeGoodsArg
		UpdateGoldGoodsArg
		UpdateFreeAdsArg
		UpdateShopDataArg
		LimitGift
		JadeGoods
		SoldTreasure
		SoldTreasureData
		RandomShop
		RecruitTreasureData
		VisitRandomShopData
		GoldGoods
		SoldGoldGift
		SoldRecommendGift
		ShopData
		VipCardGoods
		BuyRandomShopArg
		BuyJadeArg
		BuyJadeReply
		BuyLimitGiftArg
		GiftPrivilegeReward
		BuyLimitGiftReply
		BuySoldTreasureArg
		BuySoldTreasureReply
		BuyGoldArg
		BuyGoldReply
		SdkCreateOrderArg
		SdkCreateOrderReply
		RechargeLotteryReply
		SdkRechargeResult
		IosPrePayArg
		BuyLimitGiftByJadeArg
		GooglePlayRechargeArg
		BuyVipCardReply
		PieceExchangeArg
		TargetLimitGift
		IosRechargeArg
		BuyRecruitTreasureArg
		BuyRecruitTreasureReply
		BuyRandomShopRefreshCntArg
		BuyRandomShopRefreshCntReply
		PieceExchangeIds
		BuySoldGoldGiftReply
		MidasRechargeArg
		BuyRecommendGiftReply
		TargetPlayer
		PlayerInfo
		FriendItem
		FriendList
		FriendApply
		FriendApplyList
		ReplyFriendApplyArg
		FriendApplyNotifyArg
		FriendApplyResult
		PrivateChatMsg
		PrivateChatItem
		PrivateChatList
		FetchPrivateChatArg
		SendPrivateChatArg
		TargetChatChannel
		ChatItem
		Chatlet
		ChatList
		ChatItemList
		ChatNotify
		SendChatArg
		BeInviteBattleArg
		ReplyInviteBattleArg
		InviteBattleResult
		CSendChatArg
		G2GReplyInviteBattleArg
		WxInviteFriend
		WxInviteReward
		WxInviteFriendsReply
		GetWxInviteRewardArg
		GetWxInviteRewardReply
		SubscribeChatArg
		ForbidChatArg
		OnSendAdvertChatArg
		IpAddrArg
		ImportWordArg
		SurveyInfo
		Answer
		SurveyAnswer
		Televise
		TeleviseCardArg
		TeleviseUidArg
		TeleviseRankLoginArg
		Treasure
		DailyTreasure
		GetTreasuresArg
		GetTreasuresReply
		OpenTreasureArg
		OpenTreasureReply
		GainTreasure
		ActivateRewardTreasureArg
		ActivateRewardTreasureReply
		TargetTreasure
		GetCampIDArg
		GetCampIDReply
		SetCampIDArg
		SetCampIDReply
		StartTutorialBattleArg
		StartTutorialBattleReply
		TutorialFightEnd
		GuideBattle
		VideoFighter
		VideoItem
		VideoList
		WatchVideoArg
		WatchVideoResp
		FetchSelfVideoListArg
		LikeVideoArg
		LikeVideoResp
		ShareVideoArg
		VideoFighterData
		SaveVideoArg
		FetchVideoCommentsArg
		VideoComments
		FetchVideoCommentsReply
		LikeVideoCommentsArg
		LikeVideoCommentsReply
		CommentsVideoArg
		CommentsVideoReply
		GCommentsVideoArg
		FetchVideoItemArg
		GShareVideoArg
		ReplyWxInviteBattleArg
		WxInviteBattleResult
		GetShareTreasureArg
		ShareTreasureArg
		HelpShareTreasureArg
		TreasureBeHelp
		BattleLoseBeHelp
		ShareBattleLoseArg
		WxExamineState
		HelpShareBattleLoseArg
		WxgameShareArg
		ClickWxgameShareArg
		WxDailyShareArg
		CancelWxShareArg
		WxShareBeHelpArg
		DailyShareReward
		WxDailyShareReply
		DailyShareInfo
		DailyShareReturnReward
		G2GReplyWxInviteBattleArg
		GWxDailyShare
		GWxDailyTreasureShare
*/
package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// 奖励领取状态枚举
type ActivityReceiveStatus int32

const (
	ActivityReceiveStatus_ReceiveUnknow ActivityReceiveStatus = 0
	ActivityReceiveStatus_CanReceive    ActivityReceiveStatus = 1
	ActivityReceiveStatus_HasReceive    ActivityReceiveStatus = 2
	ActivityReceiveStatus_CanNotReceive ActivityReceiveStatus = 3
	ActivityReceiveStatus_NeedRecharge  ActivityReceiveStatus = 4
)

var ActivityReceiveStatus_name = map[int32]string{
	0: "ReceiveUnknow",
	1: "CanReceive",
	2: "HasReceive",
	3: "CanNotReceive",
	4: "NeedRecharge",
}
var ActivityReceiveStatus_value = map[string]int32{
	"ReceiveUnknow": 0,
	"CanReceive":    1,
	"HasReceive":    2,
	"CanNotReceive": 3,
	"NeedRecharge":  4,
}

func (x ActivityReceiveStatus) String() string {
	return proto.EnumName(ActivityReceiveStatus_name, int32(x))
}
func (ActivityReceiveStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorActivity, []int{0}
}

// 可显示的活动ID列表
type ActivityLabelList struct {
	IDList []int32 `protobuf:"varint,1,rep,packed,name=IDList" json:"IDList,omitempty"`
}

func (m *ActivityLabelList) Reset()                    { *m = ActivityLabelList{} }
func (m *ActivityLabelList) String() string            { return proto.CompactTextString(m) }
func (*ActivityLabelList) ProtoMessage()               {}
func (*ActivityLabelList) Descriptor() ([]byte, []int) { return fileDescriptorActivity, []int{0} }

func (m *ActivityLabelList) GetIDList() []int32 {
	if m != nil {
		return m.IDList
	}
	return nil
}

// 一个活动的单个奖励数据
type Activity struct {
	RewardID        int32                 `protobuf:"varint,1,opt,name=RewardID,proto3" json:"RewardID,omitempty"`
	ReceiveStatus   ActivityReceiveStatus `protobuf:"varint,2,opt,name=ReceiveStatus,proto3,enum=pb.ActivityReceiveStatus" json:"ReceiveStatus,omitempty"`
	RewardCondition string                `protobuf:"bytes,3,opt,name=RewardCondition,proto3" json:"RewardCondition,omitempty"`
	FinshNum        int32                 `protobuf:"varint,4,opt,name=FinshNum,proto3" json:"FinshNum,omitempty"`
	RewardList      map[string]int32      `protobuf:"bytes,5,rep,name=RewardList" json:"RewardList,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *Activity) Reset()                    { *m = Activity{} }
func (m *Activity) String() string            { return proto.CompactTextString(m) }
func (*Activity) ProtoMessage()               {}
func (*Activity) Descriptor() ([]byte, []int) { return fileDescriptorActivity, []int{1} }

func (m *Activity) GetRewardID() int32 {
	if m != nil {
		return m.RewardID
	}
	return 0
}

func (m *Activity) GetReceiveStatus() ActivityReceiveStatus {
	if m != nil {
		return m.ReceiveStatus
	}
	return ActivityReceiveStatus_ReceiveUnknow
}

func (m *Activity) GetRewardCondition() string {
	if m != nil {
		return m.RewardCondition
	}
	return ""
}

func (m *Activity) GetFinshNum() int32 {
	if m != nil {
		return m.FinshNum
	}
	return 0
}

func (m *Activity) GetRewardList() map[string]int32 {
	if m != nil {
		return m.RewardList
	}
	return nil
}

type ActivityList struct {
	Activitys []*Activity `protobuf:"bytes,1,rep,name=Activitys" json:"Activitys,omitempty"`
}

func (m *ActivityList) Reset()                    { *m = ActivityList{} }
func (m *ActivityList) String() string            { return proto.CompactTextString(m) }
func (*ActivityList) ProtoMessage()               {}
func (*ActivityList) Descriptor() ([]byte, []int) { return fileDescriptorActivity, []int{2} }

func (m *ActivityList) GetActivitys() []*Activity {
	if m != nil {
		return m.Activitys
	}
	return nil
}

// 返回的活动数据
// 根据 ActivityData.ID 读表，找出 ActivityType
// switch ActivityType {
// case 13:  烟花兑换
//   Data = Huodong.proto/SpringHuodong
// default:
//   Data = ActivityList
// }
type ActivityData struct {
	ID   int32  `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Data []byte `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *ActivityData) Reset()                    { *m = ActivityData{} }
func (m *ActivityData) String() string            { return proto.CompactTextString(m) }
func (*ActivityData) ProtoMessage()               {}
func (*ActivityData) Descriptor() ([]byte, []int) { return fileDescriptorActivity, []int{3} }

func (m *ActivityData) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ActivityData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// 领取奖励的活动id
type TargetActivity struct {
	ID       int32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	RewardID int32 `protobuf:"varint,2,opt,name=RewardID,proto3" json:"RewardID,omitempty"`
}

func (m *TargetActivity) Reset()                    { *m = TargetActivity{} }
func (m *TargetActivity) String() string            { return proto.CompactTextString(m) }
func (*TargetActivity) ProtoMessage()               {}
func (*TargetActivity) Descriptor() ([]byte, []int) { return fileDescriptorActivity, []int{4} }

func (m *TargetActivity) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *TargetActivity) GetRewardID() int32 {
	if m != nil {
		return m.RewardID
	}
	return 0
}

// 拉取活动的活动ID
type ActivityID struct {
	ActivityID int32 `protobuf:"varint,1,opt,name=ActivityID,proto3" json:"ActivityID,omitempty"`
}

func (m *ActivityID) Reset()                    { *m = ActivityID{} }
func (m *ActivityID) String() string            { return proto.CompactTextString(m) }
func (*ActivityID) ProtoMessage()               {}
func (*ActivityID) Descriptor() ([]byte, []int) { return fileDescriptorActivity, []int{5} }

func (m *ActivityID) GetActivityID() int32 {
	if m != nil {
		return m.ActivityID
	}
	return 0
}

type Reward struct {
	RewardList     map[string]int32     `protobuf:"bytes,1,rep,name=RewardList" json:"RewardList,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	TreasureReward []*OpenTreasureReply `protobuf:"bytes,2,rep,name=TreasureReward" json:"TreasureReward,omitempty"`
}

func (m *Reward) Reset()                    { *m = Reward{} }
func (m *Reward) String() string            { return proto.CompactTextString(m) }
func (*Reward) ProtoMessage()               {}
func (*Reward) Descriptor() ([]byte, []int) { return fileDescriptorActivity, []int{6} }

func (m *Reward) GetRewardList() map[string]int32 {
	if m != nil {
		return m.RewardList
	}
	return nil
}

func (m *Reward) GetTreasureReward() []*OpenTreasureReply {
	if m != nil {
		return m.TreasureReward
	}
	return nil
}

type ActivityFinshChange struct {
	ActivityID int32 `protobuf:"varint,1,opt,name=ActivityID,proto3" json:"ActivityID,omitempty"`
	FinshNum   int32 `protobuf:"varint,2,opt,name=FinshNum,proto3" json:"FinshNum,omitempty"`
	RewardID   int32 `protobuf:"varint,3,opt,name=RewardID,proto3" json:"RewardID,omitempty"`
}

func (m *ActivityFinshChange) Reset()                    { *m = ActivityFinshChange{} }
func (m *ActivityFinshChange) String() string            { return proto.CompactTextString(m) }
func (*ActivityFinshChange) ProtoMessage()               {}
func (*ActivityFinshChange) Descriptor() ([]byte, []int) { return fileDescriptorActivity, []int{7} }

func (m *ActivityFinshChange) GetActivityID() int32 {
	if m != nil {
		return m.ActivityID
	}
	return 0
}

func (m *ActivityFinshChange) GetFinshNum() int32 {
	if m != nil {
		return m.FinshNum
	}
	return 0
}

func (m *ActivityFinshChange) GetRewardID() int32 {
	if m != nil {
		return m.RewardID
	}
	return 0
}

type ActivityReceiveChange struct {
	ActivityID    int32                 `protobuf:"varint,1,opt,name=ActivityID,proto3" json:"ActivityID,omitempty"`
	RewardID      int32                 `protobuf:"varint,2,opt,name=RewardID,proto3" json:"RewardID,omitempty"`
	ReceiveStatus ActivityReceiveStatus `protobuf:"varint,3,opt,name=ReceiveStatus,proto3,enum=pb.ActivityReceiveStatus" json:"ReceiveStatus,omitempty"`
}

func (m *ActivityReceiveChange) Reset()                    { *m = ActivityReceiveChange{} }
func (m *ActivityReceiveChange) String() string            { return proto.CompactTextString(m) }
func (*ActivityReceiveChange) ProtoMessage()               {}
func (*ActivityReceiveChange) Descriptor() ([]byte, []int) { return fileDescriptorActivity, []int{8} }

func (m *ActivityReceiveChange) GetActivityID() int32 {
	if m != nil {
		return m.ActivityID
	}
	return 0
}

func (m *ActivityReceiveChange) GetRewardID() int32 {
	if m != nil {
		return m.RewardID
	}
	return 0
}

func (m *ActivityReceiveChange) GetReceiveStatus() ActivityReceiveStatus {
	if m != nil {
		return m.ReceiveStatus
	}
	return ActivityReceiveStatus_ReceiveUnknow
}

type ActivityStatusChange struct {
	ActivityID int32 `protobuf:"varint,1,opt,name=ActivityID,proto3" json:"ActivityID,omitempty"`
	Status     bool  `protobuf:"varint,2,opt,name=Status,proto3" json:"Status,omitempty"`
}

func (m *ActivityStatusChange) Reset()                    { *m = ActivityStatusChange{} }
func (m *ActivityStatusChange) String() string            { return proto.CompactTextString(m) }
func (*ActivityStatusChange) ProtoMessage()               {}
func (*ActivityStatusChange) Descriptor() ([]byte, []int) { return fileDescriptorActivity, []int{9} }

func (m *ActivityStatusChange) GetActivityID() int32 {
	if m != nil {
		return m.ActivityID
	}
	return 0
}

func (m *ActivityStatusChange) GetStatus() bool {
	if m != nil {
		return m.Status
	}
	return false
}

func init() {
	proto.RegisterType((*ActivityLabelList)(nil), "pb.ActivityLabelList")
	proto.RegisterType((*Activity)(nil), "pb.Activity")
	proto.RegisterType((*ActivityList)(nil), "pb.ActivityList")
	proto.RegisterType((*ActivityData)(nil), "pb.ActivityData")
	proto.RegisterType((*TargetActivity)(nil), "pb.TargetActivity")
	proto.RegisterType((*ActivityID)(nil), "pb.ActivityID")
	proto.RegisterType((*Reward)(nil), "pb.Reward")
	proto.RegisterType((*ActivityFinshChange)(nil), "pb.ActivityFinshChange")
	proto.RegisterType((*ActivityReceiveChange)(nil), "pb.ActivityReceiveChange")
	proto.RegisterType((*ActivityStatusChange)(nil), "pb.ActivityStatusChange")
	proto.RegisterEnum("pb.ActivityReceiveStatus", ActivityReceiveStatus_name, ActivityReceiveStatus_value)
}
func (m *ActivityLabelList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivityLabelList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IDList) > 0 {
		dAtA2 := make([]byte, len(m.IDList)*10)
		var j1 int
		for _, num1 := range m.IDList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintActivity(dAtA, i, uint64(j1))
		i += copy(dAtA[i:], dAtA2[:j1])
	}
	return i, nil
}

func (m *Activity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Activity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RewardID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintActivity(dAtA, i, uint64(m.RewardID))
	}
	if m.ReceiveStatus != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintActivity(dAtA, i, uint64(m.ReceiveStatus))
	}
	if len(m.RewardCondition) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintActivity(dAtA, i, uint64(len(m.RewardCondition)))
		i += copy(dAtA[i:], m.RewardCondition)
	}
	if m.FinshNum != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintActivity(dAtA, i, uint64(m.FinshNum))
	}
	if len(m.RewardList) > 0 {
		for k, _ := range m.RewardList {
			dAtA[i] = 0x2a
			i++
			v := m.RewardList[k]
			mapSize := 1 + len(k) + sovActivity(uint64(len(k))) + 1 + sovActivity(uint64(v))
			i = encodeVarintActivity(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintActivity(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintActivity(dAtA, i, uint64(v))
		}
	}
	return i, nil
}

func (m *ActivityList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivityList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Activitys) > 0 {
		for _, msg := range m.Activitys {
			dAtA[i] = 0xa
			i++
			i = encodeVarintActivity(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ActivityData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivityData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintActivity(dAtA, i, uint64(m.ID))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintActivity(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *TargetActivity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TargetActivity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintActivity(dAtA, i, uint64(m.ID))
	}
	if m.RewardID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintActivity(dAtA, i, uint64(m.RewardID))
	}
	return i, nil
}

func (m *ActivityID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivityID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ActivityID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintActivity(dAtA, i, uint64(m.ActivityID))
	}
	return i, nil
}

func (m *Reward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Reward) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RewardList) > 0 {
		for k, _ := range m.RewardList {
			dAtA[i] = 0xa
			i++
			v := m.RewardList[k]
			mapSize := 1 + len(k) + sovActivity(uint64(len(k))) + 1 + sovActivity(uint64(v))
			i = encodeVarintActivity(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintActivity(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x10
			i++
			i = encodeVarintActivity(dAtA, i, uint64(v))
		}
	}
	if len(m.TreasureReward) > 0 {
		for _, msg := range m.TreasureReward {
			dAtA[i] = 0x12
			i++
			i = encodeVarintActivity(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ActivityFinshChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivityFinshChange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ActivityID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintActivity(dAtA, i, uint64(m.ActivityID))
	}
	if m.FinshNum != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintActivity(dAtA, i, uint64(m.FinshNum))
	}
	if m.RewardID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintActivity(dAtA, i, uint64(m.RewardID))
	}
	return i, nil
}

func (m *ActivityReceiveChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivityReceiveChange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ActivityID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintActivity(dAtA, i, uint64(m.ActivityID))
	}
	if m.RewardID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintActivity(dAtA, i, uint64(m.RewardID))
	}
	if m.ReceiveStatus != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintActivity(dAtA, i, uint64(m.ReceiveStatus))
	}
	return i, nil
}

func (m *ActivityStatusChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivityStatusChange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ActivityID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintActivity(dAtA, i, uint64(m.ActivityID))
	}
	if m.Status {
		dAtA[i] = 0x10
		i++
		if m.Status {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func encodeVarintActivity(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ActivityLabelList) Size() (n int) {
	var l int
	_ = l
	if len(m.IDList) > 0 {
		l = 0
		for _, e := range m.IDList {
			l += sovActivity(uint64(e))
		}
		n += 1 + sovActivity(uint64(l)) + l
	}
	return n
}

func (m *Activity) Size() (n int) {
	var l int
	_ = l
	if m.RewardID != 0 {
		n += 1 + sovActivity(uint64(m.RewardID))
	}
	if m.ReceiveStatus != 0 {
		n += 1 + sovActivity(uint64(m.ReceiveStatus))
	}
	l = len(m.RewardCondition)
	if l > 0 {
		n += 1 + l + sovActivity(uint64(l))
	}
	if m.FinshNum != 0 {
		n += 1 + sovActivity(uint64(m.FinshNum))
	}
	if len(m.RewardList) > 0 {
		for k, v := range m.RewardList {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovActivity(uint64(len(k))) + 1 + sovActivity(uint64(v))
			n += mapEntrySize + 1 + sovActivity(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ActivityList) Size() (n int) {
	var l int
	_ = l
	if len(m.Activitys) > 0 {
		for _, e := range m.Activitys {
			l = e.Size()
			n += 1 + l + sovActivity(uint64(l))
		}
	}
	return n
}

func (m *ActivityData) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovActivity(uint64(m.ID))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovActivity(uint64(l))
	}
	return n
}

func (m *TargetActivity) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovActivity(uint64(m.ID))
	}
	if m.RewardID != 0 {
		n += 1 + sovActivity(uint64(m.RewardID))
	}
	return n
}

func (m *ActivityID) Size() (n int) {
	var l int
	_ = l
	if m.ActivityID != 0 {
		n += 1 + sovActivity(uint64(m.ActivityID))
	}
	return n
}

func (m *Reward) Size() (n int) {
	var l int
	_ = l
	if len(m.RewardList) > 0 {
		for k, v := range m.RewardList {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovActivity(uint64(len(k))) + 1 + sovActivity(uint64(v))
			n += mapEntrySize + 1 + sovActivity(uint64(mapEntrySize))
		}
	}
	if len(m.TreasureReward) > 0 {
		for _, e := range m.TreasureReward {
			l = e.Size()
			n += 1 + l + sovActivity(uint64(l))
		}
	}
	return n
}

func (m *ActivityFinshChange) Size() (n int) {
	var l int
	_ = l
	if m.ActivityID != 0 {
		n += 1 + sovActivity(uint64(m.ActivityID))
	}
	if m.FinshNum != 0 {
		n += 1 + sovActivity(uint64(m.FinshNum))
	}
	if m.RewardID != 0 {
		n += 1 + sovActivity(uint64(m.RewardID))
	}
	return n
}

func (m *ActivityReceiveChange) Size() (n int) {
	var l int
	_ = l
	if m.ActivityID != 0 {
		n += 1 + sovActivity(uint64(m.ActivityID))
	}
	if m.RewardID != 0 {
		n += 1 + sovActivity(uint64(m.RewardID))
	}
	if m.ReceiveStatus != 0 {
		n += 1 + sovActivity(uint64(m.ReceiveStatus))
	}
	return n
}

func (m *ActivityStatusChange) Size() (n int) {
	var l int
	_ = l
	if m.ActivityID != 0 {
		n += 1 + sovActivity(uint64(m.ActivityID))
	}
	if m.Status {
		n += 2
	}
	return n
}

func sovActivity(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozActivity(x uint64) (n int) {
	return sovActivity(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ActivityLabelList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivityLabelList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivityLabelList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IDList = append(m.IDList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthActivity
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IDList = append(m.IDList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IDList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Activity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Activity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Activity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardID", wireType)
			}
			m.RewardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiveStatus", wireType)
			}
			m.ReceiveStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReceiveStatus |= (ActivityReceiveStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardCondition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthActivity
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardCondition = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinshNum", wireType)
			}
			m.FinshNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinshNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActivity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RewardList == nil {
				m.RewardList = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthActivity
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipActivity(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthActivity
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RewardList[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivityList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivityList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivityList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Activitys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActivity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Activitys = append(m.Activitys, &Activity{})
			if err := m.Activitys[len(m.Activitys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivityData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivityData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivityData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthActivity
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TargetActivity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TargetActivity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TargetActivity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardID", wireType)
			}
			m.RewardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivityID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivityID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivityID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivityID", wireType)
			}
			m.ActivityID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivityID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Reward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActivity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RewardList == nil {
				m.RewardList = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthActivity
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowActivity
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipActivity(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthActivity
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RewardList[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasureReward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthActivity
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TreasureReward = append(m.TreasureReward, &OpenTreasureReply{})
			if err := m.TreasureReward[len(m.TreasureReward)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivityFinshChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivityFinshChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivityFinshChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivityID", wireType)
			}
			m.ActivityID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivityID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinshNum", wireType)
			}
			m.FinshNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinshNum |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardID", wireType)
			}
			m.RewardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivityReceiveChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivityReceiveChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivityReceiveChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivityID", wireType)
			}
			m.ActivityID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivityID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardID", wireType)
			}
			m.RewardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceiveStatus", wireType)
			}
			m.ReceiveStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReceiveStatus |= (ActivityReceiveStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivityStatusChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowActivity
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivityStatusChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivityStatusChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivityID", wireType)
			}
			m.ActivityID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivityID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Status = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipActivity(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthActivity
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipActivity(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowActivity
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowActivity
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthActivity
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowActivity
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipActivity(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthActivity = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowActivity   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("activity.proto", fileDescriptorActivity) }

var fileDescriptorActivity = []byte{
	// 532 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x54, 0xd1, 0x6e, 0xd3, 0x30,
	0x14, 0x9d, 0x9d, 0xb5, 0x6a, 0xef, 0x4a, 0xc8, 0xcc, 0x36, 0x85, 0x0a, 0x55, 0x55, 0x9e, 0xa2,
	0x81, 0xfa, 0x50, 0x5e, 0x50, 0xb5, 0x09, 0x41, 0x0b, 0xa2, 0xd2, 0x54, 0x24, 0x33, 0x3e, 0xc0,
	0x6d, 0xad, 0x35, 0x5a, 0xe7, 0x44, 0x89, 0xdb, 0xa9, 0xff, 0xc1, 0x03, 0xdf, 0xc0, 0x67, 0xf0,
	0xc4, 0x23, 0x9f, 0x80, 0xca, 0x8f, 0x20, 0xc7, 0x71, 0x9a, 0x64, 0x02, 0x86, 0x78, 0xf3, 0x39,
	0xbe, 0xd7, 0xb9, 0xe7, 0xdc, 0x7b, 0x03, 0x36, 0x9b, 0xc9, 0x60, 0x1d, 0xc8, 0x4d, 0x2f, 0x8a,
	0x43, 0x19, 0x12, 0x1c, 0x4d, 0xdb, 0xb6, 0x8c, 0x39, 0x4b, 0x56, 0x31, 0xd7, 0x9c, 0xf7, 0x14,
	0x0e, 0x5f, 0x65, 0x51, 0x17, 0x6c, 0xca, 0x97, 0x17, 0x41, 0x22, 0xc9, 0x09, 0xd4, 0xc7, 0x23,
	0x75, 0x72, 0x51, 0xd7, 0xf2, 0x6b, 0x34, 0x43, 0xde, 0x17, 0x0c, 0x0d, 0x13, 0x4d, 0xda, 0xd0,
	0xa0, 0xfc, 0x96, 0xc5, 0xf3, 0xf1, 0xc8, 0x45, 0x5d, 0xe4, 0xd7, 0x68, 0x8e, 0xc9, 0x4b, 0x78,
	0x40, 0xf9, 0x8c, 0x07, 0x6b, 0xfe, 0x41, 0x32, 0xb9, 0x4a, 0x5c, 0xdc, 0x45, 0xbe, 0xdd, 0x7f,
	0xdc, 0x8b, 0xa6, 0x3d, 0xf3, 0x40, 0x29, 0x80, 0x96, 0xe3, 0x89, 0x0f, 0x0f, 0xf5, 0x63, 0xc3,
	0x50, 0xcc, 0x03, 0x19, 0x84, 0xc2, 0xb5, 0xba, 0xc8, 0x6f, 0xd2, 0x2a, 0xad, 0xca, 0x78, 0x1b,
	0x88, 0x64, 0x31, 0x59, 0xdd, 0xb8, 0xfb, 0xba, 0x0c, 0x83, 0xc9, 0x19, 0x80, 0x0e, 0x4f, 0xb5,
	0xd4, 0xba, 0x96, 0x7f, 0xd0, 0x7f, 0x52, 0xac, 0xa1, 0xb7, 0xbb, 0x7e, 0x23, 0x64, 0xbc, 0xa1,
	0x85, 0xf8, 0xf6, 0xb9, 0xa9, 0x21, 0xbf, 0x26, 0x0e, 0x58, 0xd7, 0x7c, 0x93, 0xca, 0x6d, 0x52,
	0x75, 0x24, 0x47, 0x50, 0x5b, 0xb3, 0xe5, 0x8a, 0xa7, 0x0a, 0x6b, 0x54, 0x83, 0x01, 0x7e, 0x81,
	0xbc, 0x01, 0xb4, 0x72, 0x67, 0x95, 0xa9, 0xa7, 0xd0, 0x34, 0x38, 0x49, 0x7d, 0x3d, 0xe8, 0xb7,
	0x4a, 0x7e, 0xec, 0xae, 0xbd, 0xfe, 0x2e, 0x77, 0xc4, 0x24, 0x23, 0x36, 0xe0, 0xdc, 0x65, 0x3c,
	0x1e, 0x11, 0x02, 0xfb, 0x8a, 0x4f, 0x3f, 0xda, 0xa2, 0xe9, 0xd9, 0x3b, 0x03, 0xfb, 0x92, 0xc5,
	0x57, 0x5c, 0xe6, 0x1d, 0xaa, 0x66, 0x15, 0x3b, 0x86, 0xcb, 0x1d, 0xf3, 0x9e, 0x01, 0x98, 0xbc,
	0xf1, 0x88, 0x74, 0x8a, 0x28, 0x7b, 0xa1, 0xc0, 0x78, 0x5f, 0x11, 0xd4, 0x75, 0x2a, 0x19, 0x94,
	0x3c, 0xd6, 0xba, 0xda, 0x4a, 0x97, 0x66, 0xff, 0xe4, 0x30, 0x39, 0x07, 0xfb, 0x32, 0x1b, 0x47,
	0xcd, 0xba, 0x38, 0xcd, 0x3f, 0x56, 0xf9, 0xef, 0x23, 0x2e, 0x76, 0xb7, 0xd1, 0x72, 0x43, 0x2b,
	0xc1, 0xff, 0xdb, 0xa0, 0x1b, 0x78, 0x64, 0x24, 0xa5, 0x13, 0x33, 0x5c, 0x30, 0x71, 0xc5, 0xff,
	0xa6, 0xbd, 0x34, 0x70, 0xb8, 0x32, 0x70, 0x45, 0x87, 0xad, 0x8a, 0xc3, 0x9f, 0x10, 0x1c, 0x57,
	0x66, 0xff, 0xfe, 0x5f, 0xfc, 0x5d, 0xdf, 0xee, 0x6e, 0x9a, 0xf5, 0x6f, 0x9b, 0xe6, 0x4d, 0xe0,
	0xc8, 0xc4, 0x69, 0xe6, 0x9e, 0x45, 0x9d, 0x40, 0xbd, 0xb0, 0xdb, 0x0d, 0x9a, 0xa1, 0xd3, 0xf0,
	0x8e, 0xca, 0x6c, 0xa5, 0x0f, 0xf3, 0x4a, 0x3f, 0x8a, 0x6b, 0x11, 0xde, 0x3a, 0x7b, 0xc4, 0x06,
	0x18, 0x32, 0x91, 0xb1, 0x0e, 0x52, 0xf8, 0x1d, 0x4b, 0x0c, 0xc6, 0x2a, 0x65, 0xc8, 0xc4, 0x24,
	0x94, 0x86, 0xb2, 0x88, 0x03, 0xad, 0x09, 0xe7, 0x73, 0xca, 0x67, 0x0b, 0x35, 0xec, 0xce, 0xfe,
	0x6b, 0xe7, 0xdb, 0xb6, 0x83, 0xbe, 0x6f, 0x3b, 0xe8, 0xc7, 0xb6, 0x83, 0x3e, 0xff, 0xec, 0xec,
	0x4d, 0xeb, 0xe9, 0xaf, 0xed, 0xf9, 0xaf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xd6, 0x18, 0x04, 0xc6,
	0x00, 0x05, 0x00, 0x00,
}
