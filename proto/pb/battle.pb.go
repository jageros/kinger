// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: battle.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type BattleHandType int32

const (
	BattleHandType_UnknowType BattleHandType = 0
	BattleHandType_Default    BattleHandType = 1
	BattleHandType_Random     BattleHandType = 2
	BattleHandType_Ban        BattleHandType = 3
	BattleHandType_Switch     BattleHandType = 4
)

var BattleHandType_name = map[int32]string{
	0: "UnknowType",
	1: "Default",
	2: "Random",
	3: "Ban",
	4: "Switch",
}
var BattleHandType_value = map[string]int32{
	"UnknowType": 0,
	"Default":    1,
	"Random":     2,
	"Ban":        3,
	"Switch":     4,
}

func (x BattleHandType) String() string {
	return proto.EnumName(BattleHandType_name, int32(x))
}
func (BattleHandType) EnumDescriptor() ([]byte, []int) { return fileDescriptorBattle, []int{0} }

type BattleResult_NoSubStarReasonEnum int32

const (
	BattleResult_Normal        BattleResult_NoSubStarReasonEnum = 0
	BattleResult_NoSubStarPriv BattleResult_NoSubStarReasonEnum = 1
)

var BattleResult_NoSubStarReasonEnum_name = map[int32]string{
	0: "Normal",
	1: "NoSubStarPriv",
}
var BattleResult_NoSubStarReasonEnum_value = map[string]int32{
	"Normal":        0,
	"NoSubStarPriv": 1,
}

func (x BattleResult_NoSubStarReasonEnum) String() string {
	return proto.EnumName(BattleResult_NoSubStarReasonEnum_name, int32(x))
}
func (BattleResult_NoSubStarReasonEnum) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorBattle, []int{19, 0}
}

type VideoAction_ActionID int32

const (
	VideoAction_Unknow     VideoAction_ActionID = 0
	VideoAction_Begin      VideoAction_ActionID = 1
	VideoAction_BoutBegin  VideoAction_ActionID = 2
	VideoAction_BoutAction VideoAction_ActionID = 3
	VideoAction_End        VideoAction_ActionID = 4
)

var VideoAction_ActionID_name = map[int32]string{
	0: "Unknow",
	1: "Begin",
	2: "BoutBegin",
	3: "BoutAction",
	4: "End",
}
var VideoAction_ActionID_value = map[string]int32{
	"Unknow":     0,
	"Begin":      1,
	"BoutBegin":  2,
	"BoutAction": 3,
	"End":        4,
}

func (x VideoAction_ActionID) String() string {
	return proto.EnumName(VideoAction_ActionID_name, int32(x))
}
func (VideoAction_ActionID) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorBattle, []int{23, 0}
}

type LogBattleArg_BattleEvent int32

const (
	LogBattleArg_Unknow   LogBattleArg_BattleEvent = 0
	LogBattleArg_Begin    LogBattleArg_BattleEvent = 1
	LogBattleArg_OpenView LogBattleArg_BattleEvent = 2
	LogBattleArg_End      LogBattleArg_BattleEvent = 3
	LogBattleArg_Restored LogBattleArg_BattleEvent = 4
)

var LogBattleArg_BattleEvent_name = map[int32]string{
	0: "Unknow",
	1: "Begin",
	2: "OpenView",
	3: "End",
	4: "Restored",
}
var LogBattleArg_BattleEvent_value = map[string]int32{
	"Unknow":   0,
	"Begin":    1,
	"OpenView": 2,
	"End":      3,
	"Restored": 4,
}

func (x LogBattleArg_BattleEvent) String() string {
	return proto.EnumName(LogBattleArg_BattleEvent_name, int32(x))
}
func (LogBattleArg_BattleEvent) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorBattle, []int{31, 0}
}

type ClientAction_ActionID int32

const (
	ClientAction_Unknow   ClientAction_ActionID = 0
	ClientAction_Attack   ClientAction_ActionID = 1
	ClientAction_TurnOver ClientAction_ActionID = 2
	ClientAction_Skill    ClientAction_ActionID = 3
	// TauntDel = 4;
	// SkillPrepare = 5;
	ClientAction_SkillStatusMovie ClientAction_ActionID = 6
	ClientAction_ModifyValue      ClientAction_ActionID = 7
	// SkillOth = 8;
	ClientAction_TextMovie      ClientAction_ActionID = 9
	ClientAction_Movie          ClientAction_ActionID = 10
	ClientAction_DrawCard       ClientAction_ActionID = 11
	ClientAction_Bonus          ClientAction_ActionID = 12
	ClientAction_SwitchPos      ClientAction_ActionID = 13
	ClientAction_HandShow       ClientAction_ActionID = 14
	ClientAction_AddSkill       ClientAction_ActionID = 15
	ClientAction_DelSkill       ClientAction_ActionID = 16
	ClientAction_DisCard        ClientAction_ActionID = 17
	ClientAction_Destroy        ClientAction_ActionID = 18
	ClientAction_Summon         ClientAction_ActionID = 19
	ClientAction_Return         ClientAction_ActionID = 20
	ClientAction_Guanxing       ClientAction_ActionID = 21
	ClientAction_Copy           ClientAction_ActionID = 22
	ClientAction_EnterFog       ClientAction_ActionID = 23
	ClientAction_LeaveFog       ClientAction_ActionID = 24
	ClientAction_GoldGob        ClientAction_ActionID = 25
	ClientAction_SwitchHandCard ClientAction_ActionID = 26
	ClientAction_DelEquip       ClientAction_ActionID = 27
	ClientAction_PlayCard       ClientAction_ActionID = 1000
	ClientAction_Move           ClientAction_ActionID = 1001
	ClientAction_BattleEnd      ClientAction_ActionID = 1002
	ClientAction_BoutBegin      ClientAction_ActionID = 1003
	ClientAction_BoutResult     ClientAction_ActionID = 1004
	ClientAction_BattleBegin    ClientAction_ActionID = 1005
	ClientAction_BattleRestored ClientAction_ActionID = 1006
)

var ClientAction_ActionID_name = map[int32]string{
	0:    "Unknow",
	1:    "Attack",
	2:    "TurnOver",
	3:    "Skill",
	6:    "SkillStatusMovie",
	7:    "ModifyValue",
	9:    "TextMovie",
	10:   "Movie",
	11:   "DrawCard",
	12:   "Bonus",
	13:   "SwitchPos",
	14:   "HandShow",
	15:   "AddSkill",
	16:   "DelSkill",
	17:   "DisCard",
	18:   "Destroy",
	19:   "Summon",
	20:   "Return",
	21:   "Guanxing",
	22:   "Copy",
	23:   "EnterFog",
	24:   "LeaveFog",
	25:   "GoldGob",
	26:   "SwitchHandCard",
	27:   "DelEquip",
	1000: "PlayCard",
	1001: "Move",
	1002: "BattleEnd",
	1003: "BoutBegin",
	1004: "BoutResult",
	1005: "BattleBegin",
	1006: "BattleRestored",
}
var ClientAction_ActionID_value = map[string]int32{
	"Unknow":           0,
	"Attack":           1,
	"TurnOver":         2,
	"Skill":            3,
	"SkillStatusMovie": 6,
	"ModifyValue":      7,
	"TextMovie":        9,
	"Movie":            10,
	"DrawCard":         11,
	"Bonus":            12,
	"SwitchPos":        13,
	"HandShow":         14,
	"AddSkill":         15,
	"DelSkill":         16,
	"DisCard":          17,
	"Destroy":          18,
	"Summon":           19,
	"Return":           20,
	"Guanxing":         21,
	"Copy":             22,
	"EnterFog":         23,
	"LeaveFog":         24,
	"GoldGob":          25,
	"SwitchHandCard":   26,
	"DelEquip":         27,
	"PlayCard":         1000,
	"Move":             1001,
	"BattleEnd":        1002,
	"BoutBegin":        1003,
	"BoutResult":       1004,
	"BattleBegin":      1005,
	"BattleRestored":   1006,
}

func (x ClientAction_ActionID) String() string {
	return proto.EnumName(ClientAction_ActionID_name, int32(x))
}
func (ClientAction_ActionID) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorBattle, []int{33, 0}
}

type SendEmojiArg struct {
	EmojiID int32 `protobuf:"varint,1,opt,name=EmojiID,proto3" json:"EmojiID,omitempty"`
}

func (m *SendEmojiArg) Reset()                    { *m = SendEmojiArg{} }
func (m *SendEmojiArg) String() string            { return proto.CompactTextString(m) }
func (*SendEmojiArg) ProtoMessage()               {}
func (*SendEmojiArg) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{0} }

func (m *SendEmojiArg) GetEmojiID() int32 {
	if m != nil {
		return m.EmojiID
	}
	return 0
}

type MovieEffect struct {
	MovieID    string `protobuf:"bytes,1,opt,name=MovieID,proto3" json:"MovieID,omitempty"`
	PlayType   int32  `protobuf:"varint,2,opt,name=PlayType,proto3" json:"PlayType,omitempty"`
	OwnerObjID int32  `protobuf:"varint,3,opt,name=OwnerObjID,proto3" json:"OwnerObjID,omitempty"`
}

func (m *MovieEffect) Reset()                    { *m = MovieEffect{} }
func (m *MovieEffect) String() string            { return proto.CompactTextString(m) }
func (*MovieEffect) ProtoMessage()               {}
func (*MovieEffect) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{1} }

func (m *MovieEffect) GetMovieID() string {
	if m != nil {
		return m.MovieID
	}
	return ""
}

func (m *MovieEffect) GetPlayType() int32 {
	if m != nil {
		return m.PlayType
	}
	return 0
}

func (m *MovieEffect) GetOwnerObjID() int32 {
	if m != nil {
		return m.OwnerObjID
	}
	return 0
}

type DiyFightCardInfo struct {
	CardId      uint32 `protobuf:"varint,1,opt,name=CardId,proto3" json:"CardId,omitempty"`
	Name        string `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	DiySkillId1 int32  `protobuf:"varint,3,opt,name=DiySkillId1,proto3" json:"DiySkillId1,omitempty"`
	DiySkillId2 int32  `protobuf:"varint,4,opt,name=DiySkillId2,proto3" json:"DiySkillId2,omitempty"`
	Weapon      string `protobuf:"bytes,5,opt,name=Weapon,proto3" json:"Weapon,omitempty"`
}

func (m *DiyFightCardInfo) Reset()                    { *m = DiyFightCardInfo{} }
func (m *DiyFightCardInfo) String() string            { return proto.CompactTextString(m) }
func (*DiyFightCardInfo) ProtoMessage()               {}
func (*DiyFightCardInfo) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{2} }

func (m *DiyFightCardInfo) GetCardId() uint32 {
	if m != nil {
		return m.CardId
	}
	return 0
}

func (m *DiyFightCardInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DiyFightCardInfo) GetDiySkillId1() int32 {
	if m != nil {
		return m.DiySkillId1
	}
	return 0
}

func (m *DiyFightCardInfo) GetDiySkillId2() int32 {
	if m != nil {
		return m.DiySkillId2
	}
	return 0
}

func (m *DiyFightCardInfo) GetWeapon() string {
	if m != nil {
		return m.Weapon
	}
	return ""
}

type Card struct {
	Id            uint32            `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	ObjId         int32             `protobuf:"varint,2,opt,name=ObjId,proto3" json:"ObjId,omitempty"`
	Up            int32             `protobuf:"varint,3,opt,name=Up,proto3" json:"Up,omitempty"`
	Down          int32             `protobuf:"varint,4,opt,name=Down,proto3" json:"Down,omitempty"`
	Left          int32             `protobuf:"varint,5,opt,name=Left,proto3" json:"Left,omitempty"`
	Right         int32             `protobuf:"varint,6,opt,name=Right,proto3" json:"Right,omitempty"`
	DiyInfo       *DiyFightCardInfo `protobuf:"bytes,7,opt,name=DiyInfo" json:"DiyInfo,omitempty"`
	Effect        []*MovieEffect    `protobuf:"bytes,8,rep,name=Effect" json:"Effect,omitempty"`
	Skills        []int32           `protobuf:"varint,9,rep,packed,name=Skills" json:"Skills,omitempty"`
	IsInFog       bool              `protobuf:"varint,10,opt,name=IsInFog,proto3" json:"IsInFog,omitempty"`
	IsPublicEnemy bool              `protobuf:"varint,11,opt,name=IsPublicEnemy,proto3" json:"IsPublicEnemy,omitempty"`
	Skin          string            `protobuf:"bytes,12,opt,name=Skin,proto3" json:"Skin,omitempty"`
	Equip         *BattleEquip      `protobuf:"bytes,13,opt,name=Equip" json:"Equip,omitempty"`
}

func (m *Card) Reset()                    { *m = Card{} }
func (m *Card) String() string            { return proto.CompactTextString(m) }
func (*Card) ProtoMessage()               {}
func (*Card) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{3} }

func (m *Card) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Card) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *Card) GetUp() int32 {
	if m != nil {
		return m.Up
	}
	return 0
}

func (m *Card) GetDown() int32 {
	if m != nil {
		return m.Down
	}
	return 0
}

func (m *Card) GetLeft() int32 {
	if m != nil {
		return m.Left
	}
	return 0
}

func (m *Card) GetRight() int32 {
	if m != nil {
		return m.Right
	}
	return 0
}

func (m *Card) GetDiyInfo() *DiyFightCardInfo {
	if m != nil {
		return m.DiyInfo
	}
	return nil
}

func (m *Card) GetEffect() []*MovieEffect {
	if m != nil {
		return m.Effect
	}
	return nil
}

func (m *Card) GetSkills() []int32 {
	if m != nil {
		return m.Skills
	}
	return nil
}

func (m *Card) GetIsInFog() bool {
	if m != nil {
		return m.IsInFog
	}
	return false
}

func (m *Card) GetIsPublicEnemy() bool {
	if m != nil {
		return m.IsPublicEnemy
	}
	return false
}

func (m *Card) GetSkin() string {
	if m != nil {
		return m.Skin
	}
	return ""
}

func (m *Card) GetEquip() *BattleEquip {
	if m != nil {
		return m.Equip
	}
	return nil
}

type BattleEquip struct {
	EquipID string  `protobuf:"bytes,1,opt,name=EquipID,proto3" json:"EquipID,omitempty"`
	Skills  []int32 `protobuf:"varint,2,rep,packed,name=Skills" json:"Skills,omitempty"`
}

func (m *BattleEquip) Reset()                    { *m = BattleEquip{} }
func (m *BattleEquip) String() string            { return proto.CompactTextString(m) }
func (*BattleEquip) ProtoMessage()               {}
func (*BattleEquip) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{4} }

func (m *BattleEquip) GetEquipID() string {
	if m != nil {
		return m.EquipID
	}
	return ""
}

func (m *BattleEquip) GetSkills() []int32 {
	if m != nil {
		return m.Skills
	}
	return nil
}

type Fighter struct {
	Uid           uint64  `protobuf:"varint,1,opt,name=Uid,proto3" json:"Uid,omitempty"`
	Hand          []*Card `protobuf:"bytes,2,rep,name=Hand" json:"Hand,omitempty"`
	ObjId         int32   `protobuf:"varint,3,opt,name=ObjId,proto3" json:"ObjId,omitempty"`
	CasterSkills  []int32 `protobuf:"varint,4,rep,packed,name=CasterSkills" json:"CasterSkills,omitempty"`
	Name          string  `protobuf:"bytes,5,opt,name=Name,proto3" json:"Name,omitempty"`
	Camp          int32   `protobuf:"varint,6,opt,name=Camp,proto3" json:"Camp,omitempty"`
	PvpScore      int32   `protobuf:"varint,7,opt,name=PvpScore,proto3" json:"PvpScore,omitempty"`
	MaxHandAmount int32   `protobuf:"varint,8,opt,name=MaxHandAmount,proto3" json:"MaxHandAmount,omitempty"`
	HeadImgUrl    string  `protobuf:"bytes,9,opt,name=HeadImgUrl,proto3" json:"HeadImgUrl,omitempty"`
	HeadFrame     string  `protobuf:"bytes,10,opt,name=HeadFrame,proto3" json:"HeadFrame,omitempty"`
	NameText      int32   `protobuf:"varint,11,opt,name=NameText,proto3" json:"NameText,omitempty"`
	CountryFlag   string  `protobuf:"bytes,12,opt,name=CountryFlag,proto3" json:"CountryFlag,omitempty"`
}

func (m *Fighter) Reset()                    { *m = Fighter{} }
func (m *Fighter) String() string            { return proto.CompactTextString(m) }
func (*Fighter) ProtoMessage()               {}
func (*Fighter) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{5} }

func (m *Fighter) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *Fighter) GetHand() []*Card {
	if m != nil {
		return m.Hand
	}
	return nil
}

func (m *Fighter) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *Fighter) GetCasterSkills() []int32 {
	if m != nil {
		return m.CasterSkills
	}
	return nil
}

func (m *Fighter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Fighter) GetCamp() int32 {
	if m != nil {
		return m.Camp
	}
	return 0
}

func (m *Fighter) GetPvpScore() int32 {
	if m != nil {
		return m.PvpScore
	}
	return 0
}

func (m *Fighter) GetMaxHandAmount() int32 {
	if m != nil {
		return m.MaxHandAmount
	}
	return 0
}

func (m *Fighter) GetHeadImgUrl() string {
	if m != nil {
		return m.HeadImgUrl
	}
	return ""
}

func (m *Fighter) GetHeadFrame() string {
	if m != nil {
		return m.HeadFrame
	}
	return ""
}

func (m *Fighter) GetNameText() int32 {
	if m != nil {
		return m.NameText
	}
	return 0
}

func (m *Fighter) GetCountryFlag() string {
	if m != nil {
		return m.CountryFlag
	}
	return ""
}

type Grid struct {
	ObjId      int32          `protobuf:"varint,1,opt,name=ObjId,proto3" json:"ObjId,omitempty"`
	InGridCard *Card          `protobuf:"bytes,2,opt,name=InGridCard" json:"InGridCard,omitempty"`
	Owner      uint64         `protobuf:"varint,3,opt,name=Owner,proto3" json:"Owner,omitempty"`
	Effect     []*MovieEffect `protobuf:"bytes,8,rep,name=Effect" json:"Effect,omitempty"`
}

func (m *Grid) Reset()                    { *m = Grid{} }
func (m *Grid) String() string            { return proto.CompactTextString(m) }
func (*Grid) ProtoMessage()               {}
func (*Grid) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{6} }

func (m *Grid) GetObjId() int32 {
	if m != nil {
		return m.ObjId
	}
	return 0
}

func (m *Grid) GetInGridCard() *Card {
	if m != nil {
		return m.InGridCard
	}
	return nil
}

func (m *Grid) GetOwner() uint64 {
	if m != nil {
		return m.Owner
	}
	return 0
}

func (m *Grid) GetEffect() []*MovieEffect {
	if m != nil {
		return m.Effect
	}
	return nil
}

type FightDesk struct {
	DeskId     uint64   `protobuf:"varint,1,opt,name=DeskId,proto3" json:"DeskId,omitempty"`
	Type       int32    `protobuf:"varint,2,opt,name=Type,proto3" json:"Type,omitempty"`
	Grids      []*Grid  `protobuf:"bytes,3,rep,name=Grids" json:"Grids,omitempty"`
	Fighter1   *Fighter `protobuf:"bytes,4,opt,name=Fighter1" json:"Fighter1,omitempty"`
	Fighter2   *Fighter `protobuf:"bytes,5,opt,name=Fighter2" json:"Fighter2,omitempty"`
	Scale      int32    `protobuf:"varint,6,opt,name=Scale,proto3" json:"Scale,omitempty"`
	BattleRes  int32    `protobuf:"varint,7,opt,name=BattleRes,proto3" json:"BattleRes,omitempty"`
	IsFirstPvp bool     `protobuf:"varint,8,opt,name=IsFirstPvp,proto3" json:"IsFirstPvp,omitempty"`
}

func (m *FightDesk) Reset()                    { *m = FightDesk{} }
func (m *FightDesk) String() string            { return proto.CompactTextString(m) }
func (*FightDesk) ProtoMessage()               {}
func (*FightDesk) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{7} }

func (m *FightDesk) GetDeskId() uint64 {
	if m != nil {
		return m.DeskId
	}
	return 0
}

func (m *FightDesk) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *FightDesk) GetGrids() []*Grid {
	if m != nil {
		return m.Grids
	}
	return nil
}

func (m *FightDesk) GetFighter1() *Fighter {
	if m != nil {
		return m.Fighter1
	}
	return nil
}

func (m *FightDesk) GetFighter2() *Fighter {
	if m != nil {
		return m.Fighter2
	}
	return nil
}

func (m *FightDesk) GetScale() int32 {
	if m != nil {
		return m.Scale
	}
	return 0
}

func (m *FightDesk) GetBattleRes() int32 {
	if m != nil {
		return m.BattleRes
	}
	return 0
}

func (m *FightDesk) GetIsFirstPvp() bool {
	if m != nil {
		return m.IsFirstPvp
	}
	return false
}

// switch HandType {
// case Random:
//   Arg = SeasonRandomHand
// case Ban:
//   Arg = SeasonBanHand
// case Switch:
//   Arg = SeasonSwitchHand
// }
type SeasonBattle struct {
	Battle      *FightDesk     `protobuf:"bytes,1,opt,name=Battle" json:"Battle,omitempty"`
	HandType    BattleHandType `protobuf:"varint,2,opt,name=HandType,proto3,enum=pb.BattleHandType" json:"HandType,omitempty"`
	MyHandCards []*SkinGCard   `protobuf:"bytes,3,rep,name=MyHandCards" json:"MyHandCards,omitempty"`
	Arg         []byte         `protobuf:"bytes,4,opt,name=Arg,proto3" json:"Arg,omitempty"`
}

func (m *SeasonBattle) Reset()                    { *m = SeasonBattle{} }
func (m *SeasonBattle) String() string            { return proto.CompactTextString(m) }
func (*SeasonBattle) ProtoMessage()               {}
func (*SeasonBattle) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{8} }

func (m *SeasonBattle) GetBattle() *FightDesk {
	if m != nil {
		return m.Battle
	}
	return nil
}

func (m *SeasonBattle) GetHandType() BattleHandType {
	if m != nil {
		return m.HandType
	}
	return BattleHandType_UnknowType
}

func (m *SeasonBattle) GetMyHandCards() []*SkinGCard {
	if m != nil {
		return m.MyHandCards
	}
	return nil
}

func (m *SeasonBattle) GetArg() []byte {
	if m != nil {
		return m.Arg
	}
	return nil
}

type SeasonRandomHand struct {
	ChooseAmount int32 `protobuf:"varint,2,opt,name=ChooseAmount,proto3" json:"ChooseAmount,omitempty"`
	RemainTime   int32 `protobuf:"varint,3,opt,name=RemainTime,proto3" json:"RemainTime,omitempty"`
}

func (m *SeasonRandomHand) Reset()                    { *m = SeasonRandomHand{} }
func (m *SeasonRandomHand) String() string            { return proto.CompactTextString(m) }
func (*SeasonRandomHand) ProtoMessage()               {}
func (*SeasonRandomHand) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{9} }

func (m *SeasonRandomHand) GetChooseAmount() int32 {
	if m != nil {
		return m.ChooseAmount
	}
	return 0
}

func (m *SeasonRandomHand) GetRemainTime() int32 {
	if m != nil {
		return m.RemainTime
	}
	return 0
}

type SeasonBanHand struct {
	BanMyCardIdxs    []int32      `protobuf:"varint,1,rep,packed,name=BanMyCardIdxs" json:"BanMyCardIdxs,omitempty"`
	MyRandomCards    []*SkinGCard `protobuf:"bytes,2,rep,name=MyRandomCards" json:"MyRandomCards,omitempty"`
	BanEnemyCardIdxs []int32      `protobuf:"varint,3,rep,packed,name=BanEnemyCardIdxs" json:"BanEnemyCardIdxs,omitempty"`
	EnemyBanCards    []*SkinGCard `protobuf:"bytes,4,rep,name=EnemyBanCards" json:"EnemyBanCards,omitempty"`
}

func (m *SeasonBanHand) Reset()                    { *m = SeasonBanHand{} }
func (m *SeasonBanHand) String() string            { return proto.CompactTextString(m) }
func (*SeasonBanHand) ProtoMessage()               {}
func (*SeasonBanHand) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{10} }

func (m *SeasonBanHand) GetBanMyCardIdxs() []int32 {
	if m != nil {
		return m.BanMyCardIdxs
	}
	return nil
}

func (m *SeasonBanHand) GetMyRandomCards() []*SkinGCard {
	if m != nil {
		return m.MyRandomCards
	}
	return nil
}

func (m *SeasonBanHand) GetBanEnemyCardIdxs() []int32 {
	if m != nil {
		return m.BanEnemyCardIdxs
	}
	return nil
}

func (m *SeasonBanHand) GetEnemyBanCards() []*SkinGCard {
	if m != nil {
		return m.EnemyBanCards
	}
	return nil
}

type SeasonSwitchHand struct {
	SwitchMyCardIdxs    []int32      `protobuf:"varint,1,rep,packed,name=SwitchMyCardIdxs" json:"SwitchMyCardIdxs,omitempty"`
	SwitchEnemyCardIdxs []int32      `protobuf:"varint,2,rep,packed,name=SwitchEnemyCardIdxs" json:"SwitchEnemyCardIdxs,omitempty"`
	EnemySwitchCards    []*SkinGCard `protobuf:"bytes,3,rep,name=EnemySwitchCards" json:"EnemySwitchCards,omitempty"`
}

func (m *SeasonSwitchHand) Reset()                    { *m = SeasonSwitchHand{} }
func (m *SeasonSwitchHand) String() string            { return proto.CompactTextString(m) }
func (*SeasonSwitchHand) ProtoMessage()               {}
func (*SeasonSwitchHand) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{11} }

func (m *SeasonSwitchHand) GetSwitchMyCardIdxs() []int32 {
	if m != nil {
		return m.SwitchMyCardIdxs
	}
	return nil
}

func (m *SeasonSwitchHand) GetSwitchEnemyCardIdxs() []int32 {
	if m != nil {
		return m.SwitchEnemyCardIdxs
	}
	return nil
}

func (m *SeasonSwitchHand) GetEnemySwitchCards() []*SkinGCard {
	if m != nil {
		return m.EnemySwitchCards
	}
	return nil
}

type SeasonBattleReady struct {
	ChooseCards []uint32 `protobuf:"varint,3,rep,packed,name=ChooseCards" json:"ChooseCards,omitempty"`
}

func (m *SeasonBattleReady) Reset()                    { *m = SeasonBattleReady{} }
func (m *SeasonBattleReady) String() string            { return proto.CompactTextString(m) }
func (*SeasonBattleReady) ProtoMessage()               {}
func (*SeasonBattleReady) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{12} }

func (m *SeasonBattleReady) GetChooseCards() []uint32 {
	if m != nil {
		return m.ChooseCards
	}
	return nil
}

type SeasonBattleBegin struct {
	MyHand    []*Card `protobuf:"bytes,1,rep,name=MyHand" json:"MyHand,omitempty"`
	EnemyHand []*Card `protobuf:"bytes,2,rep,name=EnemyHand" json:"EnemyHand,omitempty"`
}

func (m *SeasonBattleBegin) Reset()                    { *m = SeasonBattleBegin{} }
func (m *SeasonBattleBegin) String() string            { return proto.CompactTextString(m) }
func (*SeasonBattleBegin) ProtoMessage()               {}
func (*SeasonBattleBegin) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{13} }

func (m *SeasonBattleBegin) GetMyHand() []*Card {
	if m != nil {
		return m.MyHand
	}
	return nil
}

func (m *SeasonBattleBegin) GetEnemyHand() []*Card {
	if m != nil {
		return m.EnemyHand
	}
	return nil
}

type FightBoutBegin struct {
	BoutUid     uint64          `protobuf:"varint,1,opt,name=BoutUid,proto3" json:"BoutUid,omitempty"`
	Actions     []*ClientAction `protobuf:"bytes,2,rep,name=Actions" json:"Actions,omitempty"`
	BoutTimeout int32           `protobuf:"varint,3,opt,name=BoutTimeout,proto3" json:"BoutTimeout,omitempty"`
	BattleID    uint64          `protobuf:"varint,4,opt,name=BattleID,proto3" json:"BattleID,omitempty"`
}

func (m *FightBoutBegin) Reset()                    { *m = FightBoutBegin{} }
func (m *FightBoutBegin) String() string            { return proto.CompactTextString(m) }
func (*FightBoutBegin) ProtoMessage()               {}
func (*FightBoutBegin) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{14} }

func (m *FightBoutBegin) GetBoutUid() uint64 {
	if m != nil {
		return m.BoutUid
	}
	return 0
}

func (m *FightBoutBegin) GetActions() []*ClientAction {
	if m != nil {
		return m.Actions
	}
	return nil
}

func (m *FightBoutBegin) GetBoutTimeout() int32 {
	if m != nil {
		return m.BoutTimeout
	}
	return 0
}

func (m *FightBoutBegin) GetBattleID() uint64 {
	if m != nil {
		return m.BattleID
	}
	return 0
}

type FightBoutCmd struct {
	UseCardObjID int32 `protobuf:"varint,1,opt,name=UseCardObjID,proto3" json:"UseCardObjID,omitempty"`
	TargetGridId int32 `protobuf:"varint,2,opt,name=TargetGridId,proto3" json:"TargetGridId,omitempty"`
}

func (m *FightBoutCmd) Reset()                    { *m = FightBoutCmd{} }
func (m *FightBoutCmd) String() string            { return proto.CompactTextString(m) }
func (*FightBoutCmd) ProtoMessage()               {}
func (*FightBoutCmd) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{15} }

func (m *FightBoutCmd) GetUseCardObjID() int32 {
	if m != nil {
		return m.UseCardObjID
	}
	return 0
}

func (m *FightBoutCmd) GetTargetGridId() int32 {
	if m != nil {
		return m.TargetGridId
	}
	return 0
}

type FightBoutResult struct {
	BoutUid              uint64          `protobuf:"varint,1,opt,name=BoutUid,proto3" json:"BoutUid,omitempty"`
	UseCardObjID         int32           `protobuf:"varint,2,opt,name=UseCardObjID,proto3" json:"UseCardObjID,omitempty"`
	TargetGridId         int32           `protobuf:"varint,3,opt,name=TargetGridId,proto3" json:"TargetGridId,omitempty"`
	Actions              []*ClientAction `protobuf:"bytes,4,rep,name=Actions" json:"Actions,omitempty"`
	WinUid               uint64          `protobuf:"varint,5,opt,name=WinUid,proto3" json:"WinUid,omitempty"`
	CardNeedTalk         bool            `protobuf:"varint,6,opt,name=CardNeedTalk,proto3" json:"CardNeedTalk,omitempty"`
	IsUseCardPublicEnemy bool            `protobuf:"varint,7,opt,name=IsUseCardPublicEnemy,proto3" json:"IsUseCardPublicEnemy,omitempty"`
	IsUseCardInFog       bool            `protobuf:"varint,8,opt,name=IsUseCardInFog,proto3" json:"IsUseCardInFog,omitempty"`
	BattleID             uint64          `protobuf:"varint,9,opt,name=BattleID,proto3" json:"BattleID,omitempty"`
}

func (m *FightBoutResult) Reset()                    { *m = FightBoutResult{} }
func (m *FightBoutResult) String() string            { return proto.CompactTextString(m) }
func (*FightBoutResult) ProtoMessage()               {}
func (*FightBoutResult) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{16} }

func (m *FightBoutResult) GetBoutUid() uint64 {
	if m != nil {
		return m.BoutUid
	}
	return 0
}

func (m *FightBoutResult) GetUseCardObjID() int32 {
	if m != nil {
		return m.UseCardObjID
	}
	return 0
}

func (m *FightBoutResult) GetTargetGridId() int32 {
	if m != nil {
		return m.TargetGridId
	}
	return 0
}

func (m *FightBoutResult) GetActions() []*ClientAction {
	if m != nil {
		return m.Actions
	}
	return nil
}

func (m *FightBoutResult) GetWinUid() uint64 {
	if m != nil {
		return m.WinUid
	}
	return 0
}

func (m *FightBoutResult) GetCardNeedTalk() bool {
	if m != nil {
		return m.CardNeedTalk
	}
	return false
}

func (m *FightBoutResult) GetIsUseCardPublicEnemy() bool {
	if m != nil {
		return m.IsUseCardPublicEnemy
	}
	return false
}

func (m *FightBoutResult) GetIsUseCardInFog() bool {
	if m != nil {
		return m.IsUseCardInFog
	}
	return false
}

func (m *FightBoutResult) GetBattleID() uint64 {
	if m != nil {
		return m.BattleID
	}
	return 0
}

type ChangeCardInfo struct {
	Old *CardInfo `protobuf:"bytes,1,opt,name=Old" json:"Old,omitempty"`
	New *CardInfo `protobuf:"bytes,2,opt,name=New" json:"New,omitempty"`
}

func (m *ChangeCardInfo) Reset()                    { *m = ChangeCardInfo{} }
func (m *ChangeCardInfo) String() string            { return proto.CompactTextString(m) }
func (*ChangeCardInfo) ProtoMessage()               {}
func (*ChangeCardInfo) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{17} }

func (m *ChangeCardInfo) GetOld() *CardInfo {
	if m != nil {
		return m.Old
	}
	return nil
}

func (m *ChangeCardInfo) GetNew() *CardInfo {
	if m != nil {
		return m.New
	}
	return nil
}

type ChangeResInfo struct {
	Old *Resource `protobuf:"bytes,1,opt,name=Old" json:"Old,omitempty"`
	New *Resource `protobuf:"bytes,2,opt,name=New" json:"New,omitempty"`
}

func (m *ChangeResInfo) Reset()                    { *m = ChangeResInfo{} }
func (m *ChangeResInfo) String() string            { return proto.CompactTextString(m) }
func (*ChangeResInfo) ProtoMessage()               {}
func (*ChangeResInfo) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{18} }

func (m *ChangeResInfo) GetOld() *Resource {
	if m != nil {
		return m.Old
	}
	return nil
}

func (m *ChangeResInfo) GetNew() *Resource {
	if m != nil {
		return m.New
	}
	return nil
}

type BattleResult struct {
	WinUid                uint64                           `protobuf:"varint,1,opt,name=WinUid,proto3" json:"WinUid,omitempty"`
	ChangeCards           []*ChangeCardInfo                `protobuf:"bytes,2,rep,name=ChangeCards" json:"ChangeCards,omitempty"`
	ChangeRes             []*ChangeResInfo                 `protobuf:"bytes,3,rep,name=ChangeRes" json:"ChangeRes,omitempty"`
	TreasureID            []string                         `protobuf:"bytes,4,rep,name=TreasureID" json:"TreasureID,omitempty"`
	UpPvpLevelRewardCards []uint32                         `protobuf:"varint,5,rep,packed,name=UpPvpLevelRewardCards" json:"UpPvpLevelRewardCards,omitempty"`
	CanShare              bool                             `protobuf:"varint,6,opt,name=CanShare,proto3" json:"CanShare,omitempty"`
	NoTreasureReason      NoTreasureReasonEnum             `protobuf:"varint,7,opt,name=NoTreasureReason,proto3,enum=pb.NoTreasureReasonEnum" json:"NoTreasureReason,omitempty"`
	UpRareTreasureModelID string                           `protobuf:"bytes,8,opt,name=UpRareTreasureModelID,proto3" json:"UpRareTreasureModelID,omitempty"`
	NoSubStarReason       BattleResult_NoSubStarReasonEnum `protobuf:"varint,9,opt,name=NoSubStarReason,proto3,enum=pb.BattleResult_NoSubStarReasonEnum" json:"NoSubStarReason,omitempty"`
}

func (m *BattleResult) Reset()                    { *m = BattleResult{} }
func (m *BattleResult) String() string            { return proto.CompactTextString(m) }
func (*BattleResult) ProtoMessage()               {}
func (*BattleResult) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{19} }

func (m *BattleResult) GetWinUid() uint64 {
	if m != nil {
		return m.WinUid
	}
	return 0
}

func (m *BattleResult) GetChangeCards() []*ChangeCardInfo {
	if m != nil {
		return m.ChangeCards
	}
	return nil
}

func (m *BattleResult) GetChangeRes() []*ChangeResInfo {
	if m != nil {
		return m.ChangeRes
	}
	return nil
}

func (m *BattleResult) GetTreasureID() []string {
	if m != nil {
		return m.TreasureID
	}
	return nil
}

func (m *BattleResult) GetUpPvpLevelRewardCards() []uint32 {
	if m != nil {
		return m.UpPvpLevelRewardCards
	}
	return nil
}

func (m *BattleResult) GetCanShare() bool {
	if m != nil {
		return m.CanShare
	}
	return false
}

func (m *BattleResult) GetNoTreasureReason() NoTreasureReasonEnum {
	if m != nil {
		return m.NoTreasureReason
	}
	return NoTreasureReasonEnum_Unknow
}

func (m *BattleResult) GetUpRareTreasureModelID() string {
	if m != nil {
		return m.UpRareTreasureModelID
	}
	return ""
}

func (m *BattleResult) GetNoSubStarReason() BattleResult_NoSubStarReasonEnum {
	if m != nil {
		return m.NoSubStarReason
	}
	return BattleResult_Normal
}

type LoadFightReq struct {
	DeskID uint64 `protobuf:"varint,1,opt,name=DeskID,proto3" json:"DeskID,omitempty"`
}

func (m *LoadFightReq) Reset()                    { *m = LoadFightReq{} }
func (m *LoadFightReq) String() string            { return proto.CompactTextString(m) }
func (*LoadFightReq) ProtoMessage()               {}
func (*LoadFightReq) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{20} }

func (m *LoadFightReq) GetDeskID() uint64 {
	if m != nil {
		return m.DeskID
	}
	return 0
}

type RestoredFightDesk struct {
	Desk          *FightDesk `protobuf:"bytes,1,opt,name=Desk" json:"Desk,omitempty"`
	CurBoutUid    uint64     `protobuf:"varint,2,opt,name=CurBoutUid,proto3" json:"CurBoutUid,omitempty"`
	CampaignType  int32      `protobuf:"varint,3,opt,name=CampaignType,proto3" json:"CampaignType,omitempty"`
	CampaignLevel int32      `protobuf:"varint,4,opt,name=CampaignLevel,proto3" json:"CampaignLevel,omitempty"`
	LevelID       int32      `protobuf:"varint,5,opt,name=LevelID,proto3" json:"LevelID,omitempty"`
	FieldCnt      int32      `protobuf:"varint,6,opt,name=FieldCnt,proto3" json:"FieldCnt,omitempty"`
	CurBout       int32      `protobuf:"varint,7,opt,name=CurBout,proto3" json:"CurBout,omitempty"`
}

func (m *RestoredFightDesk) Reset()                    { *m = RestoredFightDesk{} }
func (m *RestoredFightDesk) String() string            { return proto.CompactTextString(m) }
func (*RestoredFightDesk) ProtoMessage()               {}
func (*RestoredFightDesk) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{21} }

func (m *RestoredFightDesk) GetDesk() *FightDesk {
	if m != nil {
		return m.Desk
	}
	return nil
}

func (m *RestoredFightDesk) GetCurBoutUid() uint64 {
	if m != nil {
		return m.CurBoutUid
	}
	return 0
}

func (m *RestoredFightDesk) GetCampaignType() int32 {
	if m != nil {
		return m.CampaignType
	}
	return 0
}

func (m *RestoredFightDesk) GetCampaignLevel() int32 {
	if m != nil {
		return m.CampaignLevel
	}
	return 0
}

func (m *RestoredFightDesk) GetLevelID() int32 {
	if m != nil {
		return m.LevelID
	}
	return 0
}

func (m *RestoredFightDesk) GetFieldCnt() int32 {
	if m != nil {
		return m.FieldCnt
	}
	return 0
}

func (m *RestoredFightDesk) GetCurBout() int32 {
	if m != nil {
		return m.CurBout
	}
	return 0
}

type VideoBattleData struct {
	Actions  []*VideoAction `protobuf:"bytes,1,rep,name=Actions" json:"Actions,omitempty"`
	ShareUid uint64         `protobuf:"varint,2,opt,name=ShareUid,proto3" json:"ShareUid,omitempty"`
}

func (m *VideoBattleData) Reset()                    { *m = VideoBattleData{} }
func (m *VideoBattleData) String() string            { return proto.CompactTextString(m) }
func (*VideoBattleData) ProtoMessage()               {}
func (*VideoBattleData) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{22} }

func (m *VideoBattleData) GetActions() []*VideoAction {
	if m != nil {
		return m.Actions
	}
	return nil
}

func (m *VideoBattleData) GetShareUid() uint64 {
	if m != nil {
		return m.ShareUid
	}
	return 0
}

type VideoAction struct {
	ID   VideoAction_ActionID `protobuf:"varint,1,opt,name=ID,proto3,enum=pb.VideoAction_ActionID" json:"ID,omitempty"`
	Data []byte               `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *VideoAction) Reset()                    { *m = VideoAction{} }
func (m *VideoAction) String() string            { return proto.CompactTextString(m) }
func (*VideoAction) ProtoMessage()               {}
func (*VideoAction) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{23} }

func (m *VideoAction) GetID() VideoAction_ActionID {
	if m != nil {
		return m.ID
	}
	return VideoAction_Unknow
}

func (m *VideoAction) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type InGridCard struct {
	GridID  int32  `protobuf:"varint,1,opt,name=GridID,proto3" json:"GridID,omitempty"`
	GCardID uint32 `protobuf:"varint,2,opt,name=GCardID,proto3" json:"GCardID,omitempty"`
	Skin    string `protobuf:"bytes,3,opt,name=Skin,proto3" json:"Skin,omitempty"`
	Equip   string `protobuf:"bytes,4,opt,name=Equip,proto3" json:"Equip,omitempty"`
}

func (m *InGridCard) Reset()                    { *m = InGridCard{} }
func (m *InGridCard) String() string            { return proto.CompactTextString(m) }
func (*InGridCard) ProtoMessage()               {}
func (*InGridCard) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{24} }

func (m *InGridCard) GetGridID() int32 {
	if m != nil {
		return m.GridID
	}
	return 0
}

func (m *InGridCard) GetGCardID() uint32 {
	if m != nil {
		return m.GCardID
	}
	return 0
}

func (m *InGridCard) GetSkin() string {
	if m != nil {
		return m.Skin
	}
	return ""
}

func (m *InGridCard) GetEquip() string {
	if m != nil {
		return m.Equip
	}
	return ""
}

type FighterData struct {
	Uid          uint64        `protobuf:"varint,1,opt,name=Uid,proto3" json:"Uid,omitempty"`
	ClientID     uint64        `protobuf:"varint,2,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	GateID       uint32        `protobuf:"varint,3,opt,name=GateID,proto3" json:"GateID,omitempty"`
	HandCards    []*SkinGCard  `protobuf:"bytes,4,rep,name=HandCards" json:"HandCards,omitempty"`
	DrawCardPool []*SkinGCard  `protobuf:"bytes,5,rep,name=DrawCardPool" json:"DrawCardPool,omitempty"`
	Name         string        `protobuf:"bytes,6,opt,name=Name,proto3" json:"Name,omitempty"`
	Camp         int32         `protobuf:"varint,7,opt,name=Camp,proto3" json:"Camp,omitempty"`
	PvpScore     int32         `protobuf:"varint,8,opt,name=PvpScore,proto3" json:"PvpScore,omitempty"`
	IsRobot      bool          `protobuf:"varint,9,opt,name=IsRobot,proto3" json:"IsRobot,omitempty"`
	GridCards    []*InGridCard `protobuf:"bytes,10,rep,name=GridCards" json:"GridCards,omitempty"`
	CasterSkills []int32       `protobuf:"varint,11,rep,packed,name=CasterSkills" json:"CasterSkills,omitempty"`
	Mmr          int32         `protobuf:"varint,12,opt,name=Mmr,proto3" json:"Mmr,omitempty"`
	RobotID      uint64        `protobuf:"varint,13,opt,name=RobotID,proto3" json:"RobotID,omitempty"`
	HeadImgUrl   string        `protobuf:"bytes,14,opt,name=HeadImgUrl,proto3" json:"HeadImgUrl,omitempty"`
	HeadFrame    string        `protobuf:"bytes,15,opt,name=HeadFrame,proto3" json:"HeadFrame,omitempty"`
	NameText     int32         `protobuf:"varint,16,opt,name=NameText,proto3" json:"NameText,omitempty"`
	WinRate      int32         `protobuf:"varint,17,opt,name=WinRate,proto3" json:"WinRate,omitempty"`
	Area         int32         `protobuf:"varint,18,opt,name=Area,proto3" json:"Area,omitempty"`
	Region       uint32        `protobuf:"varint,19,opt,name=Region,proto3" json:"Region,omitempty"`
	CountryFlag  string        `protobuf:"bytes,20,opt,name=CountryFlag,proto3" json:"CountryFlag,omitempty"`
}

func (m *FighterData) Reset()                    { *m = FighterData{} }
func (m *FighterData) String() string            { return proto.CompactTextString(m) }
func (*FighterData) ProtoMessage()               {}
func (*FighterData) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{25} }

func (m *FighterData) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *FighterData) GetClientID() uint64 {
	if m != nil {
		return m.ClientID
	}
	return 0
}

func (m *FighterData) GetGateID() uint32 {
	if m != nil {
		return m.GateID
	}
	return 0
}

func (m *FighterData) GetHandCards() []*SkinGCard {
	if m != nil {
		return m.HandCards
	}
	return nil
}

func (m *FighterData) GetDrawCardPool() []*SkinGCard {
	if m != nil {
		return m.DrawCardPool
	}
	return nil
}

func (m *FighterData) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FighterData) GetCamp() int32 {
	if m != nil {
		return m.Camp
	}
	return 0
}

func (m *FighterData) GetPvpScore() int32 {
	if m != nil {
		return m.PvpScore
	}
	return 0
}

func (m *FighterData) GetIsRobot() bool {
	if m != nil {
		return m.IsRobot
	}
	return false
}

func (m *FighterData) GetGridCards() []*InGridCard {
	if m != nil {
		return m.GridCards
	}
	return nil
}

func (m *FighterData) GetCasterSkills() []int32 {
	if m != nil {
		return m.CasterSkills
	}
	return nil
}

func (m *FighterData) GetMmr() int32 {
	if m != nil {
		return m.Mmr
	}
	return 0
}

func (m *FighterData) GetRobotID() uint64 {
	if m != nil {
		return m.RobotID
	}
	return 0
}

func (m *FighterData) GetHeadImgUrl() string {
	if m != nil {
		return m.HeadImgUrl
	}
	return ""
}

func (m *FighterData) GetHeadFrame() string {
	if m != nil {
		return m.HeadFrame
	}
	return ""
}

func (m *FighterData) GetNameText() int32 {
	if m != nil {
		return m.NameText
	}
	return 0
}

func (m *FighterData) GetWinRate() int32 {
	if m != nil {
		return m.WinRate
	}
	return 0
}

func (m *FighterData) GetArea() int32 {
	if m != nil {
		return m.Area
	}
	return 0
}

func (m *FighterData) GetRegion() uint32 {
	if m != nil {
		return m.Region
	}
	return 0
}

func (m *FighterData) GetCountryFlag() string {
	if m != nil {
		return m.CountryFlag
	}
	return ""
}

type BeginBattleArg struct {
	BattleType         int32        `protobuf:"varint,1,opt,name=BattleType,proto3" json:"BattleType,omitempty"`
	Fighter1           *FighterData `protobuf:"bytes,2,opt,name=Fighter1" json:"Fighter1,omitempty"`
	Fighter2           *FighterData `protobuf:"bytes,3,opt,name=Fighter2" json:"Fighter2,omitempty"`
	NeedFortifications bool         `protobuf:"varint,4,opt,name=NeedFortifications,proto3" json:"NeedFortifications,omitempty"`
	BonusType          int32        `protobuf:"varint,5,opt,name=BonusType,proto3" json:"BonusType,omitempty"`
	NeedVideo          bool         `protobuf:"varint,6,opt,name=NeedVideo,proto3" json:"NeedVideo,omitempty"`
	UpperType          int32        `protobuf:"varint,7,opt,name=UpperType,proto3" json:"UpperType,omitempty"`
	IsFirstPvp         bool         `protobuf:"varint,8,opt,name=IsFirstPvp,proto3" json:"IsFirstPvp,omitempty"`
	SeasonPvpSession   int32        `protobuf:"varint,9,opt,name=SeasonPvpSession,proto3" json:"SeasonPvpSession,omitempty"`
	IndexDiff          int32        `protobuf:"varint,10,opt,name=IndexDiff,proto3" json:"IndexDiff,omitempty"`
}

func (m *BeginBattleArg) Reset()                    { *m = BeginBattleArg{} }
func (m *BeginBattleArg) String() string            { return proto.CompactTextString(m) }
func (*BeginBattleArg) ProtoMessage()               {}
func (*BeginBattleArg) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{26} }

func (m *BeginBattleArg) GetBattleType() int32 {
	if m != nil {
		return m.BattleType
	}
	return 0
}

func (m *BeginBattleArg) GetFighter1() *FighterData {
	if m != nil {
		return m.Fighter1
	}
	return nil
}

func (m *BeginBattleArg) GetFighter2() *FighterData {
	if m != nil {
		return m.Fighter2
	}
	return nil
}

func (m *BeginBattleArg) GetNeedFortifications() bool {
	if m != nil {
		return m.NeedFortifications
	}
	return false
}

func (m *BeginBattleArg) GetBonusType() int32 {
	if m != nil {
		return m.BonusType
	}
	return 0
}

func (m *BeginBattleArg) GetNeedVideo() bool {
	if m != nil {
		return m.NeedVideo
	}
	return false
}

func (m *BeginBattleArg) GetUpperType() int32 {
	if m != nil {
		return m.UpperType
	}
	return 0
}

func (m *BeginBattleArg) GetIsFirstPvp() bool {
	if m != nil {
		return m.IsFirstPvp
	}
	return false
}

func (m *BeginBattleArg) GetSeasonPvpSession() int32 {
	if m != nil {
		return m.SeasonPvpSession
	}
	return 0
}

func (m *BeginBattleArg) GetIndexDiff() int32 {
	if m != nil {
		return m.IndexDiff
	}
	return 0
}

type BeginLevelBattleArg struct {
	Fighter1 *FighterData `protobuf:"bytes,1,opt,name=Fighter1" json:"Fighter1,omitempty"`
	LevelID  int32        `protobuf:"varint,2,opt,name=LevelID,proto3" json:"LevelID,omitempty"`
}

func (m *BeginLevelBattleArg) Reset()                    { *m = BeginLevelBattleArg{} }
func (m *BeginLevelBattleArg) String() string            { return proto.CompactTextString(m) }
func (*BeginLevelBattleArg) ProtoMessage()               {}
func (*BeginLevelBattleArg) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{27} }

func (m *BeginLevelBattleArg) GetFighter1() *FighterData {
	if m != nil {
		return m.Fighter1
	}
	return nil
}

func (m *BeginLevelBattleArg) GetLevelID() int32 {
	if m != nil {
		return m.LevelID
	}
	return 0
}

type LoadBattleArg struct {
	Uid      uint64 `protobuf:"varint,1,opt,name=Uid,proto3" json:"Uid,omitempty"`
	ClientID uint64 `protobuf:"varint,2,opt,name=ClientID,proto3" json:"ClientID,omitempty"`
	GateID   uint32 `protobuf:"varint,3,opt,name=GateID,proto3" json:"GateID,omitempty"`
	BattleID uint64 `protobuf:"varint,4,opt,name=BattleID,proto3" json:"BattleID,omitempty"`
	Region   uint32 `protobuf:"varint,5,opt,name=Region,proto3" json:"Region,omitempty"`
}

func (m *LoadBattleArg) Reset()                    { *m = LoadBattleArg{} }
func (m *LoadBattleArg) String() string            { return proto.CompactTextString(m) }
func (*LoadBattleArg) ProtoMessage()               {}
func (*LoadBattleArg) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{28} }

func (m *LoadBattleArg) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *LoadBattleArg) GetClientID() uint64 {
	if m != nil {
		return m.ClientID
	}
	return 0
}

func (m *LoadBattleArg) GetGateID() uint32 {
	if m != nil {
		return m.GateID
	}
	return 0
}

func (m *LoadBattleArg) GetBattleID() uint64 {
	if m != nil {
		return m.BattleID
	}
	return 0
}

func (m *LoadBattleArg) GetRegion() uint32 {
	if m != nil {
		return m.Region
	}
	return 0
}

type C2SLoadFightArg struct {
	IsIgnorePve bool `protobuf:"varint,1,opt,name=IsIgnorePve,proto3" json:"IsIgnorePve,omitempty"`
}

func (m *C2SLoadFightArg) Reset()                    { *m = C2SLoadFightArg{} }
func (m *C2SLoadFightArg) String() string            { return proto.CompactTextString(m) }
func (*C2SLoadFightArg) ProtoMessage()               {}
func (*C2SLoadFightArg) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{29} }

func (m *C2SLoadFightArg) GetIsIgnorePve() bool {
	if m != nil {
		return m.IsIgnorePve
	}
	return false
}

type CancelBattleArg struct {
	Uid      uint64 `protobuf:"varint,1,opt,name=Uid,proto3" json:"Uid,omitempty"`
	BattleID uint64 `protobuf:"varint,2,opt,name=BattleID,proto3" json:"BattleID,omitempty"`
}

func (m *CancelBattleArg) Reset()                    { *m = CancelBattleArg{} }
func (m *CancelBattleArg) String() string            { return proto.CompactTextString(m) }
func (*CancelBattleArg) ProtoMessage()               {}
func (*CancelBattleArg) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{30} }

func (m *CancelBattleArg) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *CancelBattleArg) GetBattleID() uint64 {
	if m != nil {
		return m.BattleID
	}
	return 0
}

type LogBattleArg struct {
	BattleID uint64                   `protobuf:"varint,1,opt,name=BattleID,proto3" json:"BattleID,omitempty"`
	Event    LogBattleArg_BattleEvent `protobuf:"varint,2,opt,name=Event,proto3,enum=pb.LogBattleArg_BattleEvent" json:"Event,omitempty"`
	ErrorMsg string                   `protobuf:"bytes,3,opt,name=ErrorMsg,proto3" json:"ErrorMsg,omitempty"`
}

func (m *LogBattleArg) Reset()                    { *m = LogBattleArg{} }
func (m *LogBattleArg) String() string            { return proto.CompactTextString(m) }
func (*LogBattleArg) ProtoMessage()               {}
func (*LogBattleArg) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{31} }

func (m *LogBattleArg) GetBattleID() uint64 {
	if m != nil {
		return m.BattleID
	}
	return 0
}

func (m *LogBattleArg) GetEvent() LogBattleArg_BattleEvent {
	if m != nil {
		return m.Event
	}
	return LogBattleArg_Unknow
}

func (m *LogBattleArg) GetErrorMsg() string {
	if m != nil {
		return m.ErrorMsg
	}
	return ""
}

type OnRobotBattleEndArg struct {
	RobotID uint64 `protobuf:"varint,1,opt,name=RobotID,proto3" json:"RobotID,omitempty"`
	IsWin   bool   `protobuf:"varint,2,opt,name=IsWin,proto3" json:"IsWin,omitempty"`
}

func (m *OnRobotBattleEndArg) Reset()                    { *m = OnRobotBattleEndArg{} }
func (m *OnRobotBattleEndArg) String() string            { return proto.CompactTextString(m) }
func (*OnRobotBattleEndArg) ProtoMessage()               {}
func (*OnRobotBattleEndArg) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{32} }

func (m *OnRobotBattleEndArg) GetRobotID() uint64 {
	if m != nil {
		return m.RobotID
	}
	return 0
}

func (m *OnRobotBattleEndArg) GetIsWin() bool {
	if m != nil {
		return m.IsWin
	}
	return false
}

type ClientAction struct {
	ID   ClientAction_ActionID `protobuf:"varint,1,opt,name=ID,proto3,enum=pb.ClientAction_ActionID" json:"ID,omitempty"`
	Data []byte                `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *ClientAction) Reset()                    { *m = ClientAction{} }
func (m *ClientAction) String() string            { return proto.CompactTextString(m) }
func (*ClientAction) ProtoMessage()               {}
func (*ClientAction) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{33} }

func (m *ClientAction) GetID() ClientAction_ActionID {
	if m != nil {
		return m.ID
	}
	return ClientAction_Unknow
}

func (m *ClientAction) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type AttackAct struct {
	Attacker      int32           `protobuf:"varint,1,opt,name=Attacker,proto3" json:"Attacker,omitempty"`
	WinActs       []*AttackWinAct `protobuf:"bytes,2,rep,name=WinActs" json:"WinActs,omitempty"`
	MoveActs      []*MoveAct      `protobuf:"bytes,3,rep,name=MoveActs" json:"MoveActs,omitempty"`
	AfterMoveActs []*ClientAction `protobuf:"bytes,4,rep,name=AfterMoveActs" json:"AfterMoveActs,omitempty"`
	IsArrow       bool            `protobuf:"varint,5,opt,name=IsArrow,proto3" json:"IsArrow,omitempty"`
}

func (m *AttackAct) Reset()                    { *m = AttackAct{} }
func (m *AttackAct) String() string            { return proto.CompactTextString(m) }
func (*AttackAct) ProtoMessage()               {}
func (*AttackAct) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{34} }

func (m *AttackAct) GetAttacker() int32 {
	if m != nil {
		return m.Attacker
	}
	return 0
}

func (m *AttackAct) GetWinActs() []*AttackWinAct {
	if m != nil {
		return m.WinActs
	}
	return nil
}

func (m *AttackAct) GetMoveActs() []*MoveAct {
	if m != nil {
		return m.MoveActs
	}
	return nil
}

func (m *AttackAct) GetAfterMoveActs() []*ClientAction {
	if m != nil {
		return m.AfterMoveActs
	}
	return nil
}

func (m *AttackAct) GetIsArrow() bool {
	if m != nil {
		return m.IsArrow
	}
	return false
}

type AttackWinAct struct {
	BeAttacker int32 `protobuf:"varint,1,opt,name=BeAttacker,proto3" json:"BeAttacker,omitempty"`
	WinPos     int32 `protobuf:"varint,2,opt,name=WinPos,proto3" json:"WinPos,omitempty"`
	LosePos    int32 `protobuf:"varint,3,opt,name=LosePos,proto3" json:"LosePos,omitempty"`
}

func (m *AttackWinAct) Reset()                    { *m = AttackWinAct{} }
func (m *AttackWinAct) String() string            { return proto.CompactTextString(m) }
func (*AttackWinAct) ProtoMessage()               {}
func (*AttackWinAct) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{35} }

func (m *AttackWinAct) GetBeAttacker() int32 {
	if m != nil {
		return m.BeAttacker
	}
	return 0
}

func (m *AttackWinAct) GetWinPos() int32 {
	if m != nil {
		return m.WinPos
	}
	return 0
}

func (m *AttackWinAct) GetLosePos() int32 {
	if m != nil {
		return m.LosePos
	}
	return 0
}

type MoveAct struct {
	Target     int32  `protobuf:"varint,1,opt,name=Target,proto3" json:"Target,omitempty"`
	TargetGrid int32  `protobuf:"varint,2,opt,name=TargetGrid,proto3" json:"TargetGrid,omitempty"`
	MovieID    string `protobuf:"bytes,3,opt,name=MovieID,proto3" json:"MovieID,omitempty"`
	MovePos    int32  `protobuf:"varint,4,opt,name=MovePos,proto3" json:"MovePos,omitempty"`
	OwnerObjID int32  `protobuf:"varint,5,opt,name=OwnerObjID,proto3" json:"OwnerObjID,omitempty"`
}

func (m *MoveAct) Reset()                    { *m = MoveAct{} }
func (m *MoveAct) String() string            { return proto.CompactTextString(m) }
func (*MoveAct) ProtoMessage()               {}
func (*MoveAct) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{36} }

func (m *MoveAct) GetTarget() int32 {
	if m != nil {
		return m.Target
	}
	return 0
}

func (m *MoveAct) GetTargetGrid() int32 {
	if m != nil {
		return m.TargetGrid
	}
	return 0
}

func (m *MoveAct) GetMovieID() string {
	if m != nil {
		return m.MovieID
	}
	return ""
}

func (m *MoveAct) GetMovePos() int32 {
	if m != nil {
		return m.MovePos
	}
	return 0
}

func (m *MoveAct) GetOwnerObjID() int32 {
	if m != nil {
		return m.OwnerObjID
	}
	return 0
}

type TurnOverAct struct {
	BeTurners []int32 `protobuf:"varint,1,rep,packed,name=BeTurners" json:"BeTurners,omitempty"`
}

func (m *TurnOverAct) Reset()                    { *m = TurnOverAct{} }
func (m *TurnOverAct) String() string            { return proto.CompactTextString(m) }
func (*TurnOverAct) ProtoMessage()               {}
func (*TurnOverAct) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{37} }

func (m *TurnOverAct) GetBeTurners() []int32 {
	if m != nil {
		return m.BeTurners
	}
	return nil
}

type SkillAct struct {
	Owner         int32           `protobuf:"varint,1,opt,name=Owner,proto3" json:"Owner,omitempty"`
	SkillID       int32           `protobuf:"varint,2,opt,name=SkillID,proto3" json:"SkillID,omitempty"`
	Actions       []*ClientAction `protobuf:"bytes,3,rep,name=Actions" json:"Actions,omitempty"`
	MoveActs      []*MoveAct      `protobuf:"bytes,4,rep,name=MoveActs" json:"MoveActs,omitempty"`
	AfterMoveActs []*ClientAction `protobuf:"bytes,5,rep,name=AfterMoveActs" json:"AfterMoveActs,omitempty"`
	IsEquip       bool            `protobuf:"varint,6,opt,name=IsEquip,proto3" json:"IsEquip,omitempty"`
}

func (m *SkillAct) Reset()                    { *m = SkillAct{} }
func (m *SkillAct) String() string            { return proto.CompactTextString(m) }
func (*SkillAct) ProtoMessage()               {}
func (*SkillAct) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{38} }

func (m *SkillAct) GetOwner() int32 {
	if m != nil {
		return m.Owner
	}
	return 0
}

func (m *SkillAct) GetSkillID() int32 {
	if m != nil {
		return m.SkillID
	}
	return 0
}

func (m *SkillAct) GetActions() []*ClientAction {
	if m != nil {
		return m.Actions
	}
	return nil
}

func (m *SkillAct) GetMoveActs() []*MoveAct {
	if m != nil {
		return m.MoveActs
	}
	return nil
}

func (m *SkillAct) GetAfterMoveActs() []*ClientAction {
	if m != nil {
		return m.AfterMoveActs
	}
	return nil
}

func (m *SkillAct) GetIsEquip() bool {
	if m != nil {
		return m.IsEquip
	}
	return false
}

type ModifyValueActItem struct {
	Value   int32   `protobuf:"varint,1,opt,name=Value,proto3" json:"Value,omitempty"`
	Targets []int32 `protobuf:"varint,2,rep,packed,name=Targets" json:"Targets,omitempty"`
}

func (m *ModifyValueActItem) Reset()                    { *m = ModifyValueActItem{} }
func (m *ModifyValueActItem) String() string            { return proto.CompactTextString(m) }
func (*ModifyValueActItem) ProtoMessage()               {}
func (*ModifyValueActItem) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{39} }

func (m *ModifyValueActItem) GetValue() int32 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *ModifyValueActItem) GetTargets() []int32 {
	if m != nil {
		return m.Targets
	}
	return nil
}

type ModifyValueAct struct {
	Items       []*ModifyValueActItem `protobuf:"bytes,1,rep,name=Items" json:"Items,omitempty"`
	ModifyType  int32                 `protobuf:"varint,2,opt,name=ModifyType,proto3" json:"ModifyType,omitempty"`
	McMovieID   string                `protobuf:"bytes,3,opt,name=McMovieID,proto3" json:"McMovieID,omitempty"`
	TextMovieID int32                 `protobuf:"varint,4,opt,name=TextMovieID,proto3" json:"TextMovieID,omitempty"`
	OwnerObjID  int32                 `protobuf:"varint,5,opt,name=OwnerObjID,proto3" json:"OwnerObjID,omitempty"`
}

func (m *ModifyValueAct) Reset()                    { *m = ModifyValueAct{} }
func (m *ModifyValueAct) String() string            { return proto.CompactTextString(m) }
func (*ModifyValueAct) ProtoMessage()               {}
func (*ModifyValueAct) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{40} }

func (m *ModifyValueAct) GetItems() []*ModifyValueActItem {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *ModifyValueAct) GetModifyType() int32 {
	if m != nil {
		return m.ModifyType
	}
	return 0
}

func (m *ModifyValueAct) GetMcMovieID() string {
	if m != nil {
		return m.McMovieID
	}
	return ""
}

func (m *ModifyValueAct) GetTextMovieID() int32 {
	if m != nil {
		return m.TextMovieID
	}
	return 0
}

func (m *ModifyValueAct) GetOwnerObjID() int32 {
	if m != nil {
		return m.OwnerObjID
	}
	return 0
}

type SkillStatusMovieAct struct {
	Type     int32   `protobuf:"varint,1,opt,name=Type,proto3" json:"Type,omitempty"`
	MovieId  string  `protobuf:"bytes,2,opt,name=MovieId,proto3" json:"MovieId,omitempty"`
	Targets  []int32 `protobuf:"varint,3,rep,packed,name=Targets" json:"Targets,omitempty"`
	PlayType int32   `protobuf:"varint,4,opt,name=PlayType,proto3" json:"PlayType,omitempty"`
}

func (m *SkillStatusMovieAct) Reset()                    { *m = SkillStatusMovieAct{} }
func (m *SkillStatusMovieAct) String() string            { return proto.CompactTextString(m) }
func (*SkillStatusMovieAct) ProtoMessage()               {}
func (*SkillStatusMovieAct) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{41} }

func (m *SkillStatusMovieAct) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *SkillStatusMovieAct) GetMovieId() string {
	if m != nil {
		return m.MovieId
	}
	return ""
}

func (m *SkillStatusMovieAct) GetTargets() []int32 {
	if m != nil {
		return m.Targets
	}
	return nil
}

func (m *SkillStatusMovieAct) GetPlayType() int32 {
	if m != nil {
		return m.PlayType
	}
	return 0
}

type MovieAct struct {
	MovieID    string  `protobuf:"bytes,1,opt,name=MovieID,proto3" json:"MovieID,omitempty"`
	Targets    []int32 `protobuf:"varint,2,rep,packed,name=Targets" json:"Targets,omitempty"`
	PlayType   int32   `protobuf:"varint,3,opt,name=PlayType,proto3" json:"PlayType,omitempty"`
	OwnerObjID int32   `protobuf:"varint,4,opt,name=OwnerObjID,proto3" json:"OwnerObjID,omitempty"`
}

func (m *MovieAct) Reset()                    { *m = MovieAct{} }
func (m *MovieAct) String() string            { return proto.CompactTextString(m) }
func (*MovieAct) ProtoMessage()               {}
func (*MovieAct) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{42} }

func (m *MovieAct) GetMovieID() string {
	if m != nil {
		return m.MovieID
	}
	return ""
}

func (m *MovieAct) GetTargets() []int32 {
	if m != nil {
		return m.Targets
	}
	return nil
}

func (m *MovieAct) GetPlayType() int32 {
	if m != nil {
		return m.PlayType
	}
	return 0
}

func (m *MovieAct) GetOwnerObjID() int32 {
	if m != nil {
		return m.OwnerObjID
	}
	return 0
}

type TextMovieAct struct {
	MovieID     int32   `protobuf:"varint,1,opt,name=MovieID,proto3" json:"MovieID,omitempty"`
	Targets     []int32 `protobuf:"varint,2,rep,packed,name=Targets" json:"Targets,omitempty"`
	PlayType    int32   `protobuf:"varint,3,opt,name=PlayType,proto3" json:"PlayType,omitempty"`
	TargetCount int32   `protobuf:"varint,4,opt,name=TargetCount,proto3" json:"TargetCount,omitempty"`
	Value       int32   `protobuf:"varint,5,opt,name=Value,proto3" json:"Value,omitempty"`
	OwnerObjID  int32   `protobuf:"varint,6,opt,name=OwnerObjID,proto3" json:"OwnerObjID,omitempty"`
}

func (m *TextMovieAct) Reset()                    { *m = TextMovieAct{} }
func (m *TextMovieAct) String() string            { return proto.CompactTextString(m) }
func (*TextMovieAct) ProtoMessage()               {}
func (*TextMovieAct) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{43} }

func (m *TextMovieAct) GetMovieID() int32 {
	if m != nil {
		return m.MovieID
	}
	return 0
}

func (m *TextMovieAct) GetTargets() []int32 {
	if m != nil {
		return m.Targets
	}
	return nil
}

func (m *TextMovieAct) GetPlayType() int32 {
	if m != nil {
		return m.PlayType
	}
	return 0
}

func (m *TextMovieAct) GetTargetCount() int32 {
	if m != nil {
		return m.TargetCount
	}
	return 0
}

func (m *TextMovieAct) GetValue() int32 {
	if m != nil {
		return m.Value
	}
	return 0
}

func (m *TextMovieAct) GetOwnerObjID() int32 {
	if m != nil {
		return m.OwnerObjID
	}
	return 0
}

type DrawCardItem struct {
	Uid        uint64  `protobuf:"varint,1,opt,name=Uid,proto3" json:"Uid,omitempty"`
	Cards      []*Card `protobuf:"bytes,2,rep,name=Cards" json:"Cards,omitempty"`
	MovieID    int32   `protobuf:"varint,3,opt,name=MovieID,proto3" json:"MovieID,omitempty"`
	OwnerObjID int32   `protobuf:"varint,4,opt,name=OwnerObjID,proto3" json:"OwnerObjID,omitempty"`
}

func (m *DrawCardItem) Reset()                    { *m = DrawCardItem{} }
func (m *DrawCardItem) String() string            { return proto.CompactTextString(m) }
func (*DrawCardItem) ProtoMessage()               {}
func (*DrawCardItem) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{44} }

func (m *DrawCardItem) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *DrawCardItem) GetCards() []*Card {
	if m != nil {
		return m.Cards
	}
	return nil
}

func (m *DrawCardItem) GetMovieID() int32 {
	if m != nil {
		return m.MovieID
	}
	return 0
}

func (m *DrawCardItem) GetOwnerObjID() int32 {
	if m != nil {
		return m.OwnerObjID
	}
	return 0
}

type DrawCardAct struct {
	Items []*DrawCardItem `protobuf:"bytes,1,rep,name=Items" json:"Items,omitempty"`
}

func (m *DrawCardAct) Reset()                    { *m = DrawCardAct{} }
func (m *DrawCardAct) String() string            { return proto.CompactTextString(m) }
func (*DrawCardAct) ProtoMessage()               {}
func (*DrawCardAct) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{45} }

func (m *DrawCardAct) GetItems() []*DrawCardItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type HandShowAct struct {
	Uid uint64 `protobuf:"varint,1,opt,name=Uid,proto3" json:"Uid,omitempty"`
}

func (m *HandShowAct) Reset()                    { *m = HandShowAct{} }
func (m *HandShowAct) String() string            { return proto.CompactTextString(m) }
func (*HandShowAct) ProtoMessage()               {}
func (*HandShowAct) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{46} }

func (m *HandShowAct) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

type GuanxingAct struct {
	Uids            []uint64 `protobuf:"varint,1,rep,packed,name=Uids" json:"Uids,omitempty"`
	SitOneDrawCards []*Card  `protobuf:"bytes,2,rep,name=SitOneDrawCards" json:"SitOneDrawCards,omitempty"`
	SitTwoDrawCards []*Card  `protobuf:"bytes,3,rep,name=SitTwoDrawCards" json:"SitTwoDrawCards,omitempty"`
}

func (m *GuanxingAct) Reset()                    { *m = GuanxingAct{} }
func (m *GuanxingAct) String() string            { return proto.CompactTextString(m) }
func (*GuanxingAct) ProtoMessage()               {}
func (*GuanxingAct) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{47} }

func (m *GuanxingAct) GetUids() []uint64 {
	if m != nil {
		return m.Uids
	}
	return nil
}

func (m *GuanxingAct) GetSitOneDrawCards() []*Card {
	if m != nil {
		return m.SitOneDrawCards
	}
	return nil
}

func (m *GuanxingAct) GetSitTwoDrawCards() []*Card {
	if m != nil {
		return m.SitTwoDrawCards
	}
	return nil
}

type ModifySkillAct struct {
	CardObjID int32 `protobuf:"varint,1,opt,name=CardObjID,proto3" json:"CardObjID,omitempty"`
	SkillID   int32 `protobuf:"varint,2,opt,name=SkillID,proto3" json:"SkillID,omitempty"`
	IsEquip   bool  `protobuf:"varint,3,opt,name=IsEquip,proto3" json:"IsEquip,omitempty"`
}

func (m *ModifySkillAct) Reset()                    { *m = ModifySkillAct{} }
func (m *ModifySkillAct) String() string            { return proto.CompactTextString(m) }
func (*ModifySkillAct) ProtoMessage()               {}
func (*ModifySkillAct) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{48} }

func (m *ModifySkillAct) GetCardObjID() int32 {
	if m != nil {
		return m.CardObjID
	}
	return 0
}

func (m *ModifySkillAct) GetSkillID() int32 {
	if m != nil {
		return m.SkillID
	}
	return 0
}

func (m *ModifySkillAct) GetIsEquip() bool {
	if m != nil {
		return m.IsEquip
	}
	return false
}

type DisCardActItem struct {
	Uid        uint64  `protobuf:"varint,1,opt,name=Uid,proto3" json:"Uid,omitempty"`
	CardObjIDs []int32 `protobuf:"varint,2,rep,packed,name=CardObjIDs" json:"CardObjIDs,omitempty"`
	MovieID    int32   `protobuf:"varint,3,opt,name=MovieID,proto3" json:"MovieID,omitempty"`
}

func (m *DisCardActItem) Reset()                    { *m = DisCardActItem{} }
func (m *DisCardActItem) String() string            { return proto.CompactTextString(m) }
func (*DisCardActItem) ProtoMessage()               {}
func (*DisCardActItem) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{49} }

func (m *DisCardActItem) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *DisCardActItem) GetCardObjIDs() []int32 {
	if m != nil {
		return m.CardObjIDs
	}
	return nil
}

func (m *DisCardActItem) GetMovieID() int32 {
	if m != nil {
		return m.MovieID
	}
	return 0
}

type DisCardAct struct {
	Items []*DisCardActItem `protobuf:"bytes,1,rep,name=Items" json:"Items,omitempty"`
}

func (m *DisCardAct) Reset()                    { *m = DisCardAct{} }
func (m *DisCardAct) String() string            { return proto.CompactTextString(m) }
func (*DisCardAct) ProtoMessage()               {}
func (*DisCardAct) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{50} }

func (m *DisCardAct) GetItems() []*DisCardActItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type DestroyAct struct {
	Targets []int32 `protobuf:"varint,1,rep,packed,name=Targets" json:"Targets,omitempty"`
}

func (m *DestroyAct) Reset()                    { *m = DestroyAct{} }
func (m *DestroyAct) String() string            { return proto.CompactTextString(m) }
func (*DestroyAct) ProtoMessage()               {}
func (*DestroyAct) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{51} }

func (m *DestroyAct) GetTargets() []int32 {
	if m != nil {
		return m.Targets
	}
	return nil
}

type SummonAct struct {
	Uid           uint64 `protobuf:"varint,1,opt,name=Uid,proto3" json:"Uid,omitempty"`
	GridObjID     int32  `protobuf:"varint,2,opt,name=GridObjID,proto3" json:"GridObjID,omitempty"`
	Card          *Card  `protobuf:"bytes,3,opt,name=Card" json:"Card,omitempty"`
	IsInFog       bool   `protobuf:"varint,4,opt,name=IsInFog,proto3" json:"IsInFog,omitempty"`
	IsPublicEnemy bool   `protobuf:"varint,5,opt,name=IsPublicEnemy,proto3" json:"IsPublicEnemy,omitempty"`
}

func (m *SummonAct) Reset()                    { *m = SummonAct{} }
func (m *SummonAct) String() string            { return proto.CompactTextString(m) }
func (*SummonAct) ProtoMessage()               {}
func (*SummonAct) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{52} }

func (m *SummonAct) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *SummonAct) GetGridObjID() int32 {
	if m != nil {
		return m.GridObjID
	}
	return 0
}

func (m *SummonAct) GetCard() *Card {
	if m != nil {
		return m.Card
	}
	return nil
}

func (m *SummonAct) GetIsInFog() bool {
	if m != nil {
		return m.IsInFog
	}
	return false
}

func (m *SummonAct) GetIsPublicEnemy() bool {
	if m != nil {
		return m.IsPublicEnemy
	}
	return false
}

type ReturnAct struct {
	Uid       uint64 `protobuf:"varint,1,opt,name=Uid,proto3" json:"Uid,omitempty"`
	CardObjID int32  `protobuf:"varint,2,opt,name=CardObjID,proto3" json:"CardObjID,omitempty"`
	Card      *Card  `protobuf:"bytes,3,opt,name=Card" json:"Card,omitempty"`
}

func (m *ReturnAct) Reset()                    { *m = ReturnAct{} }
func (m *ReturnAct) String() string            { return proto.CompactTextString(m) }
func (*ReturnAct) ProtoMessage()               {}
func (*ReturnAct) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{53} }

func (m *ReturnAct) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *ReturnAct) GetCardObjID() int32 {
	if m != nil {
		return m.CardObjID
	}
	return 0
}

func (m *ReturnAct) GetCard() *Card {
	if m != nil {
		return m.Card
	}
	return nil
}

type SwitchPosAct struct {
	Target       int32 `protobuf:"varint,1,opt,name=Target,proto3" json:"Target,omitempty"`
	SwitchTarget int32 `protobuf:"varint,2,opt,name=SwitchTarget,proto3" json:"SwitchTarget,omitempty"`
}

func (m *SwitchPosAct) Reset()                    { *m = SwitchPosAct{} }
func (m *SwitchPosAct) String() string            { return proto.CompactTextString(m) }
func (*SwitchPosAct) ProtoMessage()               {}
func (*SwitchPosAct) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{54} }

func (m *SwitchPosAct) GetTarget() int32 {
	if m != nil {
		return m.Target
	}
	return 0
}

func (m *SwitchPosAct) GetSwitchTarget() int32 {
	if m != nil {
		return m.SwitchTarget
	}
	return 0
}

type BonusReward struct {
	Uid     uint64      `protobuf:"varint,1,opt,name=Uid,proto3" json:"Uid,omitempty"`
	BonusID int32       `protobuf:"varint,2,opt,name=BonusID,proto3" json:"BonusID,omitempty"`
	Res     []*Resource `protobuf:"bytes,3,rep,name=Res" json:"Res,omitempty"`
}

func (m *BonusReward) Reset()                    { *m = BonusReward{} }
func (m *BonusReward) String() string            { return proto.CompactTextString(m) }
func (*BonusReward) ProtoMessage()               {}
func (*BonusReward) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{55} }

func (m *BonusReward) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *BonusReward) GetBonusID() int32 {
	if m != nil {
		return m.BonusID
	}
	return 0
}

func (m *BonusReward) GetRes() []*Resource {
	if m != nil {
		return m.Res
	}
	return nil
}

type BonusAct struct {
	Rewards []*BonusReward `protobuf:"bytes,1,rep,name=Rewards" json:"Rewards,omitempty"`
}

func (m *BonusAct) Reset()                    { *m = BonusAct{} }
func (m *BonusAct) String() string            { return proto.CompactTextString(m) }
func (*BonusAct) ProtoMessage()               {}
func (*BonusAct) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{56} }

func (m *BonusAct) GetRewards() []*BonusReward {
	if m != nil {
		return m.Rewards
	}
	return nil
}

type CopyAct struct {
	Target   int32  `protobuf:"varint,1,opt,name=Target,proto3" json:"Target,omitempty"`
	CopyCard *Card  `protobuf:"bytes,2,opt,name=CopyCard" json:"CopyCard,omitempty"`
	OwnerUid uint64 `protobuf:"varint,3,opt,name=OwnerUid,proto3" json:"OwnerUid,omitempty"`
}

func (m *CopyAct) Reset()                    { *m = CopyAct{} }
func (m *CopyAct) String() string            { return proto.CompactTextString(m) }
func (*CopyAct) ProtoMessage()               {}
func (*CopyAct) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{57} }

func (m *CopyAct) GetTarget() int32 {
	if m != nil {
		return m.Target
	}
	return 0
}

func (m *CopyAct) GetCopyCard() *Card {
	if m != nil {
		return m.CopyCard
	}
	return nil
}

func (m *CopyAct) GetOwnerUid() uint64 {
	if m != nil {
		return m.OwnerUid
	}
	return 0
}

type EnterFogAct struct {
	Target        int32 `protobuf:"varint,1,opt,name=Target,proto3" json:"Target,omitempty"`
	IsPublicEnemy bool  `protobuf:"varint,3,opt,name=IsPublicEnemy,proto3" json:"IsPublicEnemy,omitempty"`
}

func (m *EnterFogAct) Reset()                    { *m = EnterFogAct{} }
func (m *EnterFogAct) String() string            { return proto.CompactTextString(m) }
func (*EnterFogAct) ProtoMessage()               {}
func (*EnterFogAct) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{58} }

func (m *EnterFogAct) GetTarget() int32 {
	if m != nil {
		return m.Target
	}
	return 0
}

func (m *EnterFogAct) GetIsPublicEnemy() bool {
	if m != nil {
		return m.IsPublicEnemy
	}
	return false
}

type LeaveFogAct struct {
	Targets []int32 `protobuf:"varint,1,rep,packed,name=Targets" json:"Targets,omitempty"`
}

func (m *LeaveFogAct) Reset()                    { *m = LeaveFogAct{} }
func (m *LeaveFogAct) String() string            { return proto.CompactTextString(m) }
func (*LeaveFogAct) ProtoMessage()               {}
func (*LeaveFogAct) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{59} }

func (m *LeaveFogAct) GetTargets() []int32 {
	if m != nil {
		return m.Targets
	}
	return nil
}

type GoldGobAct struct {
	Uid      uint64 `protobuf:"varint,1,opt,name=Uid,proto3" json:"Uid,omitempty"`
	Gold     int32  `protobuf:"varint,2,opt,name=Gold,proto3" json:"Gold,omitempty"`
	IsLadder bool   `protobuf:"varint,3,opt,name=IsLadder,proto3" json:"IsLadder,omitempty"`
}

func (m *GoldGobAct) Reset()                    { *m = GoldGobAct{} }
func (m *GoldGobAct) String() string            { return proto.CompactTextString(m) }
func (*GoldGobAct) ProtoMessage()               {}
func (*GoldGobAct) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{60} }

func (m *GoldGobAct) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *GoldGobAct) GetGold() int32 {
	if m != nil {
		return m.Gold
	}
	return 0
}

func (m *GoldGobAct) GetIsLadder() bool {
	if m != nil {
		return m.IsLadder
	}
	return false
}

type SwitchHandCardItem struct {
	Uid          uint64 `protobuf:"varint,1,opt,name=Uid,proto3" json:"Uid,omitempty"`
	DisCardObjID int32  `protobuf:"varint,2,opt,name=DisCardObjID,proto3" json:"DisCardObjID,omitempty"`
	DrawCard     *Card  `protobuf:"bytes,3,opt,name=DrawCard" json:"DrawCard,omitempty"`
	TextMovieID  int32  `protobuf:"varint,4,opt,name=TextMovieID,proto3" json:"TextMovieID,omitempty"`
	McMovieID    string `protobuf:"bytes,5,opt,name=McMovieID,proto3" json:"McMovieID,omitempty"`
}

func (m *SwitchHandCardItem) Reset()                    { *m = SwitchHandCardItem{} }
func (m *SwitchHandCardItem) String() string            { return proto.CompactTextString(m) }
func (*SwitchHandCardItem) ProtoMessage()               {}
func (*SwitchHandCardItem) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{61} }

func (m *SwitchHandCardItem) GetUid() uint64 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *SwitchHandCardItem) GetDisCardObjID() int32 {
	if m != nil {
		return m.DisCardObjID
	}
	return 0
}

func (m *SwitchHandCardItem) GetDrawCard() *Card {
	if m != nil {
		return m.DrawCard
	}
	return nil
}

func (m *SwitchHandCardItem) GetTextMovieID() int32 {
	if m != nil {
		return m.TextMovieID
	}
	return 0
}

func (m *SwitchHandCardItem) GetMcMovieID() string {
	if m != nil {
		return m.McMovieID
	}
	return ""
}

type SwitchHandCardAct struct {
	Items []*SwitchHandCardItem `protobuf:"bytes,1,rep,name=Items" json:"Items,omitempty"`
}

func (m *SwitchHandCardAct) Reset()                    { *m = SwitchHandCardAct{} }
func (m *SwitchHandCardAct) String() string            { return proto.CompactTextString(m) }
func (*SwitchHandCardAct) ProtoMessage()               {}
func (*SwitchHandCardAct) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{62} }

func (m *SwitchHandCardAct) GetItems() []*SwitchHandCardItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type DelEquipAct struct {
	CardObjIDs []int32 `protobuf:"varint,1,rep,packed,name=CardObjIDs" json:"CardObjIDs,omitempty"`
}

func (m *DelEquipAct) Reset()                    { *m = DelEquipAct{} }
func (m *DelEquipAct) String() string            { return proto.CompactTextString(m) }
func (*DelEquipAct) ProtoMessage()               {}
func (*DelEquipAct) Descriptor() ([]byte, []int) { return fileDescriptorBattle, []int{63} }

func (m *DelEquipAct) GetCardObjIDs() []int32 {
	if m != nil {
		return m.CardObjIDs
	}
	return nil
}

func init() {
	proto.RegisterType((*SendEmojiArg)(nil), "pb.SendEmojiArg")
	proto.RegisterType((*MovieEffect)(nil), "pb.MovieEffect")
	proto.RegisterType((*DiyFightCardInfo)(nil), "pb.DiyFightCardInfo")
	proto.RegisterType((*Card)(nil), "pb.Card")
	proto.RegisterType((*BattleEquip)(nil), "pb.BattleEquip")
	proto.RegisterType((*Fighter)(nil), "pb.Fighter")
	proto.RegisterType((*Grid)(nil), "pb.Grid")
	proto.RegisterType((*FightDesk)(nil), "pb.FightDesk")
	proto.RegisterType((*SeasonBattle)(nil), "pb.SeasonBattle")
	proto.RegisterType((*SeasonRandomHand)(nil), "pb.SeasonRandomHand")
	proto.RegisterType((*SeasonBanHand)(nil), "pb.SeasonBanHand")
	proto.RegisterType((*SeasonSwitchHand)(nil), "pb.SeasonSwitchHand")
	proto.RegisterType((*SeasonBattleReady)(nil), "pb.SeasonBattleReady")
	proto.RegisterType((*SeasonBattleBegin)(nil), "pb.SeasonBattleBegin")
	proto.RegisterType((*FightBoutBegin)(nil), "pb.FightBoutBegin")
	proto.RegisterType((*FightBoutCmd)(nil), "pb.FightBoutCmd")
	proto.RegisterType((*FightBoutResult)(nil), "pb.FightBoutResult")
	proto.RegisterType((*ChangeCardInfo)(nil), "pb.ChangeCardInfo")
	proto.RegisterType((*ChangeResInfo)(nil), "pb.ChangeResInfo")
	proto.RegisterType((*BattleResult)(nil), "pb.BattleResult")
	proto.RegisterType((*LoadFightReq)(nil), "pb.LoadFightReq")
	proto.RegisterType((*RestoredFightDesk)(nil), "pb.RestoredFightDesk")
	proto.RegisterType((*VideoBattleData)(nil), "pb.VideoBattleData")
	proto.RegisterType((*VideoAction)(nil), "pb.VideoAction")
	proto.RegisterType((*InGridCard)(nil), "pb.InGridCard")
	proto.RegisterType((*FighterData)(nil), "pb.FighterData")
	proto.RegisterType((*BeginBattleArg)(nil), "pb.BeginBattleArg")
	proto.RegisterType((*BeginLevelBattleArg)(nil), "pb.BeginLevelBattleArg")
	proto.RegisterType((*LoadBattleArg)(nil), "pb.LoadBattleArg")
	proto.RegisterType((*C2SLoadFightArg)(nil), "pb.C2SLoadFightArg")
	proto.RegisterType((*CancelBattleArg)(nil), "pb.CancelBattleArg")
	proto.RegisterType((*LogBattleArg)(nil), "pb.LogBattleArg")
	proto.RegisterType((*OnRobotBattleEndArg)(nil), "pb.OnRobotBattleEndArg")
	proto.RegisterType((*ClientAction)(nil), "pb.ClientAction")
	proto.RegisterType((*AttackAct)(nil), "pb.AttackAct")
	proto.RegisterType((*AttackWinAct)(nil), "pb.AttackWinAct")
	proto.RegisterType((*MoveAct)(nil), "pb.MoveAct")
	proto.RegisterType((*TurnOverAct)(nil), "pb.TurnOverAct")
	proto.RegisterType((*SkillAct)(nil), "pb.SkillAct")
	proto.RegisterType((*ModifyValueActItem)(nil), "pb.ModifyValueActItem")
	proto.RegisterType((*ModifyValueAct)(nil), "pb.ModifyValueAct")
	proto.RegisterType((*SkillStatusMovieAct)(nil), "pb.SkillStatusMovieAct")
	proto.RegisterType((*MovieAct)(nil), "pb.MovieAct")
	proto.RegisterType((*TextMovieAct)(nil), "pb.TextMovieAct")
	proto.RegisterType((*DrawCardItem)(nil), "pb.DrawCardItem")
	proto.RegisterType((*DrawCardAct)(nil), "pb.DrawCardAct")
	proto.RegisterType((*HandShowAct)(nil), "pb.HandShowAct")
	proto.RegisterType((*GuanxingAct)(nil), "pb.GuanxingAct")
	proto.RegisterType((*ModifySkillAct)(nil), "pb.ModifySkillAct")
	proto.RegisterType((*DisCardActItem)(nil), "pb.DisCardActItem")
	proto.RegisterType((*DisCardAct)(nil), "pb.DisCardAct")
	proto.RegisterType((*DestroyAct)(nil), "pb.DestroyAct")
	proto.RegisterType((*SummonAct)(nil), "pb.SummonAct")
	proto.RegisterType((*ReturnAct)(nil), "pb.ReturnAct")
	proto.RegisterType((*SwitchPosAct)(nil), "pb.SwitchPosAct")
	proto.RegisterType((*BonusReward)(nil), "pb.BonusReward")
	proto.RegisterType((*BonusAct)(nil), "pb.BonusAct")
	proto.RegisterType((*CopyAct)(nil), "pb.CopyAct")
	proto.RegisterType((*EnterFogAct)(nil), "pb.EnterFogAct")
	proto.RegisterType((*LeaveFogAct)(nil), "pb.LeaveFogAct")
	proto.RegisterType((*GoldGobAct)(nil), "pb.GoldGobAct")
	proto.RegisterType((*SwitchHandCardItem)(nil), "pb.SwitchHandCardItem")
	proto.RegisterType((*SwitchHandCardAct)(nil), "pb.SwitchHandCardAct")
	proto.RegisterType((*DelEquipAct)(nil), "pb.DelEquipAct")
	proto.RegisterEnum("pb.BattleHandType", BattleHandType_name, BattleHandType_value)
	proto.RegisterEnum("pb.BattleResult_NoSubStarReasonEnum", BattleResult_NoSubStarReasonEnum_name, BattleResult_NoSubStarReasonEnum_value)
	proto.RegisterEnum("pb.VideoAction_ActionID", VideoAction_ActionID_name, VideoAction_ActionID_value)
	proto.RegisterEnum("pb.LogBattleArg_BattleEvent", LogBattleArg_BattleEvent_name, LogBattleArg_BattleEvent_value)
	proto.RegisterEnum("pb.ClientAction_ActionID", ClientAction_ActionID_name, ClientAction_ActionID_value)
}
func (m *SendEmojiArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SendEmojiArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EmojiID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.EmojiID))
	}
	return i, nil
}

func (m *MovieEffect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MovieEffect) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MovieID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBattle(dAtA, i, uint64(len(m.MovieID)))
		i += copy(dAtA[i:], m.MovieID)
	}
	if m.PlayType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.PlayType))
	}
	if m.OwnerObjID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.OwnerObjID))
	}
	return i, nil
}

func (m *DiyFightCardInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiyFightCardInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CardId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.CardId))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBattle(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.DiySkillId1 != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.DiySkillId1))
	}
	if m.DiySkillId2 != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.DiySkillId2))
	}
	if len(m.Weapon) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBattle(dAtA, i, uint64(len(m.Weapon)))
		i += copy(dAtA[i:], m.Weapon)
	}
	return i, nil
}

func (m *Card) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Card) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Id))
	}
	if m.ObjId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.ObjId))
	}
	if m.Up != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Up))
	}
	if m.Down != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Down))
	}
	if m.Left != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Left))
	}
	if m.Right != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Right))
	}
	if m.DiyInfo != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.DiyInfo.Size()))
		n1, err := m.DiyInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Effect) > 0 {
		for _, msg := range m.Effect {
			dAtA[i] = 0x42
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Skills) > 0 {
		dAtA3 := make([]byte, len(m.Skills)*10)
		var j2 int
		for _, num1 := range m.Skills {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		dAtA[i] = 0x4a
		i++
		i = encodeVarintBattle(dAtA, i, uint64(j2))
		i += copy(dAtA[i:], dAtA3[:j2])
	}
	if m.IsInFog {
		dAtA[i] = 0x50
		i++
		if m.IsInFog {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsPublicEnemy {
		dAtA[i] = 0x58
		i++
		if m.IsPublicEnemy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Skin) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintBattle(dAtA, i, uint64(len(m.Skin)))
		i += copy(dAtA[i:], m.Skin)
	}
	if m.Equip != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Equip.Size()))
		n4, err := m.Equip.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *BattleEquip) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BattleEquip) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EquipID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBattle(dAtA, i, uint64(len(m.EquipID)))
		i += copy(dAtA[i:], m.EquipID)
	}
	if len(m.Skills) > 0 {
		dAtA6 := make([]byte, len(m.Skills)*10)
		var j5 int
		for _, num1 := range m.Skills {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintBattle(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	return i, nil
}

func (m *Fighter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Fighter) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Uid))
	}
	if len(m.Hand) > 0 {
		for _, msg := range m.Hand {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ObjId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.ObjId))
	}
	if len(m.CasterSkills) > 0 {
		dAtA8 := make([]byte, len(m.CasterSkills)*10)
		var j7 int
		for _, num1 := range m.CasterSkills {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintBattle(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBattle(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Camp != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Camp))
	}
	if m.PvpScore != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.PvpScore))
	}
	if m.MaxHandAmount != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.MaxHandAmount))
	}
	if len(m.HeadImgUrl) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintBattle(dAtA, i, uint64(len(m.HeadImgUrl)))
		i += copy(dAtA[i:], m.HeadImgUrl)
	}
	if len(m.HeadFrame) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintBattle(dAtA, i, uint64(len(m.HeadFrame)))
		i += copy(dAtA[i:], m.HeadFrame)
	}
	if m.NameText != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.NameText))
	}
	if len(m.CountryFlag) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintBattle(dAtA, i, uint64(len(m.CountryFlag)))
		i += copy(dAtA[i:], m.CountryFlag)
	}
	return i, nil
}

func (m *Grid) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Grid) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ObjId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.ObjId))
	}
	if m.InGridCard != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.InGridCard.Size()))
		n9, err := m.InGridCard.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Owner != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Owner))
	}
	if len(m.Effect) > 0 {
		for _, msg := range m.Effect {
			dAtA[i] = 0x42
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FightDesk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightDesk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DeskId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.DeskId))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Type))
	}
	if len(m.Grids) > 0 {
		for _, msg := range m.Grids {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Fighter1 != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Fighter1.Size()))
		n10, err := m.Fighter1.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Fighter2 != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Fighter2.Size()))
		n11, err := m.Fighter2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Scale != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Scale))
	}
	if m.BattleRes != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.BattleRes))
	}
	if m.IsFirstPvp {
		dAtA[i] = 0x40
		i++
		if m.IsFirstPvp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SeasonBattle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeasonBattle) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Battle != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Battle.Size()))
		n12, err := m.Battle.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.HandType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.HandType))
	}
	if len(m.MyHandCards) > 0 {
		for _, msg := range m.MyHandCards {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Arg) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBattle(dAtA, i, uint64(len(m.Arg)))
		i += copy(dAtA[i:], m.Arg)
	}
	return i, nil
}

func (m *SeasonRandomHand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeasonRandomHand) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChooseAmount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.ChooseAmount))
	}
	if m.RemainTime != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.RemainTime))
	}
	return i, nil
}

func (m *SeasonBanHand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeasonBanHand) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BanMyCardIdxs) > 0 {
		dAtA14 := make([]byte, len(m.BanMyCardIdxs)*10)
		var j13 int
		for _, num1 := range m.BanMyCardIdxs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintBattle(dAtA, i, uint64(j13))
		i += copy(dAtA[i:], dAtA14[:j13])
	}
	if len(m.MyRandomCards) > 0 {
		for _, msg := range m.MyRandomCards {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.BanEnemyCardIdxs) > 0 {
		dAtA16 := make([]byte, len(m.BanEnemyCardIdxs)*10)
		var j15 int
		for _, num1 := range m.BanEnemyCardIdxs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA16[j15] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j15++
			}
			dAtA16[j15] = uint8(num)
			j15++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBattle(dAtA, i, uint64(j15))
		i += copy(dAtA[i:], dAtA16[:j15])
	}
	if len(m.EnemyBanCards) > 0 {
		for _, msg := range m.EnemyBanCards {
			dAtA[i] = 0x22
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SeasonSwitchHand) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeasonSwitchHand) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SwitchMyCardIdxs) > 0 {
		dAtA18 := make([]byte, len(m.SwitchMyCardIdxs)*10)
		var j17 int
		for _, num1 := range m.SwitchMyCardIdxs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintBattle(dAtA, i, uint64(j17))
		i += copy(dAtA[i:], dAtA18[:j17])
	}
	if len(m.SwitchEnemyCardIdxs) > 0 {
		dAtA20 := make([]byte, len(m.SwitchEnemyCardIdxs)*10)
		var j19 int
		for _, num1 := range m.SwitchEnemyCardIdxs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintBattle(dAtA, i, uint64(j19))
		i += copy(dAtA[i:], dAtA20[:j19])
	}
	if len(m.EnemySwitchCards) > 0 {
		for _, msg := range m.EnemySwitchCards {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *SeasonBattleReady) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeasonBattleReady) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChooseCards) > 0 {
		dAtA22 := make([]byte, len(m.ChooseCards)*10)
		var j21 int
		for _, num := range m.ChooseCards {
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBattle(dAtA, i, uint64(j21))
		i += copy(dAtA[i:], dAtA22[:j21])
	}
	return i, nil
}

func (m *SeasonBattleBegin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeasonBattleBegin) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MyHand) > 0 {
		for _, msg := range m.MyHand {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.EnemyHand) > 0 {
		for _, msg := range m.EnemyHand {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FightBoutBegin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightBoutBegin) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BoutUid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.BoutUid))
	}
	if len(m.Actions) > 0 {
		for _, msg := range m.Actions {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.BoutTimeout != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.BoutTimeout))
	}
	if m.BattleID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.BattleID))
	}
	return i, nil
}

func (m *FightBoutCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightBoutCmd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.UseCardObjID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.UseCardObjID))
	}
	if m.TargetGridId != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.TargetGridId))
	}
	return i, nil
}

func (m *FightBoutResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FightBoutResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BoutUid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.BoutUid))
	}
	if m.UseCardObjID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.UseCardObjID))
	}
	if m.TargetGridId != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.TargetGridId))
	}
	if len(m.Actions) > 0 {
		for _, msg := range m.Actions {
			dAtA[i] = 0x22
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.WinUid != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.WinUid))
	}
	if m.CardNeedTalk {
		dAtA[i] = 0x30
		i++
		if m.CardNeedTalk {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsUseCardPublicEnemy {
		dAtA[i] = 0x38
		i++
		if m.IsUseCardPublicEnemy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsUseCardInFog {
		dAtA[i] = 0x40
		i++
		if m.IsUseCardInFog {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BattleID != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.BattleID))
	}
	return i, nil
}

func (m *ChangeCardInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeCardInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Old != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Old.Size()))
		n23, err := m.Old.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.New != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.New.Size()))
		n24, err := m.New.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func (m *ChangeResInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeResInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Old != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Old.Size()))
		n25, err := m.Old.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.New != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.New.Size()))
		n26, err := m.New.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func (m *BattleResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BattleResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.WinUid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.WinUid))
	}
	if len(m.ChangeCards) > 0 {
		for _, msg := range m.ChangeCards {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ChangeRes) > 0 {
		for _, msg := range m.ChangeRes {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.TreasureID) > 0 {
		for _, s := range m.TreasureID {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.UpPvpLevelRewardCards) > 0 {
		dAtA28 := make([]byte, len(m.UpPvpLevelRewardCards)*10)
		var j27 int
		for _, num := range m.UpPvpLevelRewardCards {
			for num >= 1<<7 {
				dAtA28[j27] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j27++
			}
			dAtA28[j27] = uint8(num)
			j27++
		}
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBattle(dAtA, i, uint64(j27))
		i += copy(dAtA[i:], dAtA28[:j27])
	}
	if m.CanShare {
		dAtA[i] = 0x30
		i++
		if m.CanShare {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NoTreasureReason != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.NoTreasureReason))
	}
	if len(m.UpRareTreasureModelID) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintBattle(dAtA, i, uint64(len(m.UpRareTreasureModelID)))
		i += copy(dAtA[i:], m.UpRareTreasureModelID)
	}
	if m.NoSubStarReason != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.NoSubStarReason))
	}
	return i, nil
}

func (m *LoadFightReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadFightReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DeskID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.DeskID))
	}
	return i, nil
}

func (m *RestoredFightDesk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestoredFightDesk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Desk != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Desk.Size()))
		n29, err := m.Desk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.CurBoutUid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.CurBoutUid))
	}
	if m.CampaignType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.CampaignType))
	}
	if m.CampaignLevel != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.CampaignLevel))
	}
	if m.LevelID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.LevelID))
	}
	if m.FieldCnt != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.FieldCnt))
	}
	if m.CurBout != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.CurBout))
	}
	return i, nil
}

func (m *VideoBattleData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoBattleData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Actions) > 0 {
		for _, msg := range m.Actions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ShareUid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.ShareUid))
	}
	return i, nil
}

func (m *VideoAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.ID))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBattle(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *InGridCard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InGridCard) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.GridID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.GridID))
	}
	if m.GCardID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.GCardID))
	}
	if len(m.Skin) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBattle(dAtA, i, uint64(len(m.Skin)))
		i += copy(dAtA[i:], m.Skin)
	}
	if len(m.Equip) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintBattle(dAtA, i, uint64(len(m.Equip)))
		i += copy(dAtA[i:], m.Equip)
	}
	return i, nil
}

func (m *FighterData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FighterData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Uid))
	}
	if m.ClientID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.ClientID))
	}
	if m.GateID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.GateID))
	}
	if len(m.HandCards) > 0 {
		for _, msg := range m.HandCards {
			dAtA[i] = 0x22
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.DrawCardPool) > 0 {
		for _, msg := range m.DrawCardPool {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintBattle(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Camp != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Camp))
	}
	if m.PvpScore != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.PvpScore))
	}
	if m.IsRobot {
		dAtA[i] = 0x48
		i++
		if m.IsRobot {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.GridCards) > 0 {
		for _, msg := range m.GridCards {
			dAtA[i] = 0x52
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.CasterSkills) > 0 {
		dAtA31 := make([]byte, len(m.CasterSkills)*10)
		var j30 int
		for _, num1 := range m.CasterSkills {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA31[j30] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j30++
			}
			dAtA31[j30] = uint8(num)
			j30++
		}
		dAtA[i] = 0x5a
		i++
		i = encodeVarintBattle(dAtA, i, uint64(j30))
		i += copy(dAtA[i:], dAtA31[:j30])
	}
	if m.Mmr != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Mmr))
	}
	if m.RobotID != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.RobotID))
	}
	if len(m.HeadImgUrl) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintBattle(dAtA, i, uint64(len(m.HeadImgUrl)))
		i += copy(dAtA[i:], m.HeadImgUrl)
	}
	if len(m.HeadFrame) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintBattle(dAtA, i, uint64(len(m.HeadFrame)))
		i += copy(dAtA[i:], m.HeadFrame)
	}
	if m.NameText != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.NameText))
	}
	if m.WinRate != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.WinRate))
	}
	if m.Area != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Area))
	}
	if m.Region != 0 {
		dAtA[i] = 0x98
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Region))
	}
	if len(m.CountryFlag) > 0 {
		dAtA[i] = 0xa2
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintBattle(dAtA, i, uint64(len(m.CountryFlag)))
		i += copy(dAtA[i:], m.CountryFlag)
	}
	return i, nil
}

func (m *BeginBattleArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BeginBattleArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BattleType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.BattleType))
	}
	if m.Fighter1 != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Fighter1.Size()))
		n32, err := m.Fighter1.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.Fighter2 != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Fighter2.Size()))
		n33, err := m.Fighter2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.NeedFortifications {
		dAtA[i] = 0x20
		i++
		if m.NeedFortifications {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BonusType != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.BonusType))
	}
	if m.NeedVideo {
		dAtA[i] = 0x30
		i++
		if m.NeedVideo {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.UpperType != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.UpperType))
	}
	if m.IsFirstPvp {
		dAtA[i] = 0x40
		i++
		if m.IsFirstPvp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.SeasonPvpSession != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.SeasonPvpSession))
	}
	if m.IndexDiff != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.IndexDiff))
	}
	return i, nil
}

func (m *BeginLevelBattleArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BeginLevelBattleArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Fighter1 != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Fighter1.Size()))
		n34, err := m.Fighter1.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.LevelID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.LevelID))
	}
	return i, nil
}

func (m *LoadBattleArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoadBattleArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Uid))
	}
	if m.ClientID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.ClientID))
	}
	if m.GateID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.GateID))
	}
	if m.BattleID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.BattleID))
	}
	if m.Region != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Region))
	}
	return i, nil
}

func (m *C2SLoadFightArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *C2SLoadFightArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsIgnorePve {
		dAtA[i] = 0x8
		i++
		if m.IsIgnorePve {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CancelBattleArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelBattleArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Uid))
	}
	if m.BattleID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.BattleID))
	}
	return i, nil
}

func (m *LogBattleArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogBattleArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BattleID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.BattleID))
	}
	if m.Event != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Event))
	}
	if len(m.ErrorMsg) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBattle(dAtA, i, uint64(len(m.ErrorMsg)))
		i += copy(dAtA[i:], m.ErrorMsg)
	}
	return i, nil
}

func (m *OnRobotBattleEndArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OnRobotBattleEndArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RobotID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.RobotID))
	}
	if m.IsWin {
		dAtA[i] = 0x10
		i++
		if m.IsWin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ClientAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.ID))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBattle(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	return i, nil
}

func (m *AttackAct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttackAct) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Attacker != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Attacker))
	}
	if len(m.WinActs) > 0 {
		for _, msg := range m.WinActs {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MoveActs) > 0 {
		for _, msg := range m.MoveActs {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AfterMoveActs) > 0 {
		for _, msg := range m.AfterMoveActs {
			dAtA[i] = 0x22
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.IsArrow {
		dAtA[i] = 0x28
		i++
		if m.IsArrow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *AttackWinAct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttackWinAct) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BeAttacker != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.BeAttacker))
	}
	if m.WinPos != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.WinPos))
	}
	if m.LosePos != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.LosePos))
	}
	return i, nil
}

func (m *MoveAct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MoveAct) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Target != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Target))
	}
	if m.TargetGrid != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.TargetGrid))
	}
	if len(m.MovieID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBattle(dAtA, i, uint64(len(m.MovieID)))
		i += copy(dAtA[i:], m.MovieID)
	}
	if m.MovePos != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.MovePos))
	}
	if m.OwnerObjID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.OwnerObjID))
	}
	return i, nil
}

func (m *TurnOverAct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TurnOverAct) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.BeTurners) > 0 {
		dAtA36 := make([]byte, len(m.BeTurners)*10)
		var j35 int
		for _, num1 := range m.BeTurners {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA36[j35] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j35++
			}
			dAtA36[j35] = uint8(num)
			j35++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintBattle(dAtA, i, uint64(j35))
		i += copy(dAtA[i:], dAtA36[:j35])
	}
	return i, nil
}

func (m *SkillAct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SkillAct) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Owner != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Owner))
	}
	if m.SkillID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.SkillID))
	}
	if len(m.Actions) > 0 {
		for _, msg := range m.Actions {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.MoveActs) > 0 {
		for _, msg := range m.MoveActs {
			dAtA[i] = 0x22
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.AfterMoveActs) > 0 {
		for _, msg := range m.AfterMoveActs {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.IsEquip {
		dAtA[i] = 0x30
		i++
		if m.IsEquip {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ModifyValueActItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModifyValueActItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Value))
	}
	if len(m.Targets) > 0 {
		dAtA38 := make([]byte, len(m.Targets)*10)
		var j37 int
		for _, num1 := range m.Targets {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA38[j37] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j37++
			}
			dAtA38[j37] = uint8(num)
			j37++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintBattle(dAtA, i, uint64(j37))
		i += copy(dAtA[i:], dAtA38[:j37])
	}
	return i, nil
}

func (m *ModifyValueAct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModifyValueAct) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ModifyType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.ModifyType))
	}
	if len(m.McMovieID) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBattle(dAtA, i, uint64(len(m.McMovieID)))
		i += copy(dAtA[i:], m.McMovieID)
	}
	if m.TextMovieID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.TextMovieID))
	}
	if m.OwnerObjID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.OwnerObjID))
	}
	return i, nil
}

func (m *SkillStatusMovieAct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SkillStatusMovieAct) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Type))
	}
	if len(m.MovieId) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBattle(dAtA, i, uint64(len(m.MovieId)))
		i += copy(dAtA[i:], m.MovieId)
	}
	if len(m.Targets) > 0 {
		dAtA40 := make([]byte, len(m.Targets)*10)
		var j39 int
		for _, num1 := range m.Targets {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA40[j39] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j39++
			}
			dAtA40[j39] = uint8(num)
			j39++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBattle(dAtA, i, uint64(j39))
		i += copy(dAtA[i:], dAtA40[:j39])
	}
	if m.PlayType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.PlayType))
	}
	return i, nil
}

func (m *MovieAct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MovieAct) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.MovieID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintBattle(dAtA, i, uint64(len(m.MovieID)))
		i += copy(dAtA[i:], m.MovieID)
	}
	if len(m.Targets) > 0 {
		dAtA42 := make([]byte, len(m.Targets)*10)
		var j41 int
		for _, num1 := range m.Targets {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA42[j41] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j41++
			}
			dAtA42[j41] = uint8(num)
			j41++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintBattle(dAtA, i, uint64(j41))
		i += copy(dAtA[i:], dAtA42[:j41])
	}
	if m.PlayType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.PlayType))
	}
	if m.OwnerObjID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.OwnerObjID))
	}
	return i, nil
}

func (m *TextMovieAct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TextMovieAct) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MovieID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.MovieID))
	}
	if len(m.Targets) > 0 {
		dAtA44 := make([]byte, len(m.Targets)*10)
		var j43 int
		for _, num1 := range m.Targets {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA44[j43] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j43++
			}
			dAtA44[j43] = uint8(num)
			j43++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintBattle(dAtA, i, uint64(j43))
		i += copy(dAtA[i:], dAtA44[:j43])
	}
	if m.PlayType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.PlayType))
	}
	if m.TargetCount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.TargetCount))
	}
	if m.Value != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Value))
	}
	if m.OwnerObjID != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.OwnerObjID))
	}
	return i, nil
}

func (m *DrawCardItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DrawCardItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Uid))
	}
	if len(m.Cards) > 0 {
		for _, msg := range m.Cards {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.MovieID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.MovieID))
	}
	if m.OwnerObjID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.OwnerObjID))
	}
	return i, nil
}

func (m *DrawCardAct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DrawCardAct) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *HandShowAct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HandShowAct) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Uid))
	}
	return i, nil
}

func (m *GuanxingAct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GuanxingAct) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uids) > 0 {
		dAtA46 := make([]byte, len(m.Uids)*10)
		var j45 int
		for _, num := range m.Uids {
			for num >= 1<<7 {
				dAtA46[j45] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j45++
			}
			dAtA46[j45] = uint8(num)
			j45++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintBattle(dAtA, i, uint64(j45))
		i += copy(dAtA[i:], dAtA46[:j45])
	}
	if len(m.SitOneDrawCards) > 0 {
		for _, msg := range m.SitOneDrawCards {
			dAtA[i] = 0x12
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SitTwoDrawCards) > 0 {
		for _, msg := range m.SitTwoDrawCards {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ModifySkillAct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModifySkillAct) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CardObjID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.CardObjID))
	}
	if m.SkillID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.SkillID))
	}
	if m.IsEquip {
		dAtA[i] = 0x18
		i++
		if m.IsEquip {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DisCardActItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DisCardActItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Uid))
	}
	if len(m.CardObjIDs) > 0 {
		dAtA48 := make([]byte, len(m.CardObjIDs)*10)
		var j47 int
		for _, num1 := range m.CardObjIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA48[j47] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j47++
			}
			dAtA48[j47] = uint8(num)
			j47++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintBattle(dAtA, i, uint64(j47))
		i += copy(dAtA[i:], dAtA48[:j47])
	}
	if m.MovieID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.MovieID))
	}
	return i, nil
}

func (m *DisCardAct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DisCardAct) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DestroyAct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DestroyAct) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Targets) > 0 {
		dAtA50 := make([]byte, len(m.Targets)*10)
		var j49 int
		for _, num1 := range m.Targets {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA50[j49] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j49++
			}
			dAtA50[j49] = uint8(num)
			j49++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintBattle(dAtA, i, uint64(j49))
		i += copy(dAtA[i:], dAtA50[:j49])
	}
	return i, nil
}

func (m *SummonAct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SummonAct) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Uid))
	}
	if m.GridObjID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.GridObjID))
	}
	if m.Card != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Card.Size()))
		n51, err := m.Card.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if m.IsInFog {
		dAtA[i] = 0x20
		i++
		if m.IsInFog {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.IsPublicEnemy {
		dAtA[i] = 0x28
		i++
		if m.IsPublicEnemy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *ReturnAct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReturnAct) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Uid))
	}
	if m.CardObjID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.CardObjID))
	}
	if m.Card != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Card.Size()))
		n52, err := m.Card.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	return i, nil
}

func (m *SwitchPosAct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwitchPosAct) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Target != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Target))
	}
	if m.SwitchTarget != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.SwitchTarget))
	}
	return i, nil
}

func (m *BonusReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BonusReward) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Uid))
	}
	if m.BonusID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.BonusID))
	}
	if len(m.Res) > 0 {
		for _, msg := range m.Res {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *BonusAct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BonusAct) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Rewards) > 0 {
		for _, msg := range m.Rewards {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CopyAct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CopyAct) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Target != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Target))
	}
	if m.CopyCard != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.CopyCard.Size()))
		n53, err := m.CopyCard.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if m.OwnerUid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.OwnerUid))
	}
	return i, nil
}

func (m *EnterFogAct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnterFogAct) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Target != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Target))
	}
	if m.IsPublicEnemy {
		dAtA[i] = 0x18
		i++
		if m.IsPublicEnemy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *LeaveFogAct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeaveFogAct) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Targets) > 0 {
		dAtA55 := make([]byte, len(m.Targets)*10)
		var j54 int
		for _, num1 := range m.Targets {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA55[j54] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j54++
			}
			dAtA55[j54] = uint8(num)
			j54++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintBattle(dAtA, i, uint64(j54))
		i += copy(dAtA[i:], dAtA55[:j54])
	}
	return i, nil
}

func (m *GoldGobAct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GoldGobAct) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Uid))
	}
	if m.Gold != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Gold))
	}
	if m.IsLadder {
		dAtA[i] = 0x18
		i++
		if m.IsLadder {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SwitchHandCardItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwitchHandCardItem) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.Uid))
	}
	if m.DisCardObjID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.DisCardObjID))
	}
	if m.DrawCard != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.DrawCard.Size()))
		n56, err := m.DrawCard.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	if m.TextMovieID != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintBattle(dAtA, i, uint64(m.TextMovieID))
	}
	if len(m.McMovieID) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintBattle(dAtA, i, uint64(len(m.McMovieID)))
		i += copy(dAtA[i:], m.McMovieID)
	}
	return i, nil
}

func (m *SwitchHandCardAct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SwitchHandCardAct) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarintBattle(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DelEquipAct) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelEquipAct) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CardObjIDs) > 0 {
		dAtA58 := make([]byte, len(m.CardObjIDs)*10)
		var j57 int
		for _, num1 := range m.CardObjIDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA58[j57] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j57++
			}
			dAtA58[j57] = uint8(num)
			j57++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintBattle(dAtA, i, uint64(j57))
		i += copy(dAtA[i:], dAtA58[:j57])
	}
	return i, nil
}

func encodeVarintBattle(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *SendEmojiArg) Size() (n int) {
	var l int
	_ = l
	if m.EmojiID != 0 {
		n += 1 + sovBattle(uint64(m.EmojiID))
	}
	return n
}

func (m *MovieEffect) Size() (n int) {
	var l int
	_ = l
	l = len(m.MovieID)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	if m.PlayType != 0 {
		n += 1 + sovBattle(uint64(m.PlayType))
	}
	if m.OwnerObjID != 0 {
		n += 1 + sovBattle(uint64(m.OwnerObjID))
	}
	return n
}

func (m *DiyFightCardInfo) Size() (n int) {
	var l int
	_ = l
	if m.CardId != 0 {
		n += 1 + sovBattle(uint64(m.CardId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	if m.DiySkillId1 != 0 {
		n += 1 + sovBattle(uint64(m.DiySkillId1))
	}
	if m.DiySkillId2 != 0 {
		n += 1 + sovBattle(uint64(m.DiySkillId2))
	}
	l = len(m.Weapon)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	return n
}

func (m *Card) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBattle(uint64(m.Id))
	}
	if m.ObjId != 0 {
		n += 1 + sovBattle(uint64(m.ObjId))
	}
	if m.Up != 0 {
		n += 1 + sovBattle(uint64(m.Up))
	}
	if m.Down != 0 {
		n += 1 + sovBattle(uint64(m.Down))
	}
	if m.Left != 0 {
		n += 1 + sovBattle(uint64(m.Left))
	}
	if m.Right != 0 {
		n += 1 + sovBattle(uint64(m.Right))
	}
	if m.DiyInfo != nil {
		l = m.DiyInfo.Size()
		n += 1 + l + sovBattle(uint64(l))
	}
	if len(m.Effect) > 0 {
		for _, e := range m.Effect {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	if len(m.Skills) > 0 {
		l = 0
		for _, e := range m.Skills {
			l += sovBattle(uint64(e))
		}
		n += 1 + sovBattle(uint64(l)) + l
	}
	if m.IsInFog {
		n += 2
	}
	if m.IsPublicEnemy {
		n += 2
	}
	l = len(m.Skin)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	if m.Equip != nil {
		l = m.Equip.Size()
		n += 1 + l + sovBattle(uint64(l))
	}
	return n
}

func (m *BattleEquip) Size() (n int) {
	var l int
	_ = l
	l = len(m.EquipID)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	if len(m.Skills) > 0 {
		l = 0
		for _, e := range m.Skills {
			l += sovBattle(uint64(e))
		}
		n += 1 + sovBattle(uint64(l)) + l
	}
	return n
}

func (m *Fighter) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBattle(uint64(m.Uid))
	}
	if len(m.Hand) > 0 {
		for _, e := range m.Hand {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	if m.ObjId != 0 {
		n += 1 + sovBattle(uint64(m.ObjId))
	}
	if len(m.CasterSkills) > 0 {
		l = 0
		for _, e := range m.CasterSkills {
			l += sovBattle(uint64(e))
		}
		n += 1 + sovBattle(uint64(l)) + l
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	if m.Camp != 0 {
		n += 1 + sovBattle(uint64(m.Camp))
	}
	if m.PvpScore != 0 {
		n += 1 + sovBattle(uint64(m.PvpScore))
	}
	if m.MaxHandAmount != 0 {
		n += 1 + sovBattle(uint64(m.MaxHandAmount))
	}
	l = len(m.HeadImgUrl)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	l = len(m.HeadFrame)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	if m.NameText != 0 {
		n += 1 + sovBattle(uint64(m.NameText))
	}
	l = len(m.CountryFlag)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	return n
}

func (m *Grid) Size() (n int) {
	var l int
	_ = l
	if m.ObjId != 0 {
		n += 1 + sovBattle(uint64(m.ObjId))
	}
	if m.InGridCard != nil {
		l = m.InGridCard.Size()
		n += 1 + l + sovBattle(uint64(l))
	}
	if m.Owner != 0 {
		n += 1 + sovBattle(uint64(m.Owner))
	}
	if len(m.Effect) > 0 {
		for _, e := range m.Effect {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	return n
}

func (m *FightDesk) Size() (n int) {
	var l int
	_ = l
	if m.DeskId != 0 {
		n += 1 + sovBattle(uint64(m.DeskId))
	}
	if m.Type != 0 {
		n += 1 + sovBattle(uint64(m.Type))
	}
	if len(m.Grids) > 0 {
		for _, e := range m.Grids {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	if m.Fighter1 != nil {
		l = m.Fighter1.Size()
		n += 1 + l + sovBattle(uint64(l))
	}
	if m.Fighter2 != nil {
		l = m.Fighter2.Size()
		n += 1 + l + sovBattle(uint64(l))
	}
	if m.Scale != 0 {
		n += 1 + sovBattle(uint64(m.Scale))
	}
	if m.BattleRes != 0 {
		n += 1 + sovBattle(uint64(m.BattleRes))
	}
	if m.IsFirstPvp {
		n += 2
	}
	return n
}

func (m *SeasonBattle) Size() (n int) {
	var l int
	_ = l
	if m.Battle != nil {
		l = m.Battle.Size()
		n += 1 + l + sovBattle(uint64(l))
	}
	if m.HandType != 0 {
		n += 1 + sovBattle(uint64(m.HandType))
	}
	if len(m.MyHandCards) > 0 {
		for _, e := range m.MyHandCards {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	l = len(m.Arg)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	return n
}

func (m *SeasonRandomHand) Size() (n int) {
	var l int
	_ = l
	if m.ChooseAmount != 0 {
		n += 1 + sovBattle(uint64(m.ChooseAmount))
	}
	if m.RemainTime != 0 {
		n += 1 + sovBattle(uint64(m.RemainTime))
	}
	return n
}

func (m *SeasonBanHand) Size() (n int) {
	var l int
	_ = l
	if len(m.BanMyCardIdxs) > 0 {
		l = 0
		for _, e := range m.BanMyCardIdxs {
			l += sovBattle(uint64(e))
		}
		n += 1 + sovBattle(uint64(l)) + l
	}
	if len(m.MyRandomCards) > 0 {
		for _, e := range m.MyRandomCards {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	if len(m.BanEnemyCardIdxs) > 0 {
		l = 0
		for _, e := range m.BanEnemyCardIdxs {
			l += sovBattle(uint64(e))
		}
		n += 1 + sovBattle(uint64(l)) + l
	}
	if len(m.EnemyBanCards) > 0 {
		for _, e := range m.EnemyBanCards {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	return n
}

func (m *SeasonSwitchHand) Size() (n int) {
	var l int
	_ = l
	if len(m.SwitchMyCardIdxs) > 0 {
		l = 0
		for _, e := range m.SwitchMyCardIdxs {
			l += sovBattle(uint64(e))
		}
		n += 1 + sovBattle(uint64(l)) + l
	}
	if len(m.SwitchEnemyCardIdxs) > 0 {
		l = 0
		for _, e := range m.SwitchEnemyCardIdxs {
			l += sovBattle(uint64(e))
		}
		n += 1 + sovBattle(uint64(l)) + l
	}
	if len(m.EnemySwitchCards) > 0 {
		for _, e := range m.EnemySwitchCards {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	return n
}

func (m *SeasonBattleReady) Size() (n int) {
	var l int
	_ = l
	if len(m.ChooseCards) > 0 {
		l = 0
		for _, e := range m.ChooseCards {
			l += sovBattle(uint64(e))
		}
		n += 1 + sovBattle(uint64(l)) + l
	}
	return n
}

func (m *SeasonBattleBegin) Size() (n int) {
	var l int
	_ = l
	if len(m.MyHand) > 0 {
		for _, e := range m.MyHand {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	if len(m.EnemyHand) > 0 {
		for _, e := range m.EnemyHand {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	return n
}

func (m *FightBoutBegin) Size() (n int) {
	var l int
	_ = l
	if m.BoutUid != 0 {
		n += 1 + sovBattle(uint64(m.BoutUid))
	}
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	if m.BoutTimeout != 0 {
		n += 1 + sovBattle(uint64(m.BoutTimeout))
	}
	if m.BattleID != 0 {
		n += 1 + sovBattle(uint64(m.BattleID))
	}
	return n
}

func (m *FightBoutCmd) Size() (n int) {
	var l int
	_ = l
	if m.UseCardObjID != 0 {
		n += 1 + sovBattle(uint64(m.UseCardObjID))
	}
	if m.TargetGridId != 0 {
		n += 1 + sovBattle(uint64(m.TargetGridId))
	}
	return n
}

func (m *FightBoutResult) Size() (n int) {
	var l int
	_ = l
	if m.BoutUid != 0 {
		n += 1 + sovBattle(uint64(m.BoutUid))
	}
	if m.UseCardObjID != 0 {
		n += 1 + sovBattle(uint64(m.UseCardObjID))
	}
	if m.TargetGridId != 0 {
		n += 1 + sovBattle(uint64(m.TargetGridId))
	}
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	if m.WinUid != 0 {
		n += 1 + sovBattle(uint64(m.WinUid))
	}
	if m.CardNeedTalk {
		n += 2
	}
	if m.IsUseCardPublicEnemy {
		n += 2
	}
	if m.IsUseCardInFog {
		n += 2
	}
	if m.BattleID != 0 {
		n += 1 + sovBattle(uint64(m.BattleID))
	}
	return n
}

func (m *ChangeCardInfo) Size() (n int) {
	var l int
	_ = l
	if m.Old != nil {
		l = m.Old.Size()
		n += 1 + l + sovBattle(uint64(l))
	}
	if m.New != nil {
		l = m.New.Size()
		n += 1 + l + sovBattle(uint64(l))
	}
	return n
}

func (m *ChangeResInfo) Size() (n int) {
	var l int
	_ = l
	if m.Old != nil {
		l = m.Old.Size()
		n += 1 + l + sovBattle(uint64(l))
	}
	if m.New != nil {
		l = m.New.Size()
		n += 1 + l + sovBattle(uint64(l))
	}
	return n
}

func (m *BattleResult) Size() (n int) {
	var l int
	_ = l
	if m.WinUid != 0 {
		n += 1 + sovBattle(uint64(m.WinUid))
	}
	if len(m.ChangeCards) > 0 {
		for _, e := range m.ChangeCards {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	if len(m.ChangeRes) > 0 {
		for _, e := range m.ChangeRes {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	if len(m.TreasureID) > 0 {
		for _, s := range m.TreasureID {
			l = len(s)
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	if len(m.UpPvpLevelRewardCards) > 0 {
		l = 0
		for _, e := range m.UpPvpLevelRewardCards {
			l += sovBattle(uint64(e))
		}
		n += 1 + sovBattle(uint64(l)) + l
	}
	if m.CanShare {
		n += 2
	}
	if m.NoTreasureReason != 0 {
		n += 1 + sovBattle(uint64(m.NoTreasureReason))
	}
	l = len(m.UpRareTreasureModelID)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	if m.NoSubStarReason != 0 {
		n += 1 + sovBattle(uint64(m.NoSubStarReason))
	}
	return n
}

func (m *LoadFightReq) Size() (n int) {
	var l int
	_ = l
	if m.DeskID != 0 {
		n += 1 + sovBattle(uint64(m.DeskID))
	}
	return n
}

func (m *RestoredFightDesk) Size() (n int) {
	var l int
	_ = l
	if m.Desk != nil {
		l = m.Desk.Size()
		n += 1 + l + sovBattle(uint64(l))
	}
	if m.CurBoutUid != 0 {
		n += 1 + sovBattle(uint64(m.CurBoutUid))
	}
	if m.CampaignType != 0 {
		n += 1 + sovBattle(uint64(m.CampaignType))
	}
	if m.CampaignLevel != 0 {
		n += 1 + sovBattle(uint64(m.CampaignLevel))
	}
	if m.LevelID != 0 {
		n += 1 + sovBattle(uint64(m.LevelID))
	}
	if m.FieldCnt != 0 {
		n += 1 + sovBattle(uint64(m.FieldCnt))
	}
	if m.CurBout != 0 {
		n += 1 + sovBattle(uint64(m.CurBout))
	}
	return n
}

func (m *VideoBattleData) Size() (n int) {
	var l int
	_ = l
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	if m.ShareUid != 0 {
		n += 1 + sovBattle(uint64(m.ShareUid))
	}
	return n
}

func (m *VideoAction) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovBattle(uint64(m.ID))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	return n
}

func (m *InGridCard) Size() (n int) {
	var l int
	_ = l
	if m.GridID != 0 {
		n += 1 + sovBattle(uint64(m.GridID))
	}
	if m.GCardID != 0 {
		n += 1 + sovBattle(uint64(m.GCardID))
	}
	l = len(m.Skin)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	l = len(m.Equip)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	return n
}

func (m *FighterData) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBattle(uint64(m.Uid))
	}
	if m.ClientID != 0 {
		n += 1 + sovBattle(uint64(m.ClientID))
	}
	if m.GateID != 0 {
		n += 1 + sovBattle(uint64(m.GateID))
	}
	if len(m.HandCards) > 0 {
		for _, e := range m.HandCards {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	if len(m.DrawCardPool) > 0 {
		for _, e := range m.DrawCardPool {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	if m.Camp != 0 {
		n += 1 + sovBattle(uint64(m.Camp))
	}
	if m.PvpScore != 0 {
		n += 1 + sovBattle(uint64(m.PvpScore))
	}
	if m.IsRobot {
		n += 2
	}
	if len(m.GridCards) > 0 {
		for _, e := range m.GridCards {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	if len(m.CasterSkills) > 0 {
		l = 0
		for _, e := range m.CasterSkills {
			l += sovBattle(uint64(e))
		}
		n += 1 + sovBattle(uint64(l)) + l
	}
	if m.Mmr != 0 {
		n += 1 + sovBattle(uint64(m.Mmr))
	}
	if m.RobotID != 0 {
		n += 1 + sovBattle(uint64(m.RobotID))
	}
	l = len(m.HeadImgUrl)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	l = len(m.HeadFrame)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	if m.NameText != 0 {
		n += 2 + sovBattle(uint64(m.NameText))
	}
	if m.WinRate != 0 {
		n += 2 + sovBattle(uint64(m.WinRate))
	}
	if m.Area != 0 {
		n += 2 + sovBattle(uint64(m.Area))
	}
	if m.Region != 0 {
		n += 2 + sovBattle(uint64(m.Region))
	}
	l = len(m.CountryFlag)
	if l > 0 {
		n += 2 + l + sovBattle(uint64(l))
	}
	return n
}

func (m *BeginBattleArg) Size() (n int) {
	var l int
	_ = l
	if m.BattleType != 0 {
		n += 1 + sovBattle(uint64(m.BattleType))
	}
	if m.Fighter1 != nil {
		l = m.Fighter1.Size()
		n += 1 + l + sovBattle(uint64(l))
	}
	if m.Fighter2 != nil {
		l = m.Fighter2.Size()
		n += 1 + l + sovBattle(uint64(l))
	}
	if m.NeedFortifications {
		n += 2
	}
	if m.BonusType != 0 {
		n += 1 + sovBattle(uint64(m.BonusType))
	}
	if m.NeedVideo {
		n += 2
	}
	if m.UpperType != 0 {
		n += 1 + sovBattle(uint64(m.UpperType))
	}
	if m.IsFirstPvp {
		n += 2
	}
	if m.SeasonPvpSession != 0 {
		n += 1 + sovBattle(uint64(m.SeasonPvpSession))
	}
	if m.IndexDiff != 0 {
		n += 1 + sovBattle(uint64(m.IndexDiff))
	}
	return n
}

func (m *BeginLevelBattleArg) Size() (n int) {
	var l int
	_ = l
	if m.Fighter1 != nil {
		l = m.Fighter1.Size()
		n += 1 + l + sovBattle(uint64(l))
	}
	if m.LevelID != 0 {
		n += 1 + sovBattle(uint64(m.LevelID))
	}
	return n
}

func (m *LoadBattleArg) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBattle(uint64(m.Uid))
	}
	if m.ClientID != 0 {
		n += 1 + sovBattle(uint64(m.ClientID))
	}
	if m.GateID != 0 {
		n += 1 + sovBattle(uint64(m.GateID))
	}
	if m.BattleID != 0 {
		n += 1 + sovBattle(uint64(m.BattleID))
	}
	if m.Region != 0 {
		n += 1 + sovBattle(uint64(m.Region))
	}
	return n
}

func (m *C2SLoadFightArg) Size() (n int) {
	var l int
	_ = l
	if m.IsIgnorePve {
		n += 2
	}
	return n
}

func (m *CancelBattleArg) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBattle(uint64(m.Uid))
	}
	if m.BattleID != 0 {
		n += 1 + sovBattle(uint64(m.BattleID))
	}
	return n
}

func (m *LogBattleArg) Size() (n int) {
	var l int
	_ = l
	if m.BattleID != 0 {
		n += 1 + sovBattle(uint64(m.BattleID))
	}
	if m.Event != 0 {
		n += 1 + sovBattle(uint64(m.Event))
	}
	l = len(m.ErrorMsg)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	return n
}

func (m *OnRobotBattleEndArg) Size() (n int) {
	var l int
	_ = l
	if m.RobotID != 0 {
		n += 1 + sovBattle(uint64(m.RobotID))
	}
	if m.IsWin {
		n += 2
	}
	return n
}

func (m *ClientAction) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovBattle(uint64(m.ID))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	return n
}

func (m *AttackAct) Size() (n int) {
	var l int
	_ = l
	if m.Attacker != 0 {
		n += 1 + sovBattle(uint64(m.Attacker))
	}
	if len(m.WinActs) > 0 {
		for _, e := range m.WinActs {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	if len(m.MoveActs) > 0 {
		for _, e := range m.MoveActs {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	if len(m.AfterMoveActs) > 0 {
		for _, e := range m.AfterMoveActs {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	if m.IsArrow {
		n += 2
	}
	return n
}

func (m *AttackWinAct) Size() (n int) {
	var l int
	_ = l
	if m.BeAttacker != 0 {
		n += 1 + sovBattle(uint64(m.BeAttacker))
	}
	if m.WinPos != 0 {
		n += 1 + sovBattle(uint64(m.WinPos))
	}
	if m.LosePos != 0 {
		n += 1 + sovBattle(uint64(m.LosePos))
	}
	return n
}

func (m *MoveAct) Size() (n int) {
	var l int
	_ = l
	if m.Target != 0 {
		n += 1 + sovBattle(uint64(m.Target))
	}
	if m.TargetGrid != 0 {
		n += 1 + sovBattle(uint64(m.TargetGrid))
	}
	l = len(m.MovieID)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	if m.MovePos != 0 {
		n += 1 + sovBattle(uint64(m.MovePos))
	}
	if m.OwnerObjID != 0 {
		n += 1 + sovBattle(uint64(m.OwnerObjID))
	}
	return n
}

func (m *TurnOverAct) Size() (n int) {
	var l int
	_ = l
	if len(m.BeTurners) > 0 {
		l = 0
		for _, e := range m.BeTurners {
			l += sovBattle(uint64(e))
		}
		n += 1 + sovBattle(uint64(l)) + l
	}
	return n
}

func (m *SkillAct) Size() (n int) {
	var l int
	_ = l
	if m.Owner != 0 {
		n += 1 + sovBattle(uint64(m.Owner))
	}
	if m.SkillID != 0 {
		n += 1 + sovBattle(uint64(m.SkillID))
	}
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	if len(m.MoveActs) > 0 {
		for _, e := range m.MoveActs {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	if len(m.AfterMoveActs) > 0 {
		for _, e := range m.AfterMoveActs {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	if m.IsEquip {
		n += 2
	}
	return n
}

func (m *ModifyValueActItem) Size() (n int) {
	var l int
	_ = l
	if m.Value != 0 {
		n += 1 + sovBattle(uint64(m.Value))
	}
	if len(m.Targets) > 0 {
		l = 0
		for _, e := range m.Targets {
			l += sovBattle(uint64(e))
		}
		n += 1 + sovBattle(uint64(l)) + l
	}
	return n
}

func (m *ModifyValueAct) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	if m.ModifyType != 0 {
		n += 1 + sovBattle(uint64(m.ModifyType))
	}
	l = len(m.McMovieID)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	if m.TextMovieID != 0 {
		n += 1 + sovBattle(uint64(m.TextMovieID))
	}
	if m.OwnerObjID != 0 {
		n += 1 + sovBattle(uint64(m.OwnerObjID))
	}
	return n
}

func (m *SkillStatusMovieAct) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovBattle(uint64(m.Type))
	}
	l = len(m.MovieId)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	if len(m.Targets) > 0 {
		l = 0
		for _, e := range m.Targets {
			l += sovBattle(uint64(e))
		}
		n += 1 + sovBattle(uint64(l)) + l
	}
	if m.PlayType != 0 {
		n += 1 + sovBattle(uint64(m.PlayType))
	}
	return n
}

func (m *MovieAct) Size() (n int) {
	var l int
	_ = l
	l = len(m.MovieID)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	if len(m.Targets) > 0 {
		l = 0
		for _, e := range m.Targets {
			l += sovBattle(uint64(e))
		}
		n += 1 + sovBattle(uint64(l)) + l
	}
	if m.PlayType != 0 {
		n += 1 + sovBattle(uint64(m.PlayType))
	}
	if m.OwnerObjID != 0 {
		n += 1 + sovBattle(uint64(m.OwnerObjID))
	}
	return n
}

func (m *TextMovieAct) Size() (n int) {
	var l int
	_ = l
	if m.MovieID != 0 {
		n += 1 + sovBattle(uint64(m.MovieID))
	}
	if len(m.Targets) > 0 {
		l = 0
		for _, e := range m.Targets {
			l += sovBattle(uint64(e))
		}
		n += 1 + sovBattle(uint64(l)) + l
	}
	if m.PlayType != 0 {
		n += 1 + sovBattle(uint64(m.PlayType))
	}
	if m.TargetCount != 0 {
		n += 1 + sovBattle(uint64(m.TargetCount))
	}
	if m.Value != 0 {
		n += 1 + sovBattle(uint64(m.Value))
	}
	if m.OwnerObjID != 0 {
		n += 1 + sovBattle(uint64(m.OwnerObjID))
	}
	return n
}

func (m *DrawCardItem) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBattle(uint64(m.Uid))
	}
	if len(m.Cards) > 0 {
		for _, e := range m.Cards {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	if m.MovieID != 0 {
		n += 1 + sovBattle(uint64(m.MovieID))
	}
	if m.OwnerObjID != 0 {
		n += 1 + sovBattle(uint64(m.OwnerObjID))
	}
	return n
}

func (m *DrawCardAct) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	return n
}

func (m *HandShowAct) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBattle(uint64(m.Uid))
	}
	return n
}

func (m *GuanxingAct) Size() (n int) {
	var l int
	_ = l
	if len(m.Uids) > 0 {
		l = 0
		for _, e := range m.Uids {
			l += sovBattle(uint64(e))
		}
		n += 1 + sovBattle(uint64(l)) + l
	}
	if len(m.SitOneDrawCards) > 0 {
		for _, e := range m.SitOneDrawCards {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	if len(m.SitTwoDrawCards) > 0 {
		for _, e := range m.SitTwoDrawCards {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	return n
}

func (m *ModifySkillAct) Size() (n int) {
	var l int
	_ = l
	if m.CardObjID != 0 {
		n += 1 + sovBattle(uint64(m.CardObjID))
	}
	if m.SkillID != 0 {
		n += 1 + sovBattle(uint64(m.SkillID))
	}
	if m.IsEquip {
		n += 2
	}
	return n
}

func (m *DisCardActItem) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBattle(uint64(m.Uid))
	}
	if len(m.CardObjIDs) > 0 {
		l = 0
		for _, e := range m.CardObjIDs {
			l += sovBattle(uint64(e))
		}
		n += 1 + sovBattle(uint64(l)) + l
	}
	if m.MovieID != 0 {
		n += 1 + sovBattle(uint64(m.MovieID))
	}
	return n
}

func (m *DisCardAct) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	return n
}

func (m *DestroyAct) Size() (n int) {
	var l int
	_ = l
	if len(m.Targets) > 0 {
		l = 0
		for _, e := range m.Targets {
			l += sovBattle(uint64(e))
		}
		n += 1 + sovBattle(uint64(l)) + l
	}
	return n
}

func (m *SummonAct) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBattle(uint64(m.Uid))
	}
	if m.GridObjID != 0 {
		n += 1 + sovBattle(uint64(m.GridObjID))
	}
	if m.Card != nil {
		l = m.Card.Size()
		n += 1 + l + sovBattle(uint64(l))
	}
	if m.IsInFog {
		n += 2
	}
	if m.IsPublicEnemy {
		n += 2
	}
	return n
}

func (m *ReturnAct) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBattle(uint64(m.Uid))
	}
	if m.CardObjID != 0 {
		n += 1 + sovBattle(uint64(m.CardObjID))
	}
	if m.Card != nil {
		l = m.Card.Size()
		n += 1 + l + sovBattle(uint64(l))
	}
	return n
}

func (m *SwitchPosAct) Size() (n int) {
	var l int
	_ = l
	if m.Target != 0 {
		n += 1 + sovBattle(uint64(m.Target))
	}
	if m.SwitchTarget != 0 {
		n += 1 + sovBattle(uint64(m.SwitchTarget))
	}
	return n
}

func (m *BonusReward) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBattle(uint64(m.Uid))
	}
	if m.BonusID != 0 {
		n += 1 + sovBattle(uint64(m.BonusID))
	}
	if len(m.Res) > 0 {
		for _, e := range m.Res {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	return n
}

func (m *BonusAct) Size() (n int) {
	var l int
	_ = l
	if len(m.Rewards) > 0 {
		for _, e := range m.Rewards {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	return n
}

func (m *CopyAct) Size() (n int) {
	var l int
	_ = l
	if m.Target != 0 {
		n += 1 + sovBattle(uint64(m.Target))
	}
	if m.CopyCard != nil {
		l = m.CopyCard.Size()
		n += 1 + l + sovBattle(uint64(l))
	}
	if m.OwnerUid != 0 {
		n += 1 + sovBattle(uint64(m.OwnerUid))
	}
	return n
}

func (m *EnterFogAct) Size() (n int) {
	var l int
	_ = l
	if m.Target != 0 {
		n += 1 + sovBattle(uint64(m.Target))
	}
	if m.IsPublicEnemy {
		n += 2
	}
	return n
}

func (m *LeaveFogAct) Size() (n int) {
	var l int
	_ = l
	if len(m.Targets) > 0 {
		l = 0
		for _, e := range m.Targets {
			l += sovBattle(uint64(e))
		}
		n += 1 + sovBattle(uint64(l)) + l
	}
	return n
}

func (m *GoldGobAct) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBattle(uint64(m.Uid))
	}
	if m.Gold != 0 {
		n += 1 + sovBattle(uint64(m.Gold))
	}
	if m.IsLadder {
		n += 2
	}
	return n
}

func (m *SwitchHandCardItem) Size() (n int) {
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovBattle(uint64(m.Uid))
	}
	if m.DisCardObjID != 0 {
		n += 1 + sovBattle(uint64(m.DisCardObjID))
	}
	if m.DrawCard != nil {
		l = m.DrawCard.Size()
		n += 1 + l + sovBattle(uint64(l))
	}
	if m.TextMovieID != 0 {
		n += 1 + sovBattle(uint64(m.TextMovieID))
	}
	l = len(m.McMovieID)
	if l > 0 {
		n += 1 + l + sovBattle(uint64(l))
	}
	return n
}

func (m *SwitchHandCardAct) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovBattle(uint64(l))
		}
	}
	return n
}

func (m *DelEquipAct) Size() (n int) {
	var l int
	_ = l
	if len(m.CardObjIDs) > 0 {
		l = 0
		for _, e := range m.CardObjIDs {
			l += sovBattle(uint64(e))
		}
		n += 1 + sovBattle(uint64(l)) + l
	}
	return n
}

func sovBattle(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozBattle(x uint64) (n int) {
	return sovBattle(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SendEmojiArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SendEmojiArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SendEmojiArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmojiID", wireType)
			}
			m.EmojiID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EmojiID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MovieEffect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MovieEffect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MovieEffect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MovieID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MovieID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayType", wireType)
			}
			m.PlayType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerObjID", wireType)
			}
			m.OwnerObjID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerObjID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiyFightCardInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiyFightCardInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiyFightCardInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardId", wireType)
			}
			m.CardId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiySkillId1", wireType)
			}
			m.DiySkillId1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiySkillId1 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiySkillId2", wireType)
			}
			m.DiySkillId2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiySkillId2 |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weapon", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Weapon = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Card) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Card: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Card: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Up", wireType)
			}
			m.Up = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Up |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Down", wireType)
			}
			m.Down = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Down |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			m.Left = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Left |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			m.Right = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Right |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiyInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DiyInfo == nil {
				m.DiyInfo = &DiyFightCardInfo{}
			}
			if err := m.DiyInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Effect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Effect = append(m.Effect, &MovieEffect{})
			if err := m.Effect[len(m.Effect)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Skills = append(m.Skills, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBattle
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Skills = append(m.Skills, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Skills", wireType)
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsInFog", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsInFog = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPublicEnemy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPublicEnemy = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Skin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Equip", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Equip == nil {
				m.Equip = &BattleEquip{}
			}
			if err := m.Equip.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BattleEquip) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BattleEquip: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BattleEquip: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EquipID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Skills = append(m.Skills, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBattle
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Skills = append(m.Skills, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Skills", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Fighter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fighter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fighter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hand", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hand = append(m.Hand, &Card{})
			if err := m.Hand[len(m.Hand)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CasterSkills = append(m.CasterSkills, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBattle
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CasterSkills = append(m.CasterSkills, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CasterSkills", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Camp", wireType)
			}
			m.Camp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Camp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PvpScore", wireType)
			}
			m.PvpScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PvpScore |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxHandAmount", wireType)
			}
			m.MaxHandAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxHandAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadImgUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeadImgUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadFrame", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeadFrame = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameText", wireType)
			}
			m.NameText = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NameText |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryFlag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CountryFlag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Grid) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Grid: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Grid: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjId", wireType)
			}
			m.ObjId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObjId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InGridCard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InGridCard == nil {
				m.InGridCard = &Card{}
			}
			if err := m.InGridCard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			m.Owner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Owner |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Effect", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Effect = append(m.Effect, &MovieEffect{})
			if err := m.Effect[len(m.Effect)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightDesk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightDesk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightDesk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeskId", wireType)
			}
			m.DeskId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeskId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grids", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Grids = append(m.Grids, &Grid{})
			if err := m.Grids[len(m.Grids)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fighter1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fighter1 == nil {
				m.Fighter1 = &Fighter{}
			}
			if err := m.Fighter1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fighter2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fighter2 == nil {
				m.Fighter2 = &Fighter{}
			}
			if err := m.Fighter2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scale", wireType)
			}
			m.Scale = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Scale |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BattleRes", wireType)
			}
			m.BattleRes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BattleRes |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFirstPvp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFirstPvp = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeasonBattle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeasonBattle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeasonBattle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Battle", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Battle == nil {
				m.Battle = &FightDesk{}
			}
			if err := m.Battle.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HandType", wireType)
			}
			m.HandType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HandType |= (BattleHandType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MyHandCards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MyHandCards = append(m.MyHandCards, &SkinGCard{})
			if err := m.MyHandCards[len(m.MyHandCards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arg = append(m.Arg[:0], dAtA[iNdEx:postIndex]...)
			if m.Arg == nil {
				m.Arg = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeasonRandomHand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeasonRandomHand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeasonRandomHand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChooseAmount", wireType)
			}
			m.ChooseAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChooseAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainTime", wireType)
			}
			m.RemainTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemainTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeasonBanHand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeasonBanHand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeasonBanHand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BanMyCardIdxs = append(m.BanMyCardIdxs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBattle
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BanMyCardIdxs = append(m.BanMyCardIdxs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BanMyCardIdxs", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MyRandomCards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MyRandomCards = append(m.MyRandomCards, &SkinGCard{})
			if err := m.MyRandomCards[len(m.MyRandomCards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BanEnemyCardIdxs = append(m.BanEnemyCardIdxs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBattle
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BanEnemyCardIdxs = append(m.BanEnemyCardIdxs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BanEnemyCardIdxs", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnemyBanCards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnemyBanCards = append(m.EnemyBanCards, &SkinGCard{})
			if err := m.EnemyBanCards[len(m.EnemyBanCards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeasonSwitchHand) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeasonSwitchHand: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeasonSwitchHand: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SwitchMyCardIdxs = append(m.SwitchMyCardIdxs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBattle
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SwitchMyCardIdxs = append(m.SwitchMyCardIdxs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchMyCardIdxs", wireType)
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SwitchEnemyCardIdxs = append(m.SwitchEnemyCardIdxs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBattle
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SwitchEnemyCardIdxs = append(m.SwitchEnemyCardIdxs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchEnemyCardIdxs", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnemySwitchCards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnemySwitchCards = append(m.EnemySwitchCards, &SkinGCard{})
			if err := m.EnemySwitchCards[len(m.EnemySwitchCards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeasonBattleReady) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeasonBattleReady: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeasonBattleReady: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ChooseCards = append(m.ChooseCards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBattle
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ChooseCards = append(m.ChooseCards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ChooseCards", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeasonBattleBegin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeasonBattleBegin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeasonBattleBegin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MyHand", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MyHand = append(m.MyHand, &Card{})
			if err := m.MyHand[len(m.MyHand)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnemyHand", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnemyHand = append(m.EnemyHand, &Card{})
			if err := m.EnemyHand[len(m.EnemyHand)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightBoutBegin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightBoutBegin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightBoutBegin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoutUid", wireType)
			}
			m.BoutUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BoutUid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &ClientAction{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoutTimeout", wireType)
			}
			m.BoutTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BoutTimeout |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BattleID", wireType)
			}
			m.BattleID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BattleID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightBoutCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightBoutCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightBoutCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseCardObjID", wireType)
			}
			m.UseCardObjID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseCardObjID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetGridId", wireType)
			}
			m.TargetGridId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetGridId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FightBoutResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FightBoutResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FightBoutResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoutUid", wireType)
			}
			m.BoutUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BoutUid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseCardObjID", wireType)
			}
			m.UseCardObjID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseCardObjID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetGridId", wireType)
			}
			m.TargetGridId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetGridId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &ClientAction{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinUid", wireType)
			}
			m.WinUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WinUid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardNeedTalk", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CardNeedTalk = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUseCardPublicEnemy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUseCardPublicEnemy = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsUseCardInFog", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsUseCardInFog = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BattleID", wireType)
			}
			m.BattleID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BattleID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeCardInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeCardInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeCardInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Old", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Old == nil {
				m.Old = &CardInfo{}
			}
			if err := m.Old.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field New", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.New == nil {
				m.New = &CardInfo{}
			}
			if err := m.New.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeResInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeResInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeResInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Old", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Old == nil {
				m.Old = &Resource{}
			}
			if err := m.Old.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field New", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.New == nil {
				m.New = &Resource{}
			}
			if err := m.New.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BattleResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BattleResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BattleResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinUid", wireType)
			}
			m.WinUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WinUid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeCards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangeCards = append(m.ChangeCards, &ChangeCardInfo{})
			if err := m.ChangeCards[len(m.ChangeCards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeRes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChangeRes = append(m.ChangeRes, &ChangeResInfo{})
			if err := m.ChangeRes[len(m.ChangeRes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasureID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TreasureID = append(m.TreasureID, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UpPvpLevelRewardCards = append(m.UpPvpLevelRewardCards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBattle
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UpPvpLevelRewardCards = append(m.UpPvpLevelRewardCards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UpPvpLevelRewardCards", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanShare", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanShare = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoTreasureReason", wireType)
			}
			m.NoTreasureReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NoTreasureReason |= (NoTreasureReasonEnum(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpRareTreasureModelID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpRareTreasureModelID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoSubStarReason", wireType)
			}
			m.NoSubStarReason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NoSubStarReason |= (BattleResult_NoSubStarReasonEnum(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadFightReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadFightReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadFightReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeskID", wireType)
			}
			m.DeskID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeskID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestoredFightDesk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestoredFightDesk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestoredFightDesk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Desk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Desk == nil {
				m.Desk = &FightDesk{}
			}
			if err := m.Desk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurBoutUid", wireType)
			}
			m.CurBoutUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurBoutUid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CampaignType", wireType)
			}
			m.CampaignType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CampaignType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CampaignLevel", wireType)
			}
			m.CampaignLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CampaignLevel |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LevelID", wireType)
			}
			m.LevelID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LevelID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FieldCnt", wireType)
			}
			m.FieldCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FieldCnt |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurBout", wireType)
			}
			m.CurBout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurBout |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoBattleData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoBattleData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoBattleData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &VideoAction{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShareUid", wireType)
			}
			m.ShareUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShareUid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (VideoAction_ActionID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InGridCard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InGridCard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InGridCard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GridID", wireType)
			}
			m.GridID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GridID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GCardID", wireType)
			}
			m.GCardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GCardID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Skin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Equip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Equip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FighterData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FighterData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FighterData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			m.ClientID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GateID", wireType)
			}
			m.GateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GateID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HandCards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HandCards = append(m.HandCards, &SkinGCard{})
			if err := m.HandCards[len(m.HandCards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrawCardPool", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DrawCardPool = append(m.DrawCardPool, &SkinGCard{})
			if err := m.DrawCardPool[len(m.DrawCardPool)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Camp", wireType)
			}
			m.Camp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Camp |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PvpScore", wireType)
			}
			m.PvpScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PvpScore |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsRobot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsRobot = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GridCards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GridCards = append(m.GridCards, &InGridCard{})
			if err := m.GridCards[len(m.GridCards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CasterSkills = append(m.CasterSkills, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBattle
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CasterSkills = append(m.CasterSkills, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CasterSkills", wireType)
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mmr", wireType)
			}
			m.Mmr = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mmr |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RobotID", wireType)
			}
			m.RobotID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RobotID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadImgUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeadImgUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeadFrame", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeadFrame = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameText", wireType)
			}
			m.NameText = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NameText |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinRate", wireType)
			}
			m.WinRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WinRate |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Area", wireType)
			}
			m.Area = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Area |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			m.Region = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Region |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CountryFlag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CountryFlag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BeginBattleArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BeginBattleArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BeginBattleArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BattleType", wireType)
			}
			m.BattleType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BattleType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fighter1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fighter1 == nil {
				m.Fighter1 = &FighterData{}
			}
			if err := m.Fighter1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fighter2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fighter2 == nil {
				m.Fighter2 = &FighterData{}
			}
			if err := m.Fighter2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedFortifications", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedFortifications = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BonusType", wireType)
			}
			m.BonusType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BonusType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedVideo", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NeedVideo = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpperType", wireType)
			}
			m.UpperType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpperType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFirstPvp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFirstPvp = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeasonPvpSession", wireType)
			}
			m.SeasonPvpSession = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeasonPvpSession |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexDiff", wireType)
			}
			m.IndexDiff = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexDiff |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BeginLevelBattleArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BeginLevelBattleArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BeginLevelBattleArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fighter1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fighter1 == nil {
				m.Fighter1 = &FighterData{}
			}
			if err := m.Fighter1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LevelID", wireType)
			}
			m.LevelID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LevelID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LoadBattleArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoadBattleArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoadBattleArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			m.ClientID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GateID", wireType)
			}
			m.GateID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GateID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BattleID", wireType)
			}
			m.BattleID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BattleID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			m.Region = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Region |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *C2SLoadFightArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: C2SLoadFightArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: C2SLoadFightArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsIgnorePve", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsIgnorePve = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelBattleArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelBattleArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelBattleArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BattleID", wireType)
			}
			m.BattleID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BattleID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogBattleArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogBattleArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogBattleArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BattleID", wireType)
			}
			m.BattleID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BattleID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			m.Event = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Event |= (LogBattleArg_BattleEvent(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OnRobotBattleEndArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OnRobotBattleEndArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OnRobotBattleEndArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RobotID", wireType)
			}
			m.RobotID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RobotID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsWin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsWin = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (ClientAction_ActionID(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttackAct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttackAct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttackAct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attacker", wireType)
			}
			m.Attacker = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Attacker |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinActs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WinActs = append(m.WinActs, &AttackWinAct{})
			if err := m.WinActs[len(m.WinActs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveActs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MoveActs = append(m.MoveActs, &MoveAct{})
			if err := m.MoveActs[len(m.MoveActs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AfterMoveActs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AfterMoveActs = append(m.AfterMoveActs, &ClientAction{})
			if err := m.AfterMoveActs[len(m.AfterMoveActs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsArrow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsArrow = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttackWinAct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttackWinAct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttackWinAct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeAttacker", wireType)
			}
			m.BeAttacker = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BeAttacker |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinPos", wireType)
			}
			m.WinPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WinPos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LosePos", wireType)
			}
			m.LosePos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LosePos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MoveAct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MoveAct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MoveAct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			m.Target = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Target |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetGrid", wireType)
			}
			m.TargetGrid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetGrid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MovieID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MovieID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MovePos", wireType)
			}
			m.MovePos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MovePos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerObjID", wireType)
			}
			m.OwnerObjID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerObjID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TurnOverAct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TurnOverAct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TurnOverAct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BeTurners = append(m.BeTurners, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBattle
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BeTurners = append(m.BeTurners, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BeTurners", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SkillAct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SkillAct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SkillAct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			m.Owner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Owner |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillID", wireType)
			}
			m.SkillID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &ClientAction{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveActs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MoveActs = append(m.MoveActs, &MoveAct{})
			if err := m.MoveActs[len(m.MoveActs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AfterMoveActs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AfterMoveActs = append(m.AfterMoveActs, &ClientAction{})
			if err := m.AfterMoveActs[len(m.AfterMoveActs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEquip", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEquip = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModifyValueActItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModifyValueActItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModifyValueActItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Targets = append(m.Targets, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBattle
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Targets = append(m.Targets, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModifyValueAct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModifyValueAct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModifyValueAct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &ModifyValueActItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifyType", wireType)
			}
			m.ModifyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModifyType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field McMovieID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.McMovieID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TextMovieID", wireType)
			}
			m.TextMovieID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TextMovieID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerObjID", wireType)
			}
			m.OwnerObjID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerObjID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SkillStatusMovieAct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SkillStatusMovieAct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SkillStatusMovieAct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MovieId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MovieId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Targets = append(m.Targets, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBattle
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Targets = append(m.Targets, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayType", wireType)
			}
			m.PlayType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MovieAct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MovieAct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MovieAct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MovieID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MovieID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Targets = append(m.Targets, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBattle
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Targets = append(m.Targets, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayType", wireType)
			}
			m.PlayType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerObjID", wireType)
			}
			m.OwnerObjID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerObjID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TextMovieAct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TextMovieAct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TextMovieAct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MovieID", wireType)
			}
			m.MovieID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MovieID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Targets = append(m.Targets, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBattle
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Targets = append(m.Targets, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayType", wireType)
			}
			m.PlayType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayType |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetCount", wireType)
			}
			m.TargetCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerObjID", wireType)
			}
			m.OwnerObjID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerObjID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DrawCardItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DrawCardItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DrawCardItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cards = append(m.Cards, &Card{})
			if err := m.Cards[len(m.Cards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MovieID", wireType)
			}
			m.MovieID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MovieID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerObjID", wireType)
			}
			m.OwnerObjID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerObjID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DrawCardAct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DrawCardAct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DrawCardAct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &DrawCardItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HandShowAct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HandShowAct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HandShowAct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GuanxingAct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GuanxingAct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GuanxingAct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Uids = append(m.Uids, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBattle
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Uids = append(m.Uids, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Uids", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SitOneDrawCards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SitOneDrawCards = append(m.SitOneDrawCards, &Card{})
			if err := m.SitOneDrawCards[len(m.SitOneDrawCards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SitTwoDrawCards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SitTwoDrawCards = append(m.SitTwoDrawCards, &Card{})
			if err := m.SitTwoDrawCards[len(m.SitTwoDrawCards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModifySkillAct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModifySkillAct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModifySkillAct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardObjID", wireType)
			}
			m.CardObjID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardObjID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillID", wireType)
			}
			m.SkillID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsEquip", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsEquip = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DisCardActItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DisCardActItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DisCardActItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CardObjIDs = append(m.CardObjIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBattle
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CardObjIDs = append(m.CardObjIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CardObjIDs", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MovieID", wireType)
			}
			m.MovieID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MovieID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DisCardAct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DisCardAct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DisCardAct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &DisCardActItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DestroyAct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DestroyAct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DestroyAct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Targets = append(m.Targets, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBattle
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Targets = append(m.Targets, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SummonAct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SummonAct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SummonAct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GridObjID", wireType)
			}
			m.GridObjID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GridObjID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Card", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Card == nil {
				m.Card = &Card{}
			}
			if err := m.Card.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsInFog", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsInFog = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPublicEnemy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPublicEnemy = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReturnAct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReturnAct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReturnAct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardObjID", wireType)
			}
			m.CardObjID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CardObjID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Card", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Card == nil {
				m.Card = &Card{}
			}
			if err := m.Card.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwitchPosAct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwitchPosAct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwitchPosAct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			m.Target = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Target |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwitchTarget", wireType)
			}
			m.SwitchTarget = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SwitchTarget |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BonusReward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BonusReward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BonusReward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BonusID", wireType)
			}
			m.BonusID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BonusID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Res", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Res = append(m.Res, &Resource{})
			if err := m.Res[len(m.Res)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BonusAct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BonusAct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BonusAct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rewards = append(m.Rewards, &BonusReward{})
			if err := m.Rewards[len(m.Rewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CopyAct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CopyAct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CopyAct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			m.Target = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Target |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyCard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CopyCard == nil {
				m.CopyCard = &Card{}
			}
			if err := m.CopyCard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerUid", wireType)
			}
			m.OwnerUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerUid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnterFogAct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnterFogAct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnterFogAct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			m.Target = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Target |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPublicEnemy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPublicEnemy = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeaveFogAct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeaveFogAct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeaveFogAct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Targets = append(m.Targets, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBattle
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Targets = append(m.Targets, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Targets", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GoldGobAct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GoldGobAct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GoldGobAct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			m.Gold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gold |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsLadder", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsLadder = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwitchHandCardItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwitchHandCardItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwitchHandCardItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisCardObjID", wireType)
			}
			m.DisCardObjID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DisCardObjID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrawCard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DrawCard == nil {
				m.DrawCard = &Card{}
			}
			if err := m.DrawCard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TextMovieID", wireType)
			}
			m.TextMovieID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TextMovieID |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field McMovieID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.McMovieID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SwitchHandCardAct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SwitchHandCardAct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SwitchHandCardAct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBattle
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &SwitchHandCardItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelEquipAct) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelEquipAct: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelEquipAct: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CardObjIDs = append(m.CardObjIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthBattle
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBattle
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CardObjIDs = append(m.CardObjIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CardObjIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBattle(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthBattle
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBattle(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBattle
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBattle
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthBattle
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowBattle
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipBattle(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthBattle = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBattle   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("battle.proto", fileDescriptorBattle) }

var fileDescriptorBattle = []byte{
	// 3334 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x3a, 0xcd, 0x6f, 0x23, 0x49,
	0xf5, 0xd3, 0xfe, 0x88, 0xed, 0xe7, 0x8f, 0xf4, 0x54, 0xb2, 0xfb, 0xf3, 0xce, 0x6f, 0x14, 0x42,
	0x6b, 0x76, 0x26, 0x3b, 0xb3, 0x64, 0x59, 0xef, 0x87, 0xc4, 0x69, 0x95, 0xc4, 0xc9, 0xac, 0x61,
	0xf2, 0xa1, 0x4a, 0x32, 0xc3, 0x4a, 0x8b, 0x44, 0xc7, 0xae, 0x78, 0x7a, 0xc7, 0xee, 0xf6, 0x76,
	0xb7, 0x93, 0xc9, 0xde, 0x38, 0x70, 0xe0, 0x0e, 0x08, 0xb8, 0x23, 0x21, 0x71, 0xe1, 0xc4, 0x91,
	0x1b, 0x12, 0x12, 0x12, 0x02, 0x21, 0x0e, 0xdc, 0x60, 0x91, 0x10, 0xdf, 0xe2, 0x1f, 0x00, 0xa1,
	0xf7, 0xaa, 0xaa, 0xbb, 0xba, 0xed, 0x24, 0xbb, 0x82, 0x93, 0xfb, 0x7d, 0x54, 0xd5, 0xab, 0xf7,
	0x5e, 0xbd, 0x8f, 0x2a, 0x43, 0xe3, 0xc4, 0x8d, 0xe3, 0x91, 0x58, 0x9f, 0x84, 0x41, 0x1c, 0xb0,
	0xc2, 0xe4, 0xe4, 0x16, 0xf4, 0xdd, 0x70, 0x20, 0xe1, 0x5b, 0x8d, 0x7e, 0x30, 0x1e, 0x07, 0xbe,
	0x82, 0x5a, 0x71, 0x28, 0xdc, 0x68, 0x1a, 0x2a, 0x6e, 0x67, 0x0d, 0x1a, 0x87, 0xc2, 0x1f, 0x6c,
	0x8f, 0x83, 0x0f, 0xbc, 0x8d, 0x70, 0xc8, 0xda, 0x50, 0xa1, 0xef, 0x5e, 0xb7, 0x6d, 0xad, 0x5a,
	0x6b, 0x65, 0xae, 0x41, 0xa7, 0x0f, 0xf5, 0xdd, 0xe0, 0xcc, 0x13, 0xdb, 0xa7, 0xa7, 0xa2, 0x1f,
	0x23, 0x23, 0x81, 0x8a, 0xb1, 0xc6, 0x35, 0xc8, 0x6e, 0x41, 0xf5, 0x60, 0xe4, 0x5e, 0x1c, 0x5d,
	0x4c, 0x44, 0xbb, 0x40, 0x73, 0x24, 0x30, 0x5b, 0x01, 0xd8, 0x3f, 0xf7, 0x45, 0xb8, 0x7f, 0xf2,
	0x41, 0xaf, 0xdb, 0x2e, 0x12, 0xd5, 0xc0, 0x38, 0xdf, 0xb3, 0xc0, 0xee, 0x7a, 0x17, 0x3b, 0xde,
	0xf0, 0x69, 0xbc, 0xe5, 0x86, 0x83, 0x9e, 0x7f, 0x1a, 0xb0, 0x17, 0x61, 0x81, 0xbe, 0x07, 0xb4,
	0x52, 0x93, 0x2b, 0x88, 0x31, 0x28, 0xed, 0xb9, 0x63, 0xb9, 0x48, 0x8d, 0xd3, 0x37, 0x5b, 0x85,
	0x7a, 0xd7, 0xbb, 0x38, 0x7c, 0xe6, 0x8d, 0x46, 0xbd, 0xc1, 0xeb, 0x6a, 0x05, 0x13, 0x95, 0xe5,
	0xe8, 0xb4, 0x4b, 0x79, 0x8e, 0x0e, 0xae, 0xf7, 0x44, 0xb8, 0x93, 0xc0, 0x6f, 0x97, 0x69, 0x66,
	0x05, 0x39, 0x7f, 0x2c, 0x40, 0x09, 0x97, 0x66, 0x2d, 0x28, 0x24, 0xc2, 0x14, 0x7a, 0x03, 0xb6,
	0x0c, 0x65, 0x14, 0x7f, 0xa0, 0xb6, 0x2b, 0x01, 0xe4, 0x3a, 0x9e, 0x28, 0x09, 0x0a, 0xc7, 0x13,
	0x14, 0xb7, 0x1b, 0x9c, 0xfb, 0x6a, 0x45, 0xfa, 0x46, 0xdc, 0x23, 0x71, 0x1a, 0xd3, 0x42, 0x65,
	0x4e, 0xdf, 0x38, 0x1b, 0xc7, 0xfd, 0xb7, 0x17, 0xe4, 0x6c, 0x04, 0xb0, 0x75, 0xa8, 0x74, 0xbd,
	0x0b, 0xd4, 0x47, 0xbb, 0xb2, 0x6a, 0xad, 0xd5, 0x3b, 0xcb, 0xeb, 0x93, 0x93, 0xf5, 0xbc, 0xae,
	0xb8, 0x66, 0x62, 0xf7, 0x60, 0x41, 0x5a, 0xaa, 0x5d, 0x5d, 0x2d, 0xae, 0xd5, 0x3b, 0x8b, 0xc8,
	0x6e, 0x18, 0x90, 0x2b, 0x32, 0xee, 0x96, 0x76, 0x1e, 0xb5, 0x6b, 0xab, 0xc5, 0xb5, 0x32, 0x57,
	0x10, 0x1a, 0xb8, 0x17, 0xf5, 0xfc, 0x9d, 0x60, 0xd8, 0x86, 0x55, 0x6b, 0xad, 0xca, 0x35, 0xc8,
	0xee, 0x40, 0xb3, 0x17, 0x1d, 0x4c, 0x4f, 0x46, 0x5e, 0x7f, 0xdb, 0x17, 0xe3, 0x8b, 0x76, 0x9d,
	0xe8, 0x59, 0x24, 0x6e, 0xed, 0xf0, 0x99, 0xe7, 0xb7, 0x1b, 0xd2, 0x3a, 0xf8, 0xcd, 0x5e, 0x86,
	0xf2, 0xf6, 0x87, 0x53, 0x6f, 0xd2, 0x6e, 0xd2, 0x16, 0x48, 0xa6, 0x4d, 0x72, 0x5e, 0x42, 0x73,
	0x49, 0x75, 0xde, 0x81, 0xba, 0x81, 0x25, 0x9f, 0xc4, 0x8f, 0xd4, 0xd5, 0x14, 0x68, 0xc8, 0x5e,
	0x30, 0x65, 0x77, 0x7e, 0x5b, 0x80, 0x0a, 0xe9, 0x45, 0x84, 0xcc, 0x86, 0xe2, 0xb1, 0x27, 0xad,
	0x55, 0xe2, 0xf8, 0xc9, 0x6e, 0x43, 0xe9, 0x5d, 0xd7, 0x1f, 0xd0, 0x98, 0x7a, 0xa7, 0x8a, 0x42,
	0xa0, 0xfe, 0x38, 0x61, 0x53, 0x63, 0x16, 0x4d, 0x63, 0x3a, 0xd0, 0xd8, 0x72, 0xa3, 0x58, 0x84,
	0x6a, 0xbd, 0x12, 0xad, 0x97, 0xc1, 0x25, 0xfe, 0x58, 0x36, 0xfc, 0x91, 0xa1, 0xcb, 0x8c, 0x27,
	0xca, 0x96, 0xf4, 0x4d, 0x07, 0xe4, 0x6c, 0x72, 0xd8, 0x0f, 0x42, 0x41, 0xb6, 0xc4, 0x03, 0xa2,
	0x60, 0xd4, 0xed, 0xae, 0xfb, 0x1c, 0x05, 0xd9, 0x18, 0x07, 0x53, 0x1f, 0xad, 0x87, 0x0c, 0x59,
	0x24, 0x1e, 0xa3, 0x77, 0x85, 0x3b, 0xe8, 0x8d, 0x87, 0xc7, 0xe1, 0xa8, 0x5d, 0xa3, 0xf5, 0x0c,
	0x0c, 0xbb, 0x0d, 0x35, 0x84, 0x76, 0x42, 0x14, 0x07, 0x88, 0x9c, 0x22, 0x70, 0x7d, 0x94, 0xed,
	0x48, 0x3c, 0x8f, 0xc9, 0x74, 0x65, 0x9e, 0xc0, 0x78, 0x3a, 0xb6, 0x70, 0x89, 0xf0, 0x62, 0x67,
	0xe4, 0x0e, 0x95, 0xf1, 0x4c, 0x94, 0xf3, 0x75, 0x0b, 0x4a, 0x0f, 0x43, 0xcf, 0x50, 0x94, 0x65,
	0x2a, 0x6a, 0x0d, 0xa0, 0xe7, 0x23, 0x1d, 0x55, 0x4a, 0x07, 0xc2, 0x54, 0xb1, 0x41, 0xa3, 0xf1,
	0x78, 0xf2, 0x49, 0xd1, 0x25, 0x2e, 0x81, 0x4f, 0xec, 0xb7, 0xce, 0xbf, 0x2c, 0xa8, 0x91, 0x8d,
	0xbb, 0x22, 0x7a, 0x86, 0x9e, 0x80, 0xbf, 0x3d, 0x6d, 0x68, 0x05, 0xa1, 0xfe, 0x8d, 0x40, 0x54,
	0x52, 0x41, 0xa8, 0x8c, 0x42, 0x44, 0xed, 0x62, 0xea, 0x00, 0x88, 0xe0, 0x12, 0xcd, 0xee, 0x41,
	0x55, 0x39, 0xcf, 0xeb, 0x74, 0x58, 0xeb, 0x9d, 0x3a, 0xb2, 0x28, 0x1c, 0x4f, 0x88, 0x06, 0x63,
	0x87, 0x8c, 0x7e, 0x09, 0x63, 0x07, 0xb7, 0x7a, 0xd8, 0x77, 0x47, 0x42, 0x1f, 0x69, 0x02, 0xd0,
	0x4a, 0xd2, 0xcd, 0xb9, 0x88, 0x94, 0x23, 0xa4, 0x08, 0xb4, 0x71, 0x2f, 0xda, 0xf1, 0xc2, 0x28,
	0x3e, 0x38, 0x9b, 0x90, 0x1b, 0x54, 0xb9, 0x81, 0x71, 0x7e, 0x60, 0x61, 0xe8, 0x76, 0xa3, 0xc0,
	0x97, 0x63, 0xd8, 0xcb, 0xb0, 0x20, 0xbf, 0x48, 0x05, 0xf5, 0x4e, 0x33, 0x91, 0x05, 0x75, 0xc1,
	0x15, 0x91, 0xad, 0x43, 0x15, 0x3d, 0x29, 0xd1, 0x4a, 0xab, 0xc3, 0xd2, 0x63, 0xa8, 0x29, 0x3c,
	0xe1, 0x61, 0xaf, 0x41, 0x7d, 0xf7, 0x02, 0x21, 0x34, 0x9a, 0xd6, 0x19, 0xcd, 0x8d, 0x47, 0xfa,
	0x21, 0x99, 0xd5, 0xe4, 0xc0, 0x03, 0xb7, 0x11, 0x0e, 0x49, 0x73, 0x0d, 0x8e, 0x9f, 0xce, 0x63,
	0xb0, 0xa5, 0xa4, 0xdc, 0xf5, 0x07, 0xc1, 0x98, 0x8e, 0x19, 0x1e, 0xa8, 0xa7, 0x41, 0x10, 0x09,
	0xe5, 0xe7, 0xd2, 0x40, 0x19, 0x1c, 0xaa, 0x80, 0x8b, 0xb1, 0xeb, 0xf9, 0x47, 0xde, 0x58, 0xe8,
	0x6c, 0x91, 0x62, 0x9c, 0x9f, 0x5b, 0xd0, 0xd4, 0x2a, 0xf0, 0x69, 0xd6, 0x3b, 0xd0, 0xdc, 0x74,
	0xfd, 0xdd, 0x0b, 0x99, 0x21, 0x9e, 0x47, 0x6d, 0x8b, 0xce, 0x69, 0x16, 0xc9, 0xde, 0x80, 0xe6,
	0xee, 0x85, 0x94, 0x45, 0x6e, 0xaa, 0x30, 0x6f, 0x53, 0x59, 0x1e, 0x76, 0x1f, 0xec, 0x4d, 0xd7,
	0xa7, 0xd8, 0x96, 0xcc, 0x5e, 0xa4, 0xd9, 0x67, 0xf0, 0xb8, 0x00, 0x21, 0x36, 0x5d, 0x5f, 0x2e,
	0x50, 0x9a, 0xbb, 0x40, 0x86, 0xc7, 0xf9, 0xa1, 0xa5, 0xd5, 0x74, 0x78, 0xee, 0xc5, 0xfd, 0xa7,
	0xb4, 0xa1, 0xfb, 0x60, 0x4b, 0x68, 0x66, 0x4f, 0x33, 0x78, 0xf6, 0x79, 0x58, 0x92, 0xb8, 0xac,
	0x90, 0x32, 0x34, 0xce, 0x23, 0xb1, 0x2f, 0x80, 0x4d, 0x08, 0x49, 0xbb, 0xc2, 0xc0, 0x33, 0x6c,
	0xce, 0x5b, 0x70, 0xd3, 0xf4, 0x3e, 0x2e, 0xdc, 0xc1, 0x05, 0x45, 0x0f, 0x32, 0x60, 0x3a, 0x55,
	0x93, 0x9b, 0x28, 0xe7, 0x2b, 0xd9, 0x61, 0x9b, 0x62, 0xe8, 0xf9, 0x6c, 0x15, 0x16, 0xa4, 0x03,
	0xd1, 0xd6, 0xcc, 0x78, 0xa1, 0xf0, 0xec, 0x2e, 0xd4, 0x48, 0x82, 0xb9, 0x71, 0x3b, 0x25, 0x39,
	0xdf, 0xb4, 0xa0, 0x45, 0x2e, 0xbf, 0x19, 0x4c, 0x63, 0x39, 0x79, 0x1b, 0x2a, 0x08, 0xa4, 0x39,
	0x40, 0x83, 0xec, 0x3e, 0x54, 0x36, 0xfa, 0xb1, 0x17, 0xf8, 0xda, 0x01, 0x6c, 0x9a, 0x72, 0xe4,
	0x09, 0x3f, 0x96, 0x04, 0xae, 0x19, 0x70, 0x67, 0x38, 0x0c, 0xdd, 0x2e, 0x98, 0xc6, 0xba, 0xae,
	0x30, 0x50, 0x18, 0x55, 0xe5, 0x9e, 0x7a, 0x5d, 0xf2, 0xfd, 0x12, 0x4f, 0x60, 0xe7, 0x31, 0x34,
	0x12, 0xa9, 0xb6, 0xc6, 0xe4, 0xfc, 0xc7, 0x52, 0x23, 0xb2, 0x10, 0x92, 0x11, 0x34, 0x83, 0x43,
	0x9e, 0x23, 0x37, 0x1c, 0x8a, 0x18, 0x83, 0x52, 0x52, 0x5b, 0x64, 0x70, 0xce, 0xaf, 0x0b, 0xb0,
	0x98, 0x4c, 0xcc, 0x45, 0x34, 0x1d, 0xc5, 0x57, 0xec, 0x37, 0xbf, 0x6a, 0xe1, 0x13, 0xac, 0x5a,
	0x9c, 0x5d, 0xd5, 0xd4, 0x5b, 0xe9, 0x3a, 0xbd, 0x61, 0x2d, 0xe5, 0xf9, 0x28, 0x4c, 0x59, 0xc6,
	0x65, 0x09, 0xc9, 0x7c, 0x1a, 0x0e, 0xf6, 0x84, 0x18, 0x1c, 0xb9, 0xa3, 0x67, 0x14, 0x18, 0xab,
	0x3c, 0x83, 0x63, 0x1d, 0x58, 0xee, 0x45, 0x4a, 0x3a, 0xb3, 0xdc, 0xa8, 0x10, 0xef, 0x5c, 0x1a,
	0xbb, 0x0b, 0xad, 0x04, 0x2f, 0x8b, 0x17, 0x19, 0x39, 0x73, 0xd8, 0x8c, 0xb5, 0x6a, 0x39, 0x6b,
	0x1d, 0x40, 0x6b, 0xeb, 0xa9, 0xeb, 0x0f, 0x45, 0x52, 0x81, 0xae, 0x40, 0x71, 0x7f, 0x34, 0x50,
	0x71, 0xb5, 0xa1, 0x1d, 0x8f, 0x0a, 0x2e, 0x24, 0x20, 0x7d, 0x4f, 0x9c, 0xab, 0x6c, 0x97, 0xa3,
	0xef, 0x89, 0x73, 0x67, 0x1f, 0x9a, 0x72, 0x46, 0x2e, 0xa2, 0x4b, 0x26, 0xe4, 0x22, 0x0a, 0xa6,
	0x61, 0x5f, 0x5c, 0x36, 0x61, 0x4a, 0xc7, 0x09, 0xbf, 0x56, 0x82, 0x46, 0x92, 0x2a, 0xd0, 0xea,
	0xa9, 0x9e, 0xad, 0x8c, 0x9e, 0xdf, 0xc4, 0x13, 0xa9, 0xf7, 0xa2, 0xfd, 0x9c, 0x02, 0x7e, 0x76,
	0x8b, 0xdc, 0x64, 0x63, 0xaf, 0x41, 0x2d, 0x91, 0x57, 0x05, 0x84, 0x9b, 0xe9, 0x18, 0xb5, 0x09,
	0x9e, 0xf2, 0x60, 0xa4, 0x3e, 0x52, 0x8d, 0x05, 0xb9, 0x7f, 0x11, 0x0b, 0x92, 0x14, 0xc3, 0xde,
	0x84, 0x17, 0x8e, 0x27, 0x07, 0x67, 0x93, 0x47, 0xe2, 0x4c, 0x8c, 0xb8, 0x38, 0x77, 0x43, 0x95,
	0x4e, 0xca, 0x14, 0x22, 0xe6, 0x13, 0xd1, 0x48, 0x5b, 0xae, 0x7f, 0xf8, 0xd4, 0x0d, 0x85, 0x72,
	0x90, 0x04, 0x66, 0x5d, 0xb0, 0xf7, 0x02, 0xbd, 0x02, 0xa7, 0x90, 0x42, 0x8e, 0xd1, 0xea, 0xb4,
	0x51, 0xd2, 0x3c, 0x6d, 0xdb, 0x9f, 0x8e, 0xf9, 0xcc, 0x08, 0x29, 0x17, 0x77, 0x43, 0xa1, 0xf1,
	0xbb, 0xc1, 0x40, 0x8c, 0x7a, 0x5d, 0xf2, 0x9a, 0x1a, 0x9f, 0x4f, 0x64, 0x7b, 0xb0, 0xb8, 0x17,
	0x1c, 0x4e, 0x4f, 0x0e, 0x63, 0x37, 0x54, 0x4b, 0xd7, 0x68, 0xe9, 0x3b, 0x69, 0x26, 0x95, 0x76,
	0x59, 0xcf, 0xf1, 0x91, 0x18, 0xf9, 0xc1, 0xce, 0x9b, 0xb0, 0x34, 0x87, 0x8f, 0x01, 0x2c, 0xec,
	0x05, 0xe1, 0xd8, 0x1d, 0xd9, 0x37, 0xd8, 0x4d, 0x68, 0x26, 0x2c, 0x07, 0xa1, 0x77, 0x66, 0x5b,
	0xce, 0x5d, 0x68, 0x3c, 0x0a, 0xdc, 0x01, 0x9d, 0x7f, 0x2e, 0x3e, 0x4c, 0x4a, 0xa0, 0x6e, 0xa6,
	0x04, 0xea, 0x3a, 0xff, 0xb4, 0xe0, 0x26, 0x17, 0x51, 0x1c, 0x84, 0x62, 0x90, 0x16, 0x4c, 0x9f,
	0x85, 0x12, 0xfe, 0xce, 0xaf, 0x15, 0x88, 0x84, 0x46, 0xdd, 0x9a, 0x86, 0x3a, 0x98, 0x14, 0x68,
	0x52, 0x03, 0x23, 0xcf, 0xf0, 0x78, 0xe2, 0x7a, 0x43, 0x9f, 0xaa, 0x09, 0x15, 0x2b, 0x4c, 0x1c,
	0x26, 0x64, 0x0d, 0x93, 0x79, 0x55, 0xf7, 0x93, 0x45, 0x62, 0xcc, 0xa2, 0x8f, 0x5e, 0x57, 0x75,
	0x42, 0x1a, 0x44, 0x17, 0xd8, 0xf1, 0xc4, 0x68, 0xb0, 0xe5, 0xeb, 0x7e, 0x28, 0x81, 0x71, 0x94,
	0x92, 0x46, 0x55, 0x4f, 0x1a, 0x74, 0xbe, 0x0c, 0x8b, 0x8f, 0xbd, 0x81, 0x08, 0xa4, 0x29, 0xba,
	0x6e, 0xec, 0xb2, 0x57, 0xd2, 0xa0, 0x65, 0xa5, 0x85, 0x25, 0x71, 0xe5, 0x63, 0xd6, 0x2d, 0xa8,
	0x92, 0x8f, 0xa5, 0xbb, 0x4e, 0x60, 0xe7, 0xdb, 0x16, 0xd4, 0x8d, 0x41, 0x6c, 0x0d, 0x0a, 0x4a,
	0xe1, 0xca, 0xf1, 0x0c, 0xe2, 0xba, 0xfc, 0xe9, 0x75, 0x79, 0xa1, 0xd7, 0xa5, 0xf6, 0xcf, 0x8d,
	0x5d, 0x9a, 0xb1, 0xc1, 0xe9, 0xdb, 0xe9, 0x41, 0x55, 0xf3, 0xa0, 0xb5, 0x8f, 0xfd, 0x67, 0x7e,
	0x70, 0x6e, 0xdf, 0x60, 0x35, 0x28, 0x53, 0xf2, 0xb2, 0x2d, 0xd6, 0x84, 0x5a, 0x92, 0xcb, 0xec,
	0x02, 0x6b, 0x01, 0x20, 0x28, 0x47, 0xd9, 0x45, 0x56, 0x81, 0xe2, 0xb6, 0x3f, 0xb0, 0x4b, 0xce,
	0x53, 0xb3, 0xee, 0x46, 0x5f, 0xa0, 0x60, 0xad, 0x53, 0x8b, 0x82, 0x50, 0x65, 0x94, 0xd0, 0x55,
	0xf4, 0x6f, 0x72, 0x0d, 0x26, 0xed, 0x5a, 0xd1, 0x68, 0xd7, 0x96, 0x75, 0xbb, 0x56, 0x22, 0xa4,
	0xea, 0xce, 0x7e, 0x55, 0x82, 0xba, 0xaa, 0x6c, 0x49, 0xb3, 0xb3, 0x0d, 0x16, 0x9e, 0x5b, 0xca,
	0x06, 0x6a, 0x99, 0x12, 0x4f, 0x60, 0x92, 0xcc, 0x8d, 0x85, 0xea, 0xfe, 0x9b, 0x5c, 0x41, 0xec,
	0x01, 0xd4, 0xd2, 0x22, 0x73, 0x6e, 0xb9, 0x94, 0xd2, 0xd9, 0xeb, 0xd0, 0xe8, 0x86, 0xee, 0x39,
	0x05, 0xff, 0x20, 0x18, 0x51, 0x14, 0x99, 0xe1, 0xcf, 0xb0, 0x24, 0xcd, 0xd9, 0xc2, 0x9c, 0xe6,
	0xac, 0x72, 0x49, 0x73, 0x56, 0xcd, 0x35, 0x67, 0xd4, 0x12, 0xf3, 0xe0, 0x24, 0x88, 0xe9, 0xbc,
	0x53, 0x4b, 0x4c, 0x20, 0x7b, 0x15, 0x6a, 0x5a, 0xf7, 0x51, 0x1b, 0x48, 0x9a, 0x16, 0x4a, 0x93,
	0x9a, 0x84, 0xa7, 0x0c, 0x33, 0xcd, 0x64, 0x7d, 0x4e, 0x33, 0x69, 0x43, 0x71, 0x77, 0x1c, 0x52,
	0x03, 0x56, 0xe6, 0xf8, 0x89, 0xab, 0xd3, 0x62, 0xbd, 0x2e, 0xb5, 0xcf, 0x25, 0xae, 0xc1, 0x5c,
	0x3b, 0xd8, 0xba, 0xba, 0x1d, 0x5c, 0xbc, 0xaa, 0x1d, 0xb4, 0x73, 0xed, 0x60, 0x1b, 0x2a, 0x4f,
	0x3c, 0x9f, 0xbb, 0xb1, 0x68, 0xdf, 0x94, 0x47, 0x4c, 0x81, 0xa8, 0xbb, 0x8d, 0x50, 0xb8, 0x6d,
	0x26, 0x75, 0x87, 0xdf, 0x68, 0x5b, 0x2e, 0x86, 0x5e, 0xe0, 0xb7, 0x97, 0xa4, 0x6d, 0x25, 0x94,
	0x6f, 0x2a, 0x97, 0x67, 0x9b, 0xca, 0x7f, 0x17, 0xa0, 0x45, 0x2e, 0x2e, 0x4f, 0xec, 0x46, 0x38,
	0xc4, 0x4d, 0x49, 0x80, 0x62, 0x8b, 0x74, 0x63, 0x03, 0xc3, 0x1e, 0x18, 0x5d, 0x5a, 0x21, 0xbd,
	0x4e, 0x30, 0x3c, 0xd3, 0xe8, 0xd4, 0x1e, 0x18, 0x9d, 0x5a, 0xf1, 0x6a, 0xe6, 0x0e, 0x5b, 0x07,
	0x86, 0x35, 0xc8, 0x4e, 0x10, 0xc6, 0xde, 0xa9, 0xd7, 0x77, 0x75, 0xa9, 0x83, 0x16, 0x9f, 0x43,
	0xa1, 0x3e, 0x2e, 0xf0, 0xa7, 0x11, 0x09, 0x5a, 0x56, 0x7d, 0x9c, 0x46, 0x20, 0x15, 0xc7, 0x50,
	0x5c, 0x50, 0x59, 0x2c, 0x45, 0x20, 0xf5, 0x78, 0x32, 0x11, 0x21, 0x8d, 0x55, 0x3d, 0x60, 0x82,
	0xb8, 0xae, 0x07, 0xa4, 0xee, 0x80, 0xf2, 0x05, 0xba, 0xa8, 0x88, 0x22, 0x4f, 0x65, 0x22, 0xec,
	0x0e, 0x72, 0x78, 0x5c, 0xa9, 0xe7, 0x0f, 0xc4, 0xf3, 0xae, 0x77, 0x7a, 0x4a, 0x77, 0x02, 0x65,
	0x9e, 0x22, 0x9c, 0xf7, 0x61, 0x89, 0xf4, 0x4f, 0x71, 0x37, 0x35, 0x82, 0xa9, 0x64, 0xeb, 0x3a,
	0x25, 0x1b, 0x51, 0xbc, 0x90, 0x89, 0xe2, 0xce, 0x37, 0x2c, 0x68, 0x62, 0xae, 0x4a, 0x27, 0xfe,
	0xdf, 0x04, 0x8d, 0x2b, 0x6a, 0x6e, 0xc3, 0x19, 0xcb, 0xa6, 0x33, 0x3a, 0x6f, 0xc0, 0xe2, 0x56,
	0xe7, 0x30, 0xc9, 0x9c, 0x28, 0xcc, 0x2a, 0xd4, 0x7b, 0x51, 0x6f, 0xe8, 0x07, 0xa1, 0x38, 0x38,
	0x93, 0xbe, 0x56, 0xe5, 0x26, 0xca, 0x79, 0x07, 0x16, 0xb7, 0x5c, 0xbf, 0x6f, 0xaa, 0x66, 0xee,
	0x0e, 0x12, 0x69, 0x0a, 0xb9, 0x9a, 0xf2, 0xa7, 0x16, 0x66, 0xeb, 0x61, 0x3a, 0xdc, 0x64, 0xb6,
	0x72, 0xa2, 0x77, 0xa0, 0xbc, 0x7d, 0x26, 0x54, 0x53, 0xdc, 0xea, 0xdc, 0x46, 0x95, 0x9b, 0x83,
	0xf5, 0x9d, 0x19, 0xf2, 0x70, 0xc9, 0x8a, 0xf3, 0x6d, 0x87, 0x61, 0x10, 0xee, 0x46, 0x43, 0x15,
	0xc3, 0x13, 0xd8, 0xe9, 0x25, 0xf7, 0x69, 0xc4, 0x7a, 0x49, 0xa6, 0x69, 0x40, 0x75, 0x7f, 0x22,
	0xfc, 0xc7, 0x9e, 0x38, 0xb7, 0x0b, 0x3a, 0xb1, 0x14, 0x11, 0xad, 0xab, 0x07, 0xbb, 0xe4, 0x6c,
	0xc3, 0xd2, 0xbe, 0x4f, 0x71, 0x47, 0xcd, 0xe8, 0x0f, 0xd4, 0xb5, 0xb1, 0x8e, 0x4d, 0x56, 0x36,
	0x36, 0x2d, 0x43, 0xb9, 0x17, 0x3d, 0xf1, 0x7c, 0xda, 0x4b, 0x95, 0x4b, 0xc0, 0xf9, 0x7e, 0x09,
	0x1a, 0x66, 0xc3, 0xc0, 0x5e, 0x31, 0xf2, 0xe8, 0x4b, 0xf9, 0x76, 0xe2, 0xfa, 0x44, 0xfa, 0x9b,
	0xe2, 0x25, 0x99, 0x14, 0x60, 0x61, 0x23, 0x8e, 0xdd, 0xfe, 0x33, 0xb9, 0xc1, 0xa3, 0x69, 0xe8,
	0xef, 0x9f, 0x89, 0xd0, 0x2e, 0xe0, 0xce, 0x29, 0xd4, 0xda, 0x45, 0xb6, 0x0c, 0x36, 0x7d, 0x1e,
	0xc6, 0x6e, 0x3c, 0x8d, 0xe8, 0xb2, 0xc9, 0x5e, 0x60, 0x8b, 0x50, 0xdf, 0x0d, 0x06, 0xde, 0xe9,
	0xc5, 0x63, 0x77, 0x34, 0x15, 0x76, 0x05, 0x53, 0x31, 0x06, 0x45, 0x49, 0xaf, 0xe1, 0x04, 0xf2,
	0x13, 0x70, 0x66, 0x9d, 0x6c, 0xec, 0x3a, 0xe9, 0x14, 0x8f, 0xbf, 0xdd, 0xc0, 0x21, 0xb2, 0x69,
	0x3e, 0x08, 0x22, 0xbb, 0x89, 0x7c, 0x98, 0xc4, 0x0e, 0x9f, 0x06, 0xe7, 0x76, 0x0b, 0xa1, 0x8d,
	0xc1, 0x40, 0x0a, 0xb1, 0x48, 0x73, 0x88, 0x91, 0x84, 0x6c, 0x56, 0x87, 0x4a, 0xd7, 0x8b, 0x68,
	0xc2, 0x9b, 0x04, 0x88, 0x28, 0x0e, 0x83, 0x0b, 0x9b, 0xe1, 0x8e, 0x0e, 0xa7, 0xe3, 0x71, 0xe0,
	0xdb, 0x4b, 0xf8, 0xcd, 0x45, 0x3c, 0x0d, 0x7d, 0x7b, 0x19, 0xc7, 0x3f, 0x9c, 0xba, 0xfe, 0x73,
	0xcf, 0x1f, 0xda, 0x2f, 0xb0, 0x2a, 0x94, 0xb6, 0x82, 0xc9, 0x85, 0xfd, 0x22, 0xe2, 0xb7, 0xfd,
	0x58, 0x84, 0x3b, 0xc1, 0xd0, 0xfe, 0x3f, 0x84, 0x1e, 0x09, 0xf7, 0x4c, 0x20, 0xd4, 0xc6, 0x89,
	0x1f, 0x06, 0xa3, 0xc1, 0xc3, 0xe0, 0xc4, 0x7e, 0x89, 0x31, 0x68, 0xa5, 0x17, 0x0f, 0xb4, 0xf2,
	0x2d, 0x25, 0x14, 0xe5, 0x7d, 0xfb, 0xff, 0x59, 0x53, 0xde, 0xec, 0x13, 0xed, 0x4f, 0x15, 0x56,
	0x83, 0xd2, 0x6e, 0x70, 0x26, 0xec, 0x3f, 0x57, 0x58, 0x4b, 0x5f, 0x65, 0xa1, 0xcf, 0xfc, 0x45,
	0xc2, 0x49, 0xd5, 0xf2, 0xd7, 0x0a, 0x5b, 0x94, 0x65, 0x8b, 0x2c, 0x8a, 0xed, 0xbf, 0x55, 0x98,
	0xad, 0x5d, 0x52, 0xb2, 0xfc, 0xbd, 0xc2, 0x96, 0xa0, 0x95, 0x54, 0xce, 0xd2, 0xdb, 0xfe, 0x51,
	0x71, 0x7e, 0x61, 0x41, 0x4d, 0xda, 0x6f, 0xa3, 0x4f, 0x3e, 0x2e, 0x01, 0x11, 0xaa, 0x84, 0x90,
	0xc0, 0xd8, 0x94, 0x3e, 0xf1, 0xfc, 0x8d, 0x7e, 0x9c, 0x69, 0xe6, 0x25, 0x59, 0x12, 0xb8, 0x66,
	0x60, 0xf7, 0xa0, 0x8a, 0x82, 0x13, 0xb3, 0xec, 0x6e, 0xea, 0xea, 0x96, 0x11, 0x71, 0x3c, 0x21,
	0xb2, 0xb7, 0xa1, 0xb9, 0x71, 0x1a, 0x8b, 0x30, 0xe1, 0xbe, 0xac, 0xdf, 0xcd, 0xb2, 0xc9, 0x42,
	0x61, 0x23, 0x0c, 0x83, 0x73, 0x0a, 0x3e, 0x54, 0x28, 0x10, 0xe8, 0x7c, 0x15, 0x1a, 0xa6, 0x4c,
	0x94, 0xe5, 0x44, 0x6e, 0x53, 0x06, 0x46, 0xf5, 0x75, 0x07, 0x41, 0xa4, 0x42, 0xaa, 0x82, 0x28,
	0xd6, 0x06, 0x91, 0x40, 0x42, 0x51, 0xc5, 0x5a, 0x09, 0x3a, 0xdf, 0xb2, 0xe8, 0x65, 0x06, 0x05,
	0xc1, 0xd1, 0xb2, 0x73, 0xd7, 0x65, 0xa0, 0x84, 0xa8, 0x5d, 0x4b, 0x3a, 0x7a, 0x35, 0xb3, 0x81,
	0x31, 0x1f, 0x77, 0x8a, 0xd9, 0xc7, 0x1d, 0x49, 0xa1, 0x75, 0x65, 0x25, 0xaf, 0xc1, 0xdc, 0xd3,
	0x4e, 0x79, 0xe6, 0x69, 0xe7, 0x01, 0xd4, 0xf5, 0xe9, 0x43, 0xd1, 0x30, 0x69, 0x0a, 0x44, 0x88,
	0x50, 0xdf, 0x68, 0xa5, 0x08, 0xe7, 0xf7, 0x16, 0x54, 0xe9, 0x28, 0x20, 0x6b, 0x72, 0x51, 0xac,
	0x2f, 0x9a, 0xe9, 0xa2, 0xb8, 0x0d, 0x15, 0xf9, 0x62, 0x93, 0x64, 0x1b, 0x05, 0x9a, 0xf7, 0x13,
	0xc5, 0xeb, 0xee, 0x27, 0x4c, 0x57, 0x28, 0x7d, 0x2a, 0x57, 0x28, 0x7f, 0x0a, 0x57, 0x90, 0x55,
	0xf4, 0x82, 0x76, 0x05, 0x59, 0x47, 0x77, 0x81, 0x19, 0xf1, 0x65, 0xa3, 0x1f, 0xf7, 0x62, 0x31,
	0xc6, 0xcd, 0x12, 0xac, 0x37, 0x4b, 0x00, 0xce, 0x22, 0xcd, 0xa3, 0xaf, 0xf3, 0x34, 0xe8, 0xfc,
	0xc4, 0x82, 0x56, 0x76, 0x1a, 0xf6, 0x2a, 0x94, 0x71, 0x2a, 0xdd, 0xe8, 0xbc, 0x28, 0x37, 0x94,
	0x5f, 0x89, 0x4b, 0x26, 0xb4, 0x9b, 0x24, 0x1a, 0xf7, 0xe4, 0x06, 0x06, 0x0d, 0xb5, 0xdb, 0xcf,
	0x7a, 0x43, 0x8a, 0xc0, 0xd4, 0x99, 0xc4, 0x44, 0x95, 0x84, 0xcb, 0xdc, 0x44, 0x5d, 0xeb, 0x17,
	0x17, 0xb0, 0x94, 0x0f, 0xbe, 0xb8, 0x09, 0x7d, 0x71, 0x6f, 0x19, 0x17, 0xf7, 0x89, 0x5b, 0x0e,
	0xd4, 0x9b, 0x9f, 0x06, 0x4d, 0xfd, 0x14, 0x33, 0xfa, 0xc9, 0xbc, 0x46, 0x96, 0xb2, 0xaf, 0x91,
	0xce, 0x47, 0x64, 0x7c, 0xb9, 0xde, 0xe5, 0xef, 0x99, 0x97, 0xea, 0x3e, 0x33, 0x77, 0xf1, 0xca,
	0x97, 0xce, 0xd2, 0xcc, 0xb6, 0x7f, 0x6c, 0x41, 0x23, 0x51, 0xd3, 0x1c, 0x01, 0xca, 0xff, 0xad,
	0x00, 0x68, 0x19, 0x62, 0xa3, 0x3a, 0x3b, 0xb1, 0x4c, 0x8a, 0x4a, 0x5d, 0xad, 0x6c, 0xba, 0x5a,
	0x56, 0xf0, 0x85, 0x19, 0xc1, 0x3f, 0x4a, 0x7b, 0x2f, 0x72, 0xd8, 0xd9, 0x3a, 0x68, 0x05, 0xca,
	0xe6, 0x6d, 0x53, 0x7a, 0x51, 0x2b, 0xd1, 0xf9, 0xe8, 0x62, 0xec, 0xf4, 0x3a, 0xa5, 0xbd, 0x05,
	0x75, 0xbd, 0x36, 0xaa, 0xec, 0x6e, 0xd6, 0xd1, 0xe9, 0x2c, 0x9a, 0xb2, 0x29, 0x17, 0x77, 0x3e,
	0x03, 0x75, 0x9d, 0x76, 0x71, 0xd8, 0x8c, 0xc4, 0x58, 0x9f, 0xd6, 0x75, 0xf2, 0x54, 0xce, 0x77,
	0xec, 0x0d, 0xe4, 0xbc, 0x25, 0x4e, 0xdf, 0xac, 0x03, 0x8b, 0x87, 0x5e, 0xbc, 0xef, 0x0b, 0xbd,
	0xc2, 0xec, 0xfe, 0xf2, 0x0c, 0x6a, 0xcc, 0xd1, 0x79, 0x90, 0x8e, 0x29, 0xce, 0x19, 0x63, 0x32,
	0x38, 0x27, 0xfa, 0x3c, 0x27, 0xf1, 0xef, 0x36, 0xd4, 0xf2, 0x57, 0xc5, 0x29, 0xe2, 0x8a, 0x38,
	0x68, 0x84, 0x9e, 0x62, 0x36, 0xf4, 0xbc, 0x0f, 0x2d, 0x55, 0x5d, 0xe8, 0xb0, 0x33, 0xcf, 0x8a,
	0x90, 0x2c, 0xa2, 0x1d, 0xcf, 0xc0, 0x5c, 0x6e, 0x45, 0xe7, 0x6d, 0x80, 0x74, 0x76, 0xb6, 0x96,
	0x35, 0x12, 0x93, 0xcf, 0xd6, 0xe6, 0xe2, 0xda, 0x4c, 0x77, 0x01, 0x54, 0x99, 0xa3, 0xce, 0x83,
	0xf6, 0x7a, 0x2b, 0x1b, 0xf2, 0xbe, 0x6b, 0x41, 0x4d, 0x96, 0x40, 0x73, 0xad, 0x89, 0xfa, 0xc2,
	0x2c, 0x66, 0x5e, 0x72, 0xa7, 0x08, 0x76, 0x5b, 0x3e, 0xe2, 0xab, 0x36, 0xd0, 0x78, 0xfd, 0xa5,
	0x8b, 0x13, 0xe3, 0xd5, 0xbb, 0x74, 0xcd, 0xab, 0x77, 0x79, 0xce, 0xab, 0xb7, 0xf3, 0x1e, 0xd4,
	0x64, 0x45, 0x76, 0xa9, 0x68, 0xf9, 0xfb, 0x77, 0xc3, 0x94, 0x57, 0x8a, 0xe6, 0x7c, 0x11, 0x1a,
	0x49, 0x2d, 0x79, 0x55, 0x72, 0x77, 0x34, 0x9f, 0xa2, 0xaa, 0x6b, 0x7e, 0x13, 0xe7, 0xbc, 0x07,
	0x75, 0x2a, 0x51, 0xe5, 0x6d, 0xeb, 0x1c, 0x41, 0xe9, 0x15, 0xc1, 0x9f, 0x46, 0xa9, 0x57, 0x29,
	0x90, 0xad, 0x40, 0x31, 0xbd, 0x15, 0xce, 0x5d, 0x4d, 0x73, 0x11, 0x39, 0x6f, 0x41, 0x95, 0x58,
	0x51, 0xc4, 0x57, 0xa0, 0x22, 0x57, 0xc8, 0x5c, 0xba, 0x19, 0x2b, 0x73, 0x4d, 0x77, 0xfa, 0x50,
	0xc1, 0x82, 0xf5, 0xaa, 0x8d, 0xdd, 0x81, 0x2a, 0xb2, 0xcc, 0x7d, 0x58, 0x4e, 0x28, 0x18, 0x13,
	0x29, 0x62, 0xe0, 0x86, 0xe4, 0xcb, 0x72, 0x02, 0x3b, 0x5f, 0x82, 0xba, 0xae, 0x85, 0xaf, 0x5e,
	0x28, 0x67, 0xea, 0xe2, 0x3c, 0x53, 0xdf, 0x83, 0xba, 0x2e, 0xa5, 0xaf, 0xf6, 0xd7, 0x3d, 0x00,
	0x55, 0x65, 0xcf, 0x77, 0x0a, 0x06, 0x25, 0xa4, 0xeb, 0x37, 0x6a, 0xfc, 0xc6, 0x5d, 0xf4, 0xa2,
	0x47, 0xee, 0x60, 0xa0, 0xde, 0xc7, 0xab, 0x3c, 0x81, 0x9d, 0x1f, 0x59, 0xc0, 0xb2, 0x95, 0xfa,
	0x25, 0x47, 0xd8, 0x81, 0x86, 0x3a, 0x69, 0x99, 0x07, 0x1f, 0x13, 0x87, 0x4a, 0xd5, 0xb1, 0x67,
	0xc6, 0xef, 0x12, 0xca, 0x27, 0x48, 0xf3, 0x99, 0x32, 0xa1, 0x9c, 0x2b, 0x13, 0x9c, 0x0d, 0xb8,
	0x99, 0x95, 0xf8, 0xb2, 0x3a, 0x65, 0x76, 0x5f, 0x3a, 0x3a, 0x7c, 0x0e, 0xea, 0xba, 0x15, 0x51,
	0x85, 0xb3, 0x11, 0x9e, 0xac, 0x7c, 0x78, 0xba, 0xbf, 0xa7, 0xdb, 0x89, 0xe4, 0x21, 0xbb, 0x05,
	0x20, 0xdb, 0x42, 0x84, 0xec, 0x1b, 0xb2, 0xab, 0x3a, 0x75, 0xb1, 0x21, 0xb1, 0xa8, 0x93, 0xa2,
	0xc7, 0x5e, 0xd9, 0xfa, 0x6e, 0xba, 0xbe, 0x5d, 0xa4, 0x56, 0x8b, 0xe4, 0xb1, 0x4b, 0x9b, 0xf6,
	0xcf, 0x3e, 0x5e, 0xb1, 0x7e, 0xf9, 0xf1, 0x8a, 0xf5, 0xbb, 0x8f, 0x57, 0xac, 0xef, 0xfc, 0x61,
	0xe5, 0xc6, 0xc9, 0x02, 0xfd, 0x83, 0xea, 0x8d, 0xff, 0x04, 0x00, 0x00, 0xff, 0xff, 0x8e, 0x5c,
	0x78, 0x8a, 0x7f, 0x25, 0x00, 0x00,
}
