// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: treasure.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type NoTreasureReasonEnum int32

const (
	NoTreasureReasonEnum_Unknow      NoTreasureReasonEnum = 0
	NoTreasureReasonEnum_NoPos       NoTreasureReasonEnum = 1
	NoTreasureReasonEnum_AmountLimit NoTreasureReasonEnum = 2
)

var NoTreasureReasonEnum_name = map[int32]string{
	0: "Unknow",
	1: "NoPos",
	2: "AmountLimit",
}
var NoTreasureReasonEnum_value = map[string]int32{
	"Unknow":      0,
	"NoPos":       1,
	"AmountLimit": 2,
}

func (x NoTreasureReasonEnum) String() string {
	return proto.EnumName(NoTreasureReasonEnum_name, int32(x))
}
func (NoTreasureReasonEnum) EnumDescriptor() ([]byte, []int) { return fileDescriptorTreasure, []int{0} }

type GetTreasuresArg_TreasureType int32

const (
	GetTreasuresArg_Reward GetTreasuresArg_TreasureType = 0
	GetTreasuresArg_Daily  GetTreasuresArg_TreasureType = 1
)

var GetTreasuresArg_TreasureType_name = map[int32]string{
	0: "Reward",
	1: "Daily",
}
var GetTreasuresArg_TreasureType_value = map[string]int32{
	"Reward": 0,
	"Daily":  1,
}

func (x GetTreasuresArg_TreasureType) String() string {
	return proto.EnumName(GetTreasuresArg_TreasureType_name, int32(x))
}
func (GetTreasuresArg_TreasureType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTreasure, []int{2, 0}
}

type Treasure struct {
	ID            uint32 `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	ModelID       string `protobuf:"bytes,2,opt,name=ModelID,proto3" json:"ModelID,omitempty"`
	OpenTimeout   int32  `protobuf:"varint,3,opt,name=OpenTimeout,proto3" json:"OpenTimeout,omitempty"`
	OpenStarCount int32  `protobuf:"varint,4,opt,name=OpenStarCount,proto3" json:"OpenStarCount,omitempty"`
	Pos           int32  `protobuf:"varint,5,opt,name=Pos,proto3" json:"Pos,omitempty"`
}

func (m *Treasure) Reset()                    { *m = Treasure{} }
func (m *Treasure) String() string            { return proto.CompactTextString(m) }
func (*Treasure) ProtoMessage()               {}
func (*Treasure) Descriptor() ([]byte, []int) { return fileDescriptorTreasure, []int{0} }

func (m *Treasure) GetID() uint32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Treasure) GetModelID() string {
	if m != nil {
		return m.ModelID
	}
	return ""
}

func (m *Treasure) GetOpenTimeout() int32 {
	if m != nil {
		return m.OpenTimeout
	}
	return 0
}

func (m *Treasure) GetOpenStarCount() int32 {
	if m != nil {
		return m.OpenStarCount
	}
	return 0
}

func (m *Treasure) GetPos() int32 {
	if m != nil {
		return m.Pos
	}
	return 0
}

type DailyTreasure struct {
	ID            uint32                  `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	ModelID       string                  `protobuf:"bytes,2,opt,name=ModelID,proto3" json:"ModelID,omitempty"`
	OpenStarCount int32                   `protobuf:"varint,3,opt,name=OpenStarCount,proto3" json:"OpenStarCount,omitempty"`
	IsOpen        bool                    `protobuf:"varint,4,opt,name=IsOpen,proto3" json:"IsOpen,omitempty"`
	NextTime      int32                   `protobuf:"varint,5,opt,name=NextTime,proto3" json:"NextTime,omitempty"`
	IsDouble      bool                    `protobuf:"varint,6,opt,name=IsDouble,proto3" json:"IsDouble,omitempty"`
	ShareInfo     *DailyTreasureShareInfo `protobuf:"bytes,7,opt,name=ShareInfo" json:"ShareInfo,omitempty"`
	RemainAmount  int32                   `protobuf:"varint,8,opt,name=RemainAmount,proto3" json:"RemainAmount,omitempty"`
	CompletedPro  int32                   `protobuf:"varint,9,opt,name=CompletedPro,proto3" json:"CompletedPro,omitempty"`
}

func (m *DailyTreasure) Reset()                    { *m = DailyTreasure{} }
func (m *DailyTreasure) String() string            { return proto.CompactTextString(m) }
func (*DailyTreasure) ProtoMessage()               {}
func (*DailyTreasure) Descriptor() ([]byte, []int) { return fileDescriptorTreasure, []int{1} }

func (m *DailyTreasure) GetID() uint32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *DailyTreasure) GetModelID() string {
	if m != nil {
		return m.ModelID
	}
	return ""
}

func (m *DailyTreasure) GetOpenStarCount() int32 {
	if m != nil {
		return m.OpenStarCount
	}
	return 0
}

func (m *DailyTreasure) GetIsOpen() bool {
	if m != nil {
		return m.IsOpen
	}
	return false
}

func (m *DailyTreasure) GetNextTime() int32 {
	if m != nil {
		return m.NextTime
	}
	return 0
}

func (m *DailyTreasure) GetIsDouble() bool {
	if m != nil {
		return m.IsDouble
	}
	return false
}

func (m *DailyTreasure) GetShareInfo() *DailyTreasureShareInfo {
	if m != nil {
		return m.ShareInfo
	}
	return nil
}

func (m *DailyTreasure) GetRemainAmount() int32 {
	if m != nil {
		return m.RemainAmount
	}
	return 0
}

func (m *DailyTreasure) GetCompletedPro() int32 {
	if m != nil {
		return m.CompletedPro
	}
	return 0
}

type GetTreasuresArg struct {
	TreasureType1 GetTreasuresArg_TreasureType `protobuf:"varint,1,opt,name=TreasureType1,proto3,enum=pb.GetTreasuresArg_TreasureType" json:"TreasureType1,omitempty"`
}

func (m *GetTreasuresArg) Reset()                    { *m = GetTreasuresArg{} }
func (m *GetTreasuresArg) String() string            { return proto.CompactTextString(m) }
func (*GetTreasuresArg) ProtoMessage()               {}
func (*GetTreasuresArg) Descriptor() ([]byte, []int) { return fileDescriptorTreasure, []int{2} }

func (m *GetTreasuresArg) GetTreasureType1() GetTreasuresArg_TreasureType {
	if m != nil {
		return m.TreasureType1
	}
	return GetTreasuresArg_Reward
}

type GetTreasuresReply struct {
	Treasures      []*Treasure    `protobuf:"bytes,1,rep,name=Treasures" json:"Treasures,omitempty"`
	DailyTreasure1 *DailyTreasure `protobuf:"bytes,2,opt,name=DailyTreasure1" json:"DailyTreasure1,omitempty"`
}

func (m *GetTreasuresReply) Reset()                    { *m = GetTreasuresReply{} }
func (m *GetTreasuresReply) String() string            { return proto.CompactTextString(m) }
func (*GetTreasuresReply) ProtoMessage()               {}
func (*GetTreasuresReply) Descriptor() ([]byte, []int) { return fileDescriptorTreasure, []int{3} }

func (m *GetTreasuresReply) GetTreasures() []*Treasure {
	if m != nil {
		return m.Treasures
	}
	return nil
}

func (m *GetTreasuresReply) GetDailyTreasure1() *DailyTreasure {
	if m != nil {
		return m.DailyTreasure1
	}
	return nil
}

type OpenTreasureArg struct {
	TreasureID uint32 `protobuf:"varint,1,opt,name=TreasureID,proto3" json:"TreasureID,omitempty"`
}

func (m *OpenTreasureArg) Reset()                    { *m = OpenTreasureArg{} }
func (m *OpenTreasureArg) String() string            { return proto.CompactTextString(m) }
func (*OpenTreasureArg) ProtoMessage()               {}
func (*OpenTreasureArg) Descriptor() ([]byte, []int) { return fileDescriptorTreasure, []int{4} }

func (m *OpenTreasureArg) GetTreasureID() uint32 {
	if m != nil {
		return m.TreasureID
	}
	return 0
}

type OpenTreasureReply struct {
	OK                 bool        `protobuf:"varint,1,opt,name=OK,proto3" json:"OK,omitempty"`
	CardIDs            []uint32    `protobuf:"varint,2,rep,packed,name=CardIDs" json:"CardIDs,omitempty"`
	ShareHid           int32       `protobuf:"varint,3,opt,name=ShareHid,proto3" json:"ShareHid,omitempty"`
	CanWatchAddCardAds bool        `protobuf:"varint,4,opt,name=CanWatchAddCardAds,proto3" json:"CanWatchAddCardAds,omitempty"`
	CardSkins          []string    `protobuf:"bytes,5,rep,name=CardSkins" json:"CardSkins,omitempty"`
	EmojiTeams         []int32     `protobuf:"varint,6,rep,packed,name=EmojiTeams" json:"EmojiTeams,omitempty"`
	Headframes         []string    `protobuf:"bytes,7,rep,name=Headframes" json:"Headframes,omitempty"`
	Resources          []*Resource `protobuf:"bytes,8,rep,name=Resources" json:"Resources,omitempty"`
	ConvertResources   []*Resource `protobuf:"bytes,9,rep,name=ConvertResources" json:"ConvertResources,omitempty"`
	UpLevelRewardCards []uint32    `protobuf:"varint,10,rep,packed,name=UpLevelRewardCards" json:"UpLevelRewardCards,omitempty"`
	TreasureID         string      `protobuf:"bytes,11,opt,name=TreasureID,proto3" json:"TreasureID,omitempty"`
}

func (m *OpenTreasureReply) Reset()                    { *m = OpenTreasureReply{} }
func (m *OpenTreasureReply) String() string            { return proto.CompactTextString(m) }
func (*OpenTreasureReply) ProtoMessage()               {}
func (*OpenTreasureReply) Descriptor() ([]byte, []int) { return fileDescriptorTreasure, []int{5} }

func (m *OpenTreasureReply) GetOK() bool {
	if m != nil {
		return m.OK
	}
	return false
}

func (m *OpenTreasureReply) GetCardIDs() []uint32 {
	if m != nil {
		return m.CardIDs
	}
	return nil
}

func (m *OpenTreasureReply) GetShareHid() int32 {
	if m != nil {
		return m.ShareHid
	}
	return 0
}

func (m *OpenTreasureReply) GetCanWatchAddCardAds() bool {
	if m != nil {
		return m.CanWatchAddCardAds
	}
	return false
}

func (m *OpenTreasureReply) GetCardSkins() []string {
	if m != nil {
		return m.CardSkins
	}
	return nil
}

func (m *OpenTreasureReply) GetEmojiTeams() []int32 {
	if m != nil {
		return m.EmojiTeams
	}
	return nil
}

func (m *OpenTreasureReply) GetHeadframes() []string {
	if m != nil {
		return m.Headframes
	}
	return nil
}

func (m *OpenTreasureReply) GetResources() []*Resource {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *OpenTreasureReply) GetConvertResources() []*Resource {
	if m != nil {
		return m.ConvertResources
	}
	return nil
}

func (m *OpenTreasureReply) GetUpLevelRewardCards() []uint32 {
	if m != nil {
		return m.UpLevelRewardCards
	}
	return nil
}

func (m *OpenTreasureReply) GetTreasureID() string {
	if m != nil {
		return m.TreasureID
	}
	return ""
}

type GainTreasure struct {
	Treasure *Treasure `protobuf:"bytes,1,opt,name=Treasure" json:"Treasure,omitempty"`
}

func (m *GainTreasure) Reset()                    { *m = GainTreasure{} }
func (m *GainTreasure) String() string            { return proto.CompactTextString(m) }
func (*GainTreasure) ProtoMessage()               {}
func (*GainTreasure) Descriptor() ([]byte, []int) { return fileDescriptorTreasure, []int{6} }

func (m *GainTreasure) GetTreasure() *Treasure {
	if m != nil {
		return m.Treasure
	}
	return nil
}

type ActivateRewardTreasureArg struct {
	TreasureID uint32 `protobuf:"varint,1,opt,name=TreasureID,proto3" json:"TreasureID,omitempty"`
}

func (m *ActivateRewardTreasureArg) Reset()         { *m = ActivateRewardTreasureArg{} }
func (m *ActivateRewardTreasureArg) String() string { return proto.CompactTextString(m) }
func (*ActivateRewardTreasureArg) ProtoMessage()    {}
func (*ActivateRewardTreasureArg) Descriptor() ([]byte, []int) {
	return fileDescriptorTreasure, []int{7}
}

func (m *ActivateRewardTreasureArg) GetTreasureID() uint32 {
	if m != nil {
		return m.TreasureID
	}
	return 0
}

type ActivateRewardTreasureReply struct {
	OK          bool  `protobuf:"varint,1,opt,name=OK,proto3" json:"OK,omitempty"`
	OpenTimeout int32 `protobuf:"varint,2,opt,name=OpenTimeout,proto3" json:"OpenTimeout,omitempty"`
}

func (m *ActivateRewardTreasureReply) Reset()         { *m = ActivateRewardTreasureReply{} }
func (m *ActivateRewardTreasureReply) String() string { return proto.CompactTextString(m) }
func (*ActivateRewardTreasureReply) ProtoMessage()    {}
func (*ActivateRewardTreasureReply) Descriptor() ([]byte, []int) {
	return fileDescriptorTreasure, []int{8}
}

func (m *ActivateRewardTreasureReply) GetOK() bool {
	if m != nil {
		return m.OK
	}
	return false
}

func (m *ActivateRewardTreasureReply) GetOpenTimeout() int32 {
	if m != nil {
		return m.OpenTimeout
	}
	return 0
}

type TargetTreasure struct {
	TreasureID uint32 `protobuf:"varint,1,opt,name=TreasureID,proto3" json:"TreasureID,omitempty"`
}

func (m *TargetTreasure) Reset()                    { *m = TargetTreasure{} }
func (m *TargetTreasure) String() string            { return proto.CompactTextString(m) }
func (*TargetTreasure) ProtoMessage()               {}
func (*TargetTreasure) Descriptor() ([]byte, []int) { return fileDescriptorTreasure, []int{9} }

func (m *TargetTreasure) GetTreasureID() uint32 {
	if m != nil {
		return m.TreasureID
	}
	return 0
}

func init() {
	proto.RegisterType((*Treasure)(nil), "pb.Treasure")
	proto.RegisterType((*DailyTreasure)(nil), "pb.DailyTreasure")
	proto.RegisterType((*GetTreasuresArg)(nil), "pb.GetTreasuresArg")
	proto.RegisterType((*GetTreasuresReply)(nil), "pb.GetTreasuresReply")
	proto.RegisterType((*OpenTreasureArg)(nil), "pb.OpenTreasureArg")
	proto.RegisterType((*OpenTreasureReply)(nil), "pb.OpenTreasureReply")
	proto.RegisterType((*GainTreasure)(nil), "pb.GainTreasure")
	proto.RegisterType((*ActivateRewardTreasureArg)(nil), "pb.ActivateRewardTreasureArg")
	proto.RegisterType((*ActivateRewardTreasureReply)(nil), "pb.ActivateRewardTreasureReply")
	proto.RegisterType((*TargetTreasure)(nil), "pb.TargetTreasure")
	proto.RegisterEnum("pb.NoTreasureReasonEnum", NoTreasureReasonEnum_name, NoTreasureReasonEnum_value)
	proto.RegisterEnum("pb.GetTreasuresArg_TreasureType", GetTreasuresArg_TreasureType_name, GetTreasuresArg_TreasureType_value)
}
func (m *Treasure) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Treasure) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.ID))
	}
	if len(m.ModelID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(len(m.ModelID)))
		i += copy(dAtA[i:], m.ModelID)
	}
	if m.OpenTimeout != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.OpenTimeout))
	}
	if m.OpenStarCount != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.OpenStarCount))
	}
	if m.Pos != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.Pos))
	}
	return i, nil
}

func (m *DailyTreasure) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DailyTreasure) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.ID))
	}
	if len(m.ModelID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(len(m.ModelID)))
		i += copy(dAtA[i:], m.ModelID)
	}
	if m.OpenStarCount != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.OpenStarCount))
	}
	if m.IsOpen {
		dAtA[i] = 0x20
		i++
		if m.IsOpen {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.NextTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.NextTime))
	}
	if m.IsDouble {
		dAtA[i] = 0x30
		i++
		if m.IsDouble {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ShareInfo != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.ShareInfo.Size()))
		n1, err := m.ShareInfo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.RemainAmount != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.RemainAmount))
	}
	if m.CompletedPro != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.CompletedPro))
	}
	return i, nil
}

func (m *GetTreasuresArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTreasuresArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TreasureType1 != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.TreasureType1))
	}
	return i, nil
}

func (m *GetTreasuresReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetTreasuresReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Treasures) > 0 {
		for _, msg := range m.Treasures {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTreasure(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.DailyTreasure1 != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.DailyTreasure1.Size()))
		n2, err := m.DailyTreasure1.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *OpenTreasureArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenTreasureArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TreasureID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.TreasureID))
	}
	return i, nil
}

func (m *OpenTreasureReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpenTreasureReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OK {
		dAtA[i] = 0x8
		i++
		if m.OK {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.CardIDs) > 0 {
		dAtA4 := make([]byte, len(m.CardIDs)*10)
		var j3 int
		for _, num := range m.CardIDs {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if m.ShareHid != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.ShareHid))
	}
	if m.CanWatchAddCardAds {
		dAtA[i] = 0x20
		i++
		if m.CanWatchAddCardAds {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.CardSkins) > 0 {
		for _, s := range m.CardSkins {
			dAtA[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.EmojiTeams) > 0 {
		dAtA6 := make([]byte, len(m.EmojiTeams)*10)
		var j5 int
		for _, num1 := range m.EmojiTeams {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0x32
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	if len(m.Headframes) > 0 {
		for _, s := range m.Headframes {
			dAtA[i] = 0x3a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Resources) > 0 {
		for _, msg := range m.Resources {
			dAtA[i] = 0x42
			i++
			i = encodeVarintTreasure(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ConvertResources) > 0 {
		for _, msg := range m.ConvertResources {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintTreasure(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.UpLevelRewardCards) > 0 {
		dAtA8 := make([]byte, len(m.UpLevelRewardCards)*10)
		var j7 int
		for _, num := range m.UpLevelRewardCards {
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		dAtA[i] = 0x52
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(j7))
		i += copy(dAtA[i:], dAtA8[:j7])
	}
	if len(m.TreasureID) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(len(m.TreasureID)))
		i += copy(dAtA[i:], m.TreasureID)
	}
	return i, nil
}

func (m *GainTreasure) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GainTreasure) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Treasure != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.Treasure.Size()))
		n9, err := m.Treasure.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *ActivateRewardTreasureArg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivateRewardTreasureArg) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TreasureID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.TreasureID))
	}
	return i, nil
}

func (m *ActivateRewardTreasureReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivateRewardTreasureReply) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OK {
		dAtA[i] = 0x8
		i++
		if m.OK {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OpenTimeout != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.OpenTimeout))
	}
	return i, nil
}

func (m *TargetTreasure) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TargetTreasure) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TreasureID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTreasure(dAtA, i, uint64(m.TreasureID))
	}
	return i, nil
}

func encodeVarintTreasure(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Treasure) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovTreasure(uint64(m.ID))
	}
	l = len(m.ModelID)
	if l > 0 {
		n += 1 + l + sovTreasure(uint64(l))
	}
	if m.OpenTimeout != 0 {
		n += 1 + sovTreasure(uint64(m.OpenTimeout))
	}
	if m.OpenStarCount != 0 {
		n += 1 + sovTreasure(uint64(m.OpenStarCount))
	}
	if m.Pos != 0 {
		n += 1 + sovTreasure(uint64(m.Pos))
	}
	return n
}

func (m *DailyTreasure) Size() (n int) {
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovTreasure(uint64(m.ID))
	}
	l = len(m.ModelID)
	if l > 0 {
		n += 1 + l + sovTreasure(uint64(l))
	}
	if m.OpenStarCount != 0 {
		n += 1 + sovTreasure(uint64(m.OpenStarCount))
	}
	if m.IsOpen {
		n += 2
	}
	if m.NextTime != 0 {
		n += 1 + sovTreasure(uint64(m.NextTime))
	}
	if m.IsDouble {
		n += 2
	}
	if m.ShareInfo != nil {
		l = m.ShareInfo.Size()
		n += 1 + l + sovTreasure(uint64(l))
	}
	if m.RemainAmount != 0 {
		n += 1 + sovTreasure(uint64(m.RemainAmount))
	}
	if m.CompletedPro != 0 {
		n += 1 + sovTreasure(uint64(m.CompletedPro))
	}
	return n
}

func (m *GetTreasuresArg) Size() (n int) {
	var l int
	_ = l
	if m.TreasureType1 != 0 {
		n += 1 + sovTreasure(uint64(m.TreasureType1))
	}
	return n
}

func (m *GetTreasuresReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Treasures) > 0 {
		for _, e := range m.Treasures {
			l = e.Size()
			n += 1 + l + sovTreasure(uint64(l))
		}
	}
	if m.DailyTreasure1 != nil {
		l = m.DailyTreasure1.Size()
		n += 1 + l + sovTreasure(uint64(l))
	}
	return n
}

func (m *OpenTreasureArg) Size() (n int) {
	var l int
	_ = l
	if m.TreasureID != 0 {
		n += 1 + sovTreasure(uint64(m.TreasureID))
	}
	return n
}

func (m *OpenTreasureReply) Size() (n int) {
	var l int
	_ = l
	if m.OK {
		n += 2
	}
	if len(m.CardIDs) > 0 {
		l = 0
		for _, e := range m.CardIDs {
			l += sovTreasure(uint64(e))
		}
		n += 1 + sovTreasure(uint64(l)) + l
	}
	if m.ShareHid != 0 {
		n += 1 + sovTreasure(uint64(m.ShareHid))
	}
	if m.CanWatchAddCardAds {
		n += 2
	}
	if len(m.CardSkins) > 0 {
		for _, s := range m.CardSkins {
			l = len(s)
			n += 1 + l + sovTreasure(uint64(l))
		}
	}
	if len(m.EmojiTeams) > 0 {
		l = 0
		for _, e := range m.EmojiTeams {
			l += sovTreasure(uint64(e))
		}
		n += 1 + sovTreasure(uint64(l)) + l
	}
	if len(m.Headframes) > 0 {
		for _, s := range m.Headframes {
			l = len(s)
			n += 1 + l + sovTreasure(uint64(l))
		}
	}
	if len(m.Resources) > 0 {
		for _, e := range m.Resources {
			l = e.Size()
			n += 1 + l + sovTreasure(uint64(l))
		}
	}
	if len(m.ConvertResources) > 0 {
		for _, e := range m.ConvertResources {
			l = e.Size()
			n += 1 + l + sovTreasure(uint64(l))
		}
	}
	if len(m.UpLevelRewardCards) > 0 {
		l = 0
		for _, e := range m.UpLevelRewardCards {
			l += sovTreasure(uint64(e))
		}
		n += 1 + sovTreasure(uint64(l)) + l
	}
	l = len(m.TreasureID)
	if l > 0 {
		n += 1 + l + sovTreasure(uint64(l))
	}
	return n
}

func (m *GainTreasure) Size() (n int) {
	var l int
	_ = l
	if m.Treasure != nil {
		l = m.Treasure.Size()
		n += 1 + l + sovTreasure(uint64(l))
	}
	return n
}

func (m *ActivateRewardTreasureArg) Size() (n int) {
	var l int
	_ = l
	if m.TreasureID != 0 {
		n += 1 + sovTreasure(uint64(m.TreasureID))
	}
	return n
}

func (m *ActivateRewardTreasureReply) Size() (n int) {
	var l int
	_ = l
	if m.OK {
		n += 2
	}
	if m.OpenTimeout != 0 {
		n += 1 + sovTreasure(uint64(m.OpenTimeout))
	}
	return n
}

func (m *TargetTreasure) Size() (n int) {
	var l int
	_ = l
	if m.TreasureID != 0 {
		n += 1 + sovTreasure(uint64(m.TreasureID))
	}
	return n
}

func sovTreasure(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTreasure(x uint64) (n int) {
	return sovTreasure(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Treasure) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasure
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Treasure: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Treasure: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTreasure
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenTimeout", wireType)
			}
			m.OpenTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenTimeout |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenStarCount", wireType)
			}
			m.OpenStarCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenStarCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTreasure(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasure
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DailyTreasure) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasure
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DailyTreasure: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DailyTreasure: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTreasure
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenStarCount", wireType)
			}
			m.OpenStarCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenStarCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOpen", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOpen = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextTime", wireType)
			}
			m.NextTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextTime |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDouble", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDouble = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShareInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasure
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShareInfo == nil {
				m.ShareInfo = &DailyTreasureShareInfo{}
			}
			if err := m.ShareInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainAmount", wireType)
			}
			m.RemainAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemainAmount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedPro", wireType)
			}
			m.CompletedPro = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompletedPro |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTreasure(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasure
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTreasuresArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasure
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTreasuresArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTreasuresArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasureType1", wireType)
			}
			m.TreasureType1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TreasureType1 |= (GetTreasuresArg_TreasureType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTreasure(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasure
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetTreasuresReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasure
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetTreasuresReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetTreasuresReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Treasures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasure
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Treasures = append(m.Treasures, &Treasure{})
			if err := m.Treasures[len(m.Treasures)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DailyTreasure1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasure
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DailyTreasure1 == nil {
				m.DailyTreasure1 = &DailyTreasure{}
			}
			if err := m.DailyTreasure1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTreasure(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasure
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenTreasureArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasure
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenTreasureArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenTreasureArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasureID", wireType)
			}
			m.TreasureID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TreasureID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTreasure(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasure
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpenTreasureReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasure
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpenTreasureReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpenTreasureReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OK", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OK = bool(v != 0)
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasure
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CardIDs = append(m.CardIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasure
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTreasure
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasure
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CardIDs = append(m.CardIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CardIDs", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShareHid", wireType)
			}
			m.ShareHid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShareHid |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanWatchAddCardAds", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CanWatchAddCardAds = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardSkins", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTreasure
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CardSkins = append(m.CardSkins, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasure
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EmojiTeams = append(m.EmojiTeams, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasure
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTreasure
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasure
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EmojiTeams = append(m.EmojiTeams, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EmojiTeams", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headframes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTreasure
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headframes = append(m.Headframes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasure
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, &Resource{})
			if err := m.Resources[len(m.Resources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConvertResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasure
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConvertResources = append(m.ConvertResources, &Resource{})
			if err := m.ConvertResources[len(m.ConvertResources)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasure
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UpLevelRewardCards = append(m.UpLevelRewardCards, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTreasure
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTreasure
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTreasure
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UpLevelRewardCards = append(m.UpLevelRewardCards, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UpLevelRewardCards", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasureID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTreasure
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TreasureID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTreasure(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasure
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GainTreasure) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasure
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GainTreasure: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GainTreasure: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Treasure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTreasure
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Treasure == nil {
				m.Treasure = &Treasure{}
			}
			if err := m.Treasure.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTreasure(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasure
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivateRewardTreasureArg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasure
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivateRewardTreasureArg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivateRewardTreasureArg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasureID", wireType)
			}
			m.TreasureID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TreasureID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTreasure(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasure
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivateRewardTreasureReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasure
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivateRewardTreasureReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivateRewardTreasureReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OK", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OK = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenTimeout", wireType)
			}
			m.OpenTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenTimeout |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTreasure(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasure
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TargetTreasure) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTreasure
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TargetTreasure: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TargetTreasure: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreasureID", wireType)
			}
			m.TreasureID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TreasureID |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTreasure(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTreasure
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTreasure(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTreasure
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTreasure
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTreasure
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTreasure
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTreasure(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTreasure = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTreasure   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("treasure.proto", fileDescriptorTreasure) }

var fileDescriptorTreasure = []byte{
	// 704 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0xdd, 0x6e, 0xd3, 0x4a,
	0x10, 0xae, 0xed, 0x93, 0x34, 0x9e, 0xfc, 0x34, 0x5d, 0x1d, 0x1d, 0xed, 0xe9, 0x39, 0x8a, 0x2c,
	0x0b, 0x24, 0xab, 0x17, 0x11, 0x0d, 0x37, 0x45, 0x48, 0x48, 0x21, 0x29, 0x6d, 0xd4, 0xd2, 0x54,
	0xdb, 0x54, 0x5c, 0x6f, 0xe2, 0x6d, 0x6b, 0x1a, 0x7b, 0x2d, 0xaf, 0xd3, 0x52, 0xae, 0x78, 0x02,
	0xae, 0xb9, 0xe1, 0x21, 0x78, 0x0b, 0x2e, 0x79, 0x04, 0x54, 0x5e, 0x04, 0xed, 0x3a, 0xfe, 0xc9,
	0x8f, 0x84, 0xe0, 0xce, 0xf3, 0xcd, 0x37, 0x9e, 0x99, 0x9d, 0x6f, 0x06, 0x1a, 0x71, 0xc4, 0xa8,
	0x98, 0x45, 0xac, 0x1d, 0x46, 0x3c, 0xe6, 0x48, 0x0f, 0xc7, 0x3b, 0xb5, 0x09, 0xf7, 0x7d, 0x1e,
	0x24, 0x88, 0xfd, 0x51, 0x83, 0xca, 0x68, 0x4e, 0x42, 0x0d, 0xd0, 0x07, 0x7d, 0xac, 0x59, 0x9a,
	0x53, 0x27, 0xfa, 0xa0, 0x8f, 0x30, 0x6c, 0xbe, 0xe6, 0x2e, 0x9b, 0x0e, 0xfa, 0x58, 0xb7, 0x34,
	0xc7, 0x24, 0xa9, 0x89, 0x2c, 0xa8, 0x0e, 0x43, 0x16, 0x8c, 0x3c, 0x9f, 0xf1, 0x59, 0x8c, 0x0d,
	0x4b, 0x73, 0x4a, 0xa4, 0x08, 0xa1, 0x47, 0x50, 0x97, 0xe6, 0x79, 0x4c, 0xa3, 0x1e, 0x9f, 0x05,
	0x31, 0xfe, 0x4b, 0x71, 0x16, 0x41, 0xd4, 0x04, 0xe3, 0x8c, 0x0b, 0x5c, 0x52, 0x3e, 0xf9, 0x69,
	0x7f, 0xd1, 0xa1, 0xde, 0xa7, 0xde, 0xf4, 0xfe, 0x0f, 0xaa, 0x5a, 0xc9, 0x69, 0xac, 0xcb, 0xf9,
	0x0f, 0x94, 0x07, 0x42, 0x42, 0xaa, 0xa4, 0x0a, 0x99, 0x5b, 0x68, 0x07, 0x2a, 0xa7, 0xec, 0x5d,
	0x2c, 0x1b, 0x98, 0x17, 0x94, 0xd9, 0xd2, 0x37, 0x10, 0x7d, 0x3e, 0x1b, 0x4f, 0x19, 0x2e, 0xab,
	0xa8, 0xcc, 0x46, 0xfb, 0x60, 0x9e, 0x5f, 0xd3, 0x88, 0x0d, 0x82, 0x4b, 0x8e, 0x37, 0x2d, 0xcd,
	0xa9, 0x76, 0x76, 0xda, 0xe1, 0xb8, 0xbd, 0xd0, 0x45, 0xc6, 0x20, 0x39, 0x19, 0xd9, 0x50, 0x23,
	0xcc, 0xa7, 0x5e, 0xd0, 0xf5, 0x55, 0xb9, 0x15, 0x95, 0x75, 0x01, 0x93, 0x9c, 0x1e, 0xf7, 0xc3,
	0x29, 0x8b, 0x99, 0x7b, 0x16, 0x71, 0x6c, 0x26, 0x9c, 0x22, 0x66, 0x7f, 0xd0, 0x60, 0xeb, 0x90,
	0xc5, 0x69, 0x2e, 0xd1, 0x8d, 0xae, 0xd0, 0x2b, 0xa8, 0xa7, 0xf6, 0xe8, 0x3e, 0x64, 0x7b, 0xea,
	0x01, 0x1b, 0x1d, 0x4b, 0x56, 0xb6, 0xc4, 0x6d, 0x17, 0x89, 0x64, 0x31, 0xcc, 0x7e, 0x0c, 0xb5,
	0x22, 0x80, 0x00, 0xca, 0x84, 0xdd, 0xd1, 0xc8, 0x6d, 0x6e, 0x20, 0x13, 0x4a, 0xaa, 0xc9, 0xa6,
	0x66, 0xbf, 0x87, 0xed, 0xe2, 0x5f, 0x09, 0x0b, 0xa7, 0xf7, 0x68, 0x17, 0xcc, 0x0c, 0xc1, 0x9a,
	0x65, 0x38, 0xd5, 0x4e, 0x4d, 0xe6, 0x4f, 0x41, 0x92, 0xbb, 0xd1, 0x33, 0x68, 0x2c, 0x3c, 0xd8,
	0x9e, 0x1a, 0x6e, 0xb5, 0xb3, 0xbd, 0xf2, 0x94, 0x64, 0x89, 0x68, 0xef, 0xc1, 0x96, 0x52, 0xde,
	0x1c, 0x90, 0xdd, 0xb7, 0x00, 0x52, 0x33, 0xd3, 0x4e, 0x01, 0xb1, 0x3f, 0x1b, 0xb0, 0x5d, 0x8c,
	0x49, 0xea, 0x6d, 0x80, 0x3e, 0x3c, 0x56, 0xec, 0x0a, 0xd1, 0x87, 0xc7, 0x52, 0x69, 0x3d, 0x1a,
	0xb9, 0x83, 0xbe, 0xc0, 0xba, 0x65, 0x38, 0x75, 0x92, 0x9a, 0x52, 0x0f, 0x6a, 0x8c, 0x47, 0x9e,
	0x3b, 0x17, 0x59, 0x66, 0xa3, 0x36, 0xa0, 0x1e, 0x0d, 0xde, 0xd0, 0x78, 0x72, 0xdd, 0x75, 0x5d,
	0x19, 0xd1, 0x75, 0xc5, 0x5c, 0x6b, 0x6b, 0x3c, 0xe8, 0x7f, 0x30, 0xe5, 0xe7, 0xf9, 0x8d, 0x17,
	0xc8, 0x4d, 0x30, 0x1c, 0x93, 0xe4, 0x80, 0xec, 0xe4, 0xc0, 0xe7, 0x6f, 0xbd, 0x11, 0xa3, 0xbe,
	0xc0, 0x65, 0xcb, 0x70, 0x4a, 0xa4, 0x80, 0x48, 0xff, 0x11, 0xa3, 0xee, 0x65, 0x44, 0x7d, 0x26,
	0xf0, 0xa6, 0x0a, 0x2f, 0x20, 0x72, 0x06, 0x84, 0x09, 0x3e, 0x8b, 0x26, 0x4c, 0xe0, 0x4a, 0x3e,
	0x83, 0x14, 0x24, 0xb9, 0x1b, 0xed, 0x43, 0xb3, 0xc7, 0x83, 0x5b, 0x16, 0xc5, 0x79, 0x88, 0xb9,
	0x26, 0x64, 0x85, 0x25, 0x7b, 0xbe, 0x08, 0x4f, 0xd8, 0x2d, 0x9b, 0x26, 0xe2, 0x90, 0xf5, 0x0b,
	0x0c, 0xea, 0xd1, 0xd6, 0x78, 0x96, 0xe6, 0x53, 0x55, 0x6b, 0x5c, 0x9c, 0xcf, 0x3e, 0xd4, 0x0e,
	0xa9, 0x97, 0x8d, 0x07, 0x39, 0xf9, 0x95, 0x52, 0xf3, 0x59, 0x16, 0x52, 0xe6, 0xb5, 0x9f, 0xc3,
	0xbf, 0xdd, 0x49, 0xec, 0xdd, 0xd2, 0x98, 0x25, 0x09, 0x7f, 0x47, 0x16, 0x43, 0xf8, 0x6f, 0x7d,
	0xf0, 0x7a, 0x7d, 0x2c, 0x5d, 0x41, 0x7d, 0xe5, 0x0a, 0xda, 0x4f, 0xa0, 0x31, 0xa2, 0xd1, 0x55,
	0xbe, 0x19, 0xbf, 0x2a, 0x61, 0xf7, 0x05, 0xfc, 0x7d, 0xca, 0xf3, 0xb4, 0x54, 0xf0, 0xe0, 0x20,
	0x98, 0xf9, 0x72, 0xef, 0x2e, 0x82, 0x9b, 0x80, 0xdf, 0x25, 0x7b, 0x77, 0xca, 0xcf, 0xb8, 0x68,
	0x6a, 0x68, 0x0b, 0xaa, 0xc9, 0xa1, 0x38, 0xf1, 0x7c, 0x2f, 0x6e, 0xea, 0x2f, 0x9b, 0x5f, 0x1f,
	0x5a, 0xda, 0xb7, 0x87, 0x96, 0xf6, 0xfd, 0xa1, 0xa5, 0x7d, 0xfa, 0xd1, 0xda, 0x18, 0x97, 0xd5,
	0xa5, 0x7f, 0xfa, 0x33, 0x00, 0x00, 0xff, 0xff, 0x98, 0x2c, 0x47, 0x35, 0x0d, 0x06, 0x00, 0x00,
}
